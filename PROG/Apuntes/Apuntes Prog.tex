\input{preambulo.tex}

%----------------------------------------------------------------------------------------
%	TÍTULO Y DATOS DEL ALUMNO
%----------------------------------------------------------------------------------------

\title{
\normalfont \normalsize
\textsc{{\bfseries Curso 2023-2024} \\ Ciclo Superior de Desarrollo de Aplicaciones Web \\ IES Aguadulce} \\ [25pt]
\horrule{0.5pt} \\[0.4cm]
\huge Programación \\
\horrule{0.5pt} \\[0.4cm]
}

\author{Francisco Javier Sueza Rodríguez}
\date{\normalsize\today}

%----------------------------------------------------------------------------------------
%                                     DOCUMENTO
%----------------------------------------------------------------------------------------
\makeglossaries
\loadglsentries{glossary.tex}

\begin{document}

\maketitle

\newpage

\tableofcontents

\listoffigures

%\listoftables

\newpage

\chapter{Introducción a la Programación}

En esta primera unidad vamos a estudiar los conceptos básicos de la programación de aplicaciones. Comenzaremos estudiando que es la programación, que técnicas podemos emplear, que herramientas podemos utilizar y cual es objetivo que pretendemos alcanzar. Analizaremos las diferentes paradigmas de programación  existentes, identificaremos las fases del desarrollo de un programa.

Una vez realizada una introducción general, detallaremos las características relevantes de los principales lenguajes de programación, para a continuación centrarnos en el lenguaje que vamos a usar durante toda esta asignatura, \textbf{Java}, dando a conocer también que herramientas podemos usar para que nuestro desarrollo sea más sencillo con este lenguaje.

\section{Programas: Buscando una Solución}
La principal razón que mueve  a una persona hacia el aprendizaje de la programación es utilizar el ordenador como una herramienta para resolver diferentes problemas. Al igual que en la vida real, las búsqueda y obtención de una solución requiere de una serie de \textbf{pasos fundamentales}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{Tema1/pasos-problemas.png}
    \caption{Pasos para la resolución de un problema}
\end{figure}

Para que una \textbf{solución} se considere \textbf{correcta} tiene que tener principalmente dos características:

\begin{itemize}
    \item \textbf{Corrección y Eficacia}: si resuelve el problema de forma adecuada.
    \item \textbf{Eficiencia}: si lo realiza en un tiempo mínimo y con un uso óptimo de los recursos del sistema.
\end{itemize}

Para construir esta solución, hay que tener en cuenta algunos conceptos ligados a la programación, como son:

\begin{enumerate}
    \item \textbf{Abstracción}: se trata de realizar una análisis del problema para descomponerlo en problemas más pequeños y de menos complejidad de manera precisa. \textbf{Divide y Vencerás}: es una filosofía general para resolver problemas y de aquí que no solo forme parte del vocabulario informático, sino que también se utiliza en otros muchos ámbitos.

    \item \textbf{Encapsulación}: consiste en ocultar la información de un objeto o función de forma que se pueda implementar de diferentes maneras sin que esto afecte al resto de objetos.

    \item \textbf{Modularidad}: estructuraremos cada parte en módulos independientes, cada uno con su función correspondiente.
\end{enumerate}

Todo estos conceptos, deberemos tenerlos en cuenta a la hora de analizar el problema, para llegar a un solución lo más óptima posible.

\subsection{Algoritmos y Programas}
Una vez realizado el análisis del problema, tenemos que diseñar y desarrollar un \textbf{algoritmo} adecuado que pueda solucionarlo. Pero, ¿que es un algoritmo?

Un \textbf{algoritmo} es una secuencia ordenada de pasos, descrita sin ambigüedades, que conducen a la solución de un problema.

Los algoritmos deben ser \textbf{independientes} de los \textbf{lenguajes de programación} y de las \textbf{computadoras} donde se ejecutan, de forma que puedan implementarse sobre cualquier ordenador empleando cualquier lenguaje de programación. Esto facilita que una misma solución pueda emplearse para el mismo problema en diferentes dispositivos.

La \textbf{diferencia} entre un algoritmo y un \textbf{programa} es que en este último lo pasos deben escribirse en un \textbf{lenguaje de programación concreto} para que pueda ser ejecutado en el ordenador y así obtener la solución deseada.

Los \textbf{lenguajes de programación} son solo un medio para expresar el algoritmo y el ordenador un procesador para ejecutarlo. El diseño de algoritmos es una tare que requiere de la creatividad y conocimientos de las técnicas de programación del programador, así, diferentes programadores pueden desarrollar diferentes algoritmos para resolver un mismo problema.

Las principales \textbf{características} que debe cumplir un \textbf{algoritmo} son:

\begin{itemize}
    \item Debe ser \textbf{preciso} e indicar el orden en el que se realiza cada paso.
    \item Debe estar \textbf{bien definido}, si se ejecuta dos o más veces, debemos obtener el mismo resultado.
    \item Debe ser \textbf{finito}, teniendo un número de pasos bien determinado.
\end{itemize}

Cuando los problemas complejos, debemos descomponer estos en subproblemas más simples, y estos a su vez en otros más pequeños. Es lo que se conoce como \textbf{diseño descendente} o \textbf{diseño modular} y se basa en el lema \textbf{Divide y Vencerás}.

Para \textbf{representar gráficamente} los algoritmos tenemos diferentes herramientas que nos ayudarán a describir su comportamiento de una forma precisa y genérica, que nos facilitará la implementación del algoritmo en diferentes lenguajes de programación. Las principales herramientas que tenemos son:

\begin{itemize}
    \item \textbf{Diagramas de Flujo}: esta técnica utiliza símbolos gráficos para representar el flujo de ejecución del algoritmo y suelen ser empleados en la fase de análisis.
    \item \textbf{Pseudocódigo}: se basa en el uso de palabras clave en lenguaje natural, representando las constantes, variables y otras estructuras de programación de forma escrita. Es la técnica mas utilizada actualmente.
    \item \textbf{Tablas de Decisión}: es un tabla que representa las diferentes condiciones del problema con sus respectivas acciones. Suele ser una técnica de apoyo a pseudocódigo cuando existen circunstancias condicionales complejas.
\end{itemize}

\section{Fases de la Programación}
Sea cual sea el estilo que escojamos para resolver el problema, deberemos realizar el proceso aplicando un método a nuestro trabajo. Así, el \textbf{proceso de creación de software} se puede dividir en las siguientes \textbf{fases}:

\begin{itemize}
    \item \textbf{Fase de resolución del problema}
    \item \textbf{Fase de implementación}
    \item \textbf{Fase de explotación y mantenimiento}
\end{itemize}

En los siguientes puntos, analizaremos cada una de estas fases.

\subsection{Resolución del Problema}
Esta es la primera fase del desarrollo del programa, para la cuál deberá estar bien definido cual es el problema que se quiere solucionar y tener un comprensión clara de éste para poder realizar su análisis y diseño. Esta fase se puede dividir en \textbf{dos etapas}:

\begin{enumerate}
    \item \textbf{Etapa de Análisis}:

    En esta primera etapa se debe analizar el problema, lo que nos va a indicar las especificaciones y requisitos que la aplicación debe cumplir. Para llevar esto acabo, se deberán realizar diferentes entrevistas entre el programador y el cliente/usuario para precisar cuales son las características que debe tener la aplicación, especificando, entre otras cosas, los procesos y estructuras que deberá tener ésta. La creación de \textbf{prototipos} será muy útil en esta fase para saber con mayor exactitud los puntos a tratar.

    Esta etapa proporcionará una idea general de lo que se solicita, realizando sucesivos refinamientos posteriormente que servirá para determinar cual es la información que ofrecerá la resolución del problema y que datos son necesarios para resolver este.

    \item \textbf{Etapa de Diseño}:

    En esta tapa se convierte la especificación de la etapa de análisis en un diseño más detallado que define el comportamiento o la secuencia lógica de instrucciones capaz de resolver el problema planteado. Estos pasos sucesivos, constituyen lo que ya hemos definido como algoritmo.

    Antes de pasar a la implementación del algoritmo, tenemos que tener claro que la solución que se propone es la adecuada. Para ello, toda solución necesitará de la \textbf{prueba} o \textbf{traza} del programa. Este procedimiento consistirá en el seguimiento paso a paso de cada instrucción del algoritmo utilizando los datos correctos. Si la solución aportada contiene errores, deberemos volver a la etapa de análisis, si no, podremos pasar a la fase de implementación.
\end{enumerate}

\subsection{Implementación}
Esta fase consiste en plasmar en un código la solución a la que hemos llegado en la fase de resolución del problema y consta de las siguientes etapas:

\begin{enumerate}
    \item \textbf{Etapa de Codificación}:

    Esta etapa consiste en transformar o traducir la solución a la que hemos llegado en un lenguaje de programación concreto. Para comprobar la estabilidad y calidad de la solución, deberemos realizar una serie de pruebas para comprobar que los módulos funcionan correctamente (\textbf{pruebas unitarias}), que dichos módulos funcionan bien entre ellos (\textbf{pruebas de interconexión}) y todo el conjunto funciona correctamente (\textbf{pruebas de integración}).

    Cuando realizamos la traducción deberemos tener en cuenta la reglas gramaticales y sintácticas del lenguaje de programación que estemos usando, lo que generará lo que se conoce como \textbf{código fuente}, es decir, el programa en sí mismo. Pero para que nuestro programa funcione correctamente, antes deberá ser traducido a \textbf{código máquina}, el único lenguaje que entiende el ordenador. Este proceso de traducción será llevado a cabo por un \textbf{compilador} o un \textbf{interprete}, dependiendo del lenguaje de programación que estemos empleando.

    Algunos de los términos que están asociados a esta fase son los siguientes:

    \begin{itemize}
        \item \textbf{Compilación}: proceso mediante el cual el código fuente, es decir, el conjunto de instrucciones escritas en un determinado lenguaje de programación, es traducido a código máquina, un código binario que es el único lenguaje que entiende el computador.

        \item \textbf{Compilador}: es la aplicación informática que se encarga de realizar la traducción. Esta recibe el código fuente, y tras realizar una análisis lexicográfico, semántico y sintáctico, generando en primer lugar un código intermedio sin optimizar, el cual se optimiza y genera el código objeto para la plataforma especifica.

        \item \textbf{Interprete}: aplicación informática capaz de analizar y traducir programas escritos en un determinado lenguaje de programación. A diferencia de los compiladores, que realizan una traducción completa del programa a lenguaje máquina, los interpretas van realizando la traducción a medida que va siendo necesaria, típicamente, realizándola instrucción por instrucción. Además, no suelen guardar los resultados de dicha traducción.
    \end{itemize}

    \item \textbf{Prueba, Ejecución y Validación}:

    Una vez que el programa ha sido codificado, estará listo para ser ejecutado. Para ello, deberemos implantar la aplicación en el sistema donde va a ser ejecutado para comprobar su funcionamiento correcto. Utilizando diferentes datos, se comprobará si el programa cumple con los requisitos que se han especificado, si se detectan nuevos errores o si la interfaz es amigable. Se trata de poner a prueba nuestro programa para ver su respuesta en diferentes situaciones.

    Mientas que el programa tenga errores, no podremos pasar a la siguiente fase. Una vez que se corrijan, se habrán generado diferentes documentos sobre la aplicación que entrarán el alguna de las siguientes dos categorías:

    \begin{itemize}
        \item \textbf{Documentación Interna}: encabezados, descripciones, declaraciones del problema y comentarios que se incluyen dentro de código fuente.

        \item \textbf{Documentación Externa}: son los manuales que se crean para una mejor ejecución y utilización del programa, así como los diferentes diagramas generados durante el proceso de desarrollo que nos ayuden a comprender mejor su funcionamiento y arquitectura.
    \end{itemize}
\end{enumerate}

\subsection{Explotación}
En esta última fase, el software ya esta instalado en el sistema y esta siendo de utilidad para los usuarios, siendo esta la \textbf{etapa de explotación}.

Periódicamente será necesario realizar evaluaciones y, si es necesario, llevar a cabo modificaciones para que el programa se adapte o actualice a las nuevas necesidades de los usuarios, pudiendo también realizarse la corrección de errores no detectados anteriormente. Esta es la \textbf{etapa de mantenimiento}.

Así, se define el \textbf{mantenimiento de software} como el proceso de mejora y optimización del software después de su entrega al usuario final. Involucra la realización de cambios para corregir defectos y dependencias encontradas durante su uso o para la adición de funcionalidades para mejorar su usabilidad y aplicabilidad.

Sera indispensable que se haya generado la documentación adecuada para facilitar la labor del programador en la compresión, uso y modificación de la aplicación.

\section{Ciclo de Vida del Software}
Sean cuales sean las fases que las fases en las que realicemos el proceso de desarrollo de software, siempre habrá que aplicar un \textbf{modelo de ciclo vida}, siendo este una sucesión de estados o fases por las cuales pasa el software a lo largo de su vida.

Este proceso debe tener siempre la siguientes etapas mínimas:

\begin{itemize}
    \item \textbf{Especificación} y \textbf{Análisis de Requisitos}
    \item \textbf{Diseño}
    \item \textbf{Codificación}
    \item \textbf{Pruebas}
    \item \textbf{Instalación} y \textbf{Producción}
    \item \textbf{Mantenimiento}
\end{itemize}

Existen diferentes modelos de desarrollo como el modelo en cascada, en espiral, incremental, evolutivo, etc.. En la siguiente \href{https://es.wikipedia.org/wiki/Proceso_del_desarrollo_del_software}{entrada de Wikipedia} podemos ver más información sobre el proceso de desarrollo de software y las diferentes metodologías.

\section{Lenguajes de Programación}
Como hemos visto en los puntos anteriores, una de las etapas del desarrollo es la codificación del programa. Para ello, emplearemos un lenguaje que exprese cada uno de los pasos que se deben ejecutar. Este lenguaje recibe el nombre de \textbf{lenguaje de programación}.

Se entiende por \textbf{lenguaje de programación} el conjunto de reglas sintácticas y semánticas, símbolos y palabras especiales establecidos para la construcción del programa. Todo lenguaje se compone de:

\begin{itemize}
    \item \textbf{Gramática}: reglas aplicables al conjunto de símbolos y palabras empleados en el lenguaje de programación para la construcción de sentencias correctas.
    \item \textbf{Léxico}: es el conjunto de símbolos y palabras especiales, es decir, el vocabulario del lenguaje.
    \item \textbf{Sintaxis}: son las posibles combinaciones de símbolos y palabras especiales.
    \item \textbf{Semántica}: es el significado de cada construcción del lenguaje, es decir, la acción que se llevará a cabo.
\end{itemize}

Los lenguajes permiten que los programadores pueden expresar el código de forma que sea legible para ellos y otros programadores. Estos se clasifican según lo cercanos que estén al lenguaje máquina o al lenguaje natural, así como si son lenguajes interpretados o compilados, lo que vamos a ver en los siguientes puntos.

\subsection{Lenguaje Máquina}
Este lenguajes es él único que entiende el ordenador y se compone de un conjunto de instrucciones codificadas en binario que se encarga de ejecutar el procesador. Este lenguaje es directamente interpretable por un circuito microprogramable.

Se trata del primer lenguaje utilizado para la programación de computadoras. De hecho, cada máquina tenía su propio conjunto de instrucciones codificadas en ceros y uno. Esto, evidentemente, genera un conjunto de \textbf{inconvenientes}:

\begin{itemize}
    \item Cada programa era válido \textbf{solo para un tipo de procesador} u ordenador.
    \item La \textbf{lectura} e \textbf{interpretación} de este tipo de programas es \textbf{extremadamente difícil}, por lo que realizar modificaciones resultaba extremadamente costoso.
    \item Los programadores de la época debían \textbf{memorizar largas cadenas de unos y ceros}, que equivalían a las instrucciones disponibles en los diferentes tipos de procesadores.
    \item Además, la introducción de estas cadenas suponía \textbf{largos tiempos de espera y posibles errores}.
\end{itemize}

En la siguiente tabla muestran algunos ejemplos de operaciones codificadas en binario.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{Tema1/ejemplo-binario.png}
    \caption{Operaciones en binario}
\end{figure}

Dada la dificultad de este lenguaje, con el tiempo fue sustituido por otros de más fácil compresión, aunque hay que tener en cuenta que en última instancia todos los lenguajes deben ser traducido a éste para que puedan ser interpretados y ejecutados por el ordenador.

\subsection{Lenguaje Ensamblador}
La evolución del lenguaje máquina fue el \textbf{lenguaje ensamblador}. En éste, las instrucciones ya no son secuencias binarias sino que son códigos de operación que describen operaciones básicas del procesador.

Estos códigos, conocidos como \textbf{mnemotécnicos}, son palabras especiales que sustituyen largas secuencias de unos y ceros, utilizadas para referirse a diferentes operaciones disponibles en el juego de instrucciones que soporta un procesador concreto.

En la siguiente tabla, podemos ver alguno ejemplos de estos mnemotécnicos con diferentes operaciones.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{Tema1/ejemplo-asm.png}
    \caption{Operaciones en ensamblador}
\end{figure}

Aunque el ensamblador fue un intento de acercar el lenguaje máquina al lenguaje humano, aún presentaba diferentes \textbf{dificultades}:
\begin{itemize}
    \item Los programas seguían \textbf{dependiendo} directamente del \textbf{hardware} que los soportaba.
    \item Los programadores debían \textbf{conocer} detalladamente \textbf{la máquina} sobre la que programaban, ya que debían hacer un uso adecuado de los recursos del sistema.
    \item La \textbf{lectura}, \textbf{interpretación} o \textbf{modificación} de los programas seguía presentando dificultades.
\end{itemize}

Todo programa escrito en ensamblador necesita ser traducido al lenguaje máquina para poder ser ejecutad. Esta función la lleva a cabo el \textbf{programa ensamblador}, el cual convierte el programa original escrito en lenguaje ensamblador (código fuente) en el programa traducido a lenguaje máquina (código objeto).

\subsection{Lenguajes Compilados}
Para paliar los defectos del lenguaje ensamblador y acercar los lenguajes de programación al lenguaje humano nacieron los \textbf{lenguajes compilados}.

 Así surgieron lenguajes como \textbf{Pascal}, \textbf{FORTRAN}, \textbf{Algol}, \textbf{C}, \textbf{C++}, etc. Estos lenguajes, más cercanos al humano, también se denominan \textbf{lenguajes de alto nivel}. Son más fáciles de utilizar y comprender, ya que las instrucciones que emplean y los signos que usan son fácilmente reconocibles por el programador.

 Entre las principales \textbf{ventajas} de estos lenguajes tenemos:
 \begin{itemize}
     \item Son mucho más \textbf{fáciles} de \textbf{aprender y utilizar} que sus predecesores.
     \item Se \textbf{reduce} el \textbf{tiempo} para desarrollar programas así como el \textbf{coste}.
     \item Son \textbf{independientes del hardware}, es decir, los programas pueden ejecutarse en diferentes tipos de máquina.
     \item La \textbf{lectura}, \textbf{modificación} e \textbf{interpretación} de los programas es \textbf{mucho más sencilla}.
 \end{itemize}

Un programa que este escrito en un lenguaje de alto nivel también tiene que \textbf{traducirse} a código máquina para que pueda ser ejecutado por el ordenador. Este trabajo, lo lleva a cabo el \textbf{compilador}, mediante un proceso de traducción que se conoce como \textbf{compilación}.

En la siguiente imagen podemos ver de forma mas ilustrativa cual es el proceso de compilación.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.50]{Tema1/compilador.png}
    \caption{Proceso de compilación}
\end{figure}

El compilador realizará la traducción y ademas \textbf{informará} de posibles \textbf{errores}. Una vez subsanados se generará el programa traducido a código máquina, conocido como \textbf{código objeto}. Este programa aún no puede ser ejecutado hasta que no se añadan los módulos de enlace o bibliotecas, durante el proceso de enlazado. Una vez realizado, se obtiene el \textbf{código ejecutable}.

\subsection{Lenguaje Interpretados}
Los lenguajes interpretados están diseñados para que su ejecución se realice a través de un \textbf{interprete}. Cada instrucción de un lenguaje interpretado se analiza, traduce y ejecuta tras haber sido verificada.

Un \textbf{interprete} es un traductor de lenguaje de alto nivel donde el proceso de traducción y ejecución se llevan a cabo simultáneamente, es decir, la instrucción se pasa al lenguaje máquina y se ejecuta directamente. No se genera código objeto ni ejecutable, como en los lenguajes compilados.

Los lenguajes interpretados tienen el inconveniente que son un poco más lentos que los lenguajes compilados, además, se necesita tener el intérprete instalado en la máquina donde se quiere ejecutar el programa, algo que no es necesario con los lenguajes compilados.

Algunos ejemplos de lenguajes interpretados son \textbf{Perl}, \textbf{PHP}, \textbf{Python} o \textbf{Javascript}, entre otros.

A medio camino entre los lenguajes compilados y los interpretados existen los lenguajes que podríamos llamar \textbf{pseudo-compilados} o \textbf{pseudo-interpretados}, como es el caso de \textbf{Java}. Java puede verse como un lenguaje compilado, pero también como un lenguaje interpretado, ya que su código fuente se compila para obtener el código binario conocido como \textbf{bytecode}, que son estructuras parecidas a las instrucciones máquina, con la importante propiedad de no se dependiente de ningún tipo de máquina. La \textbf{Maquina Virtual Java} se encargará de interpretar este código, y para su ejecución, lo traducirá al código máquina del procesador en particular donde se quiera ejecutar la aplicación.

\section{El Lenguaje de Programación Java}
Java es un lenguaje de programación con un sintaxis similar a C++, donde se han eliminado algunos de sus elementos complicados, como el tratamiento de punteros. Es un lenguaje \textbf{orientado a objetos} que nos permite la utilización de gran cantidad de bibliotecas fomentando la reutilización de código y evitando que tengamos que reescribir código ya existente.

Una de las principales virtudes de Java es su \textbf{independencia del hardware}, ya que el código que se genera es válido para cualquier plataforma. Este código será ejecutado en una maquina virtual denominada \textbf{Máquina Virtual Java} (JVM), que interpretará el código generado traduciéndolo al código máquina de la plataforma donde queramos ejecutarlo. De este modo, el programa se escribe una única vez y puede hacerse funcionar en cualquier lugar, llevando a la práctica el lema del lenguaje \textbf{``Write once, run everywhere''}.

Antes de la aparición de Java, el lenguaje de programación C era uno de los más versátiles y extendidos, pero cuando los programas en C aumentaban de volumen, su manejo se volvía muy complejo. Aunque mediante la programación modular y estructura se conseguía reducir esta complejidad, no era suficiente.

Fue entonces cuando entró en escena la \textbf{Programación Orientada a Objetos} (POO), aproximando más la construcción al pensamiento humano y haciendo más sencillo todo el proceso. Los problemas se dividen en objetos que tienen propiedades e interactúan con otros objetos, pudiendo el programador centrarse en cada objeto y los detalles las propiedades y funcionalidades que este posee. Fue entonces cuando surgió el lenguaje Java.

Las principales \textbf{características} del \textbf{lenguaje Java} son:

\begin{itemize}
    \item El código generado por el compilador es independiente del hardware.
    \item Es totalmente orientado a objetos.
    \item Su sintaxis es similar a C y C++.
    \item Es distribuido, es decir, preparado para aplicaciones TCP/IP.
    \item Dispone de un amplio conjunto de bibliotecas.
    \item Es robusto, realizando comprobaciones tanto en tiempo de compilación como de ejecución.
    \item La seguridad está garantizada, ya que las aplicaciones Java no acceden directamente a zonas delicadas de la memoria o el sistema.
\end{itemize}

\subsection{Breve Historia de Java}
Java surgió en 1991 cuando un pequeño grupo de ingenieros de Sun Microsystems trataron de diseñar un lenguaje de programación destinado a programar pequeños dispositivos electrónicos. El problema con estos dispositivos es que cambian rápidamente de un modelo a otro y el software debe ser reescrito, por lo que necesitaban un lenguaje que se fuera \textbf{independiente del dispositivo}.

No fue hasta 1995 cuando el lenguaje adoptó el nombre de Java, dándose a conocer al mundo como lenguaje de programación de computadores. El hecho de que sea un lenguaje orientado a objetos, independiente de la plataforma y su facilidad para la creación de aplicaciones TCP/IP, han hecho que Java sea uno de los lenguajes más utilizados.

El factor determinante para su expansión fue la inclusión de un interprete en la versión 2.0 del navegador Netscape, lo que supuso un gran revuelo en internet. A principio de 1997 apareció \textbf{Java 1.1}, que proporcionó sustanciales mejoras en el lenguaje. A finales de 1998 salió \textbf{Java 1.2}, posteriormente rebautizado como \textbf{Java 2}.

Para el desarrollo de programas en Java es necesario el uso de un entorno de desarrollo denominado \textbf{JDK} (Java Development Kit), que provee de un compilador y un entorno de ejecución, conocido como \textbf{JRE} (Java Runtime Environment), para ejecutar los bytecode generados. Al igual que el lenguaje, JDK y JRE han sido mejorados con cada versión del lenguaje.

\textbf{Java 2} es la tercera versión del lenguaje, pero no solo incluye el lenguaje, sino incluye:

\begin{itemize}
    \item El lenguaje de programación: Java.
    \item Un conjunto de bibliotecas estándar que vienen incluidas en el lenguaje y son necesarias en todo el entorno Java. Es el \textbf{Java Core}.
    \item Un conjunto de herramientas para el desarrollo de programas como compilador de bytecode, el generador de documentación, un depurador, etc...
    \item Un entorno de ejecución que en definitiva es una máquina virtual para ejecutar los bytecodes generados.
\end{itemize}

En la siguiente imagen podemos ver un esquema de los elementos de Java 2.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{Tema1/java2.png}
    \caption{Elementos de Java 2}
\end{figure}

Actualmente hay varias ediciones de la plataforma Java y que de forma resumida se podrían clasificar en:

\begin{itemize}
    \item \textbf{Java SE}: es la plataforma base para el desarrollo de aplicaciones con Java. Es usado para desarrollar aplicaciones de escritorio, applets y otros tipos de aplicaciones. Es fundamental, ya que es la basa en la que se cimienta el resto de plataformas Java.
    \item \textbf{Java EE}: es una plataforma de desarrollo de aplicaciones empresariales y del lado del servidor.
    \item \textbf{Java ME}: es una plataforma de desarrollo de aplicaciones para dispositivos móviles.
\end{itemize}

En \href{https://www.campusmvp.es/recursos/post/Descifrando-Java-lenguaje-plataforma-ediciones-implementaciones.aspx}{este enlace} puedes encontrar más información sobre las diferentes plataformas de Java y como trabajan entre ellas.

\subsection{La POO y Java}
En Java, los datos y el código (funciones o métodos) se combinan en entidades llamadas \textbf{objetos}. El objeto tendrá un \textbf{comportamiento} (su código interno) y un \textbf{estado} (los datos). Los objetos permiten la reutilización de código y pueden considerarse a sí mismos con piezas reutilizables en diferentes proyectos. Esta característica permite reducir el tiempo de desarrollo de aplicaciones.

Al incorporar los conceptos de Programación Orientada a Objetos (POO), Java incluye las tres características propias de este paradigma de programación:

\begin{itemize}
    \item \textbf{Encapsulación}: se denomina así al ocultamiento de la información interna de un objeto. Este solo se puede modificar a través de sus operaciones definidas.
    \item \textbf{Herencia}: mecanismo que permite derivar una clase de otra, de manera que extienda su funcionalidad.
    \item \textbf{Polimorfismo}: capacidad para que varias clases derivada de otra utilicen un mismo método de forma diferentes.
\end{itemize}

Los patrones o tipos de objetos se denominan \textbf{clases} y los objetos que utilizan estos patrones o pertenecen a dichos tipos se denominan \textbf{instancias}.

En la siguiente figura podemos ver algunas de las ventajas de la POO de forma más esquemática.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.30]{Tema1/ventajas-poo.png}
    \caption{Ventajas de la POO}
\end{figure}

\subsection{Independencia de la Plataforma}
Hay dos características de distinguen a Java de otros lenguajes de programación, como son la \textbf{independencia de la plataforma} y la posibilidad de \textbf{crear aplicaciones} para \textbf{trabajar en red}.

Estas características consisten en:
\begin{itemize}
    \item \textbf{Independencia}: los programas escritos en Java pueden ser ejecutados en cualquier tipo de hardware. El código fuente se compila generando el código conocido como Java Bytecode, el cual será interpretado y ejecutado por la \textbf{Máquina Virtual Java}, que es un programa escrito en código nativo de la plataforma destino. Con eso se evita tener que realizar un programada diferente para diferentes CPUs.

    \item \textbf{Trabajo en red}: esta capacidad del lenguaje ofrece múltiples posibilidades para la comunicación vía TCP/IP. Para poder hacer esto, existen librerías que permiten el acceso y la interacción con protocolos como \textbf{http}, \textbf{ftp}, etc.., facilitando las tareas del programador para el tratamiento de la información.
\end{itemize}

\subsection{Seguridad y Simplicidad}
Además de las características vistas en el punto anterior, cabe destacar dos virtudes de este lenguaje que hacen que este tan extendido: la \textbf{seguridad} y la \textbf{simplicidad}.

\begin{itemize}
    \item \textbf{Seguridad}: en primer lugar, el acceso a zonas sensibles de memoria que podemos tener en otros lenguajes como C o C++ se han eliminado en Java.

    En segundo lugar, el código en Java se comprueba y verifica para evitar que determinadas secciones del código produzcan efectos adversos. Los test que se aplican garantizan que las operaciones, operandos, conversiones y uso de clases son seguras.

    En definitiva, podemos afirmar que Java es un lenguaje seguro.

    \item \textbf{Simplicidad}: aunque Java es tan potente como C o C++, es bastante más sencillo. Tiene una curva de aprendizaje muy rápida y para alguien que aprende a programar con este lenguaje, le resultará más fácil comenzar a escribir aplicaciones interesantes.

    Java elimina ciertos mecanismos complejos que si encontramos en C o C++ como pueden ser la aritmética de punteros, los registros, la definición de tipos, la gestión de memoria, etc.., reduciendo considerablemente la posibilidad de cometer errores comunes en otros lenguajes de programación.

    Un elemento que ayuda a la simplicidad de Java es el \textbf{Recolector de Basura} (Garbage Collector), que permite al programador liberarse de la gestión de memoria y hace que ciertos bloques de memoria puedan reaprovecharse, disminuyendo el número de huevos libres, lo que se conoce como \textbf{fragmentación de memoria}.
\end{itemize}

Como vemos, además de ser independiente de la plataforma, Java es un lenguaje más seguro y simple que otros parecidos, manteniendo la misma potencia que estos.

\subsection{Java y los Bytecodes}
Un programa en Java no es directamente ejecutable, es necesario que el código sea interpretado por la Máquina Virtual.

Una vez escrito el código fuente (con extensión .java), este es precompilado generándose los códigos de bytes o Bytecodes (con extensión .class), que serán interpretados directamente por la Máquina Virtual y traducidos a código nativo de la plataforma donde queramos ejecutarlo.

Un \textbf{Bytecode} es un conjunto de instrucciones en lenguaje máquina que no son específicos de ningún procesador o sistema de cómputo. Un intérprete de bytes para una plataforma concreta será el que los ejecute. A este interprete también se les conoce como Máquina Virtual Java.

En el proceso de compilación, existe un verificador de códigos de bytes que se asegurará que se cumplen las siguientes condiciones:

\begin{itemize}
    \item El código satisface las especificaciones de la Máquina Virtual Java.
    \item No existe amenaza contra la integridad del sistema.
    \item No se produce desbordamiento de memoria.
    \item Los parámetros y sus tipos son adecuados.
    \item No existen conversiones de datos no permitidas.
\end{itemize}

Para que un bytecode puede ser ejecutado en cualquier plataforma es imprescindible que la plataforma cuente con el intérprete adecuado, es decir, la \textbf{máquina virtual} específica para \textbf{dicha plataforma}.

\section{Programas en Java}
Hasta ahora hemos descrito el lenguaje de programación Java y hablado un poco sobre su historia y características. En este punto, ya vamos a empezar ha hablar de los programas en Java, cuales son su elementos básicos, como debemos escribir el código y los tipos de aplicaciones que podremos crear con este lenguaje.

\subsection{Estructura de un Programa}
En la siguiente figura, se presenta una estructura general de un programa en Java, la cual vamos a explicar en esta sección punto por punto.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.40]{Tema1/estructura-java.png}
    \caption{Estructura general de un programa en Java}
\end{figure}

Los diferentes elementos que podemos ver en esta figura son los siguientes:

\begin{itemize}
    \item \textbf{public class ClasePrincipal}: todos los programas en Java deben incluir este elemento. Podrá llamarse ClasePrincipal, ProgramaPrincipal, ... o como queramos, pero debe tener un nombre. Se trata de una clase general donde se incluyen todos los demás elementos del programa. En unidades posteriores veremos que es una clase y cuales son sus componentes principales. Por ahora es suficiente que sepamos que nuestro programa debe comenzar con este elemento.

    \item \textbf{public static void main (String args[])}: dentro del elemento anterior podemos ver el método \textbf{main()} que contiene las líneas de código de nuestro programa. Más adelante también veremos que es un método. Basta saber por ahora que al igual que la línea anterior nuestro programa debe contener la sentencia \textbf{public static void main (String args[])}. Aquí dentro podremos incluir las instrucciones que veamos oportunas para ejecución del programa.

    \item \textbf{Comentarios}: los comentarios suelen introducirse en el programa para realizar aclaraciones, anotaciones o cualquier otra indicación que el programador estime oportuna. Estos comentarios pueden introducirse de dos formas:

    \begin{itemize}
        \item Con \textit{\textbf{//}} estaríamos estableciendo una línea de comentario, es decir, todo lo que hay detrás de este símbolo es un comentario hasta que se produzca un salto de línea.
        \item Si queremos indicar que un comentario tiene varias líneas debemos usar \textit{\textbf{/*} }para comenzar el comentario y \textit{\textbf{*/}} para cerrarlo.
    \end{itemize}

    \item \textbf{Bloques de Código} (\textbf{\{} \textbf{\}}): con conjuntos de instrucciones que se marcan mediante la apertura y cierre de llaves \textbf{\{} \textbf{\}}. En código así marcado se considera interno al bloque.

    \item \textbf{Punto y Coma} (\textbf{;}): aunque en el ejemplo de la imagen no tenemos ninguna línea de código acabada con un punto y coma, para no distraernos de momento con estos detalles, hay que hacer hincapié en que cada línea de código ha de terminar con un punto y coma. En caso de no hacerlo, tendremos errores sintácticos.
\end{itemize}

\subsection{El Entorno Básico de Desarrollo de Java}
La herramienta básica para comenzar a desarrollar aplicaciones en Java es el \textbf{JDK} (\textbf{Java Development Kit}), que incluye un compilador y un interprete para la línea de comandos. Estos dos programas son los empleados en la compilación y la interpretación del código.

Como veremos, existen diferentes entornos para el desarrollo de aplicaciones en Java que incluyen una gran variedad de herramientas, pero por ahora nos centraremos en el entorno básico, extendido y gratuito, el Java Development Kit. JDK es un entorno para construir aplicaciones, applets y componentes utilizando el lenguaje de programación Java, incluyendo todas las herramientas necesarias para su construcción y ejecución.

Junto con JDK se incluye una implementación del entorno de ejecución Java, conocido como \textbf{Java Runtime Environment} (\textbf{JRE}), para ser utilizado por JDK. El JRE incluye la \textbf{Java Virtual Machine} (\textbf{JVM}), bibliotecas de clases y otros ficheros que soportan la ejecución de programas escritos en Java.

Java fue creado por Sun Microsystems, pero posteriormente fue absorbida por Oracle, los que no han dejado de lanzar versiones de JDK. Con el lanzamiento de Java 11, Oracle hizo un cambio de licencia de modo que se convirtió en tecnología de pago en caso de usarlo en ciertas circunstancias. Podemos usar JDK u otras implementaciones abiertas. En nuestro caso, usaremos \textbf{OpenJDK}.

\textbf{OpenJDK} es la versión libre de la plataforma de desarrollo Java, en concreto de su versión \textbf{Java SE} (Standard Edition). Esta bajo la licencia \textbf{GPL 2.0} y desde la versión 7 de Java SE, OpenJDK es la versión de referencia. \cite{wiki01}

En \href{https://www.muylinux.com/2021/03/23/adoptium-working-group-adoptopenjdk-eclipse-foundation-openjdk/}{este enlace} podemos ver una guía de como instalar OpenJDK en las principales distribuciones.

\subsection{La API de Java}
Dentro del kit de desarrollo de Java que acabos de ver se incluyen gratuitamente todas las bibliotecas de Java, los que se conoce como la \textbf{API} (Advanced Programing Interface) de Java, lo que se conoce como \textbf{Biblioteca de Clases Java}. Este conjunto de bibliotecas proporcionar al programador paquetes de clases útiles para la realización de diferentes tareas dentro de un programa. Las bibliotecas están organizadas en paquetes donde cada paquete tiene un conjunto de clases relacionadas semánticamente.

En décadas pasadas una biblioteca era un conjunto de programas que contenía cientos de rutinas. Estas rutinas manejaban las tareas de todos o casi todos los programas que necesitaban. El programador podía recurrir a estar bibliotecas para para desarrollar programas con rapidez.

Una biblioteca de clases es un conjunto de clases en programación orientada a objetos. Estas clases contienen métodos que son útiles para los programadores realizando diferentes tareas. En el caso de Java, cuando descargamos el JDK obtenemos la biblioteca de clases API. Utilizar las clases y métodos de la API de Java acelera el proceso de desarrollo de los programas. También, existen diferentes bibliotecas de clases desarrolladas por terceros que contienen componentes reutilizables de software y están disponibles a través de la web.

En la \href{https://docs.oracle.com/en/java/javase/index.html}{página oficial de Oracle} podemos encontrar información más detallada sobre la API de Java.

\subsection{Afinando la Configuración}
Para que podamos compilar y ejecutar ficheros Java es necesario que realicemos unos pequeños ajustes en la configuración del sistema. Vamos a indicarle donde puede encontrar los ficheros necesarios para realizar la labores de compilación y ejecución, es esta caso los ficheros \textbf{javac.exe} y \textbf{java.exe}, así como las librerías incluidas en la API de Java y las clases de usuario. Esto lo haremos definiendo o editando las siguientes variables del sistema.

\begin{itemize}
    \item \textbf{Variable PATH}: como aún no disponemos de un IDE (Integrated Development Environment), la única forma de ejecutar programas es a través de la línea de comandos. Pero sólo podremos ejecutar programas directamente si la ruta hacia ellos esta indicada en la variable de sistema PATH. Es necesario que incluyamos la ruta hacia estos programas en nuestra variable PATH, incluyendo la ruta donde se instaló JDK hasta su directorio \textbf{bin}.

    \item \textbf{Variable CLASSPATH}: esta variable de entorno establece donde encontrar la librerías y clases de la API de Java, así como las clases creadas por el usuario. Es decir, los ficheros \textbf{.class} que se obtienen una vez compilado el código fuente de un programa escrito en Java. Es posible que en dicha ruta existan ficheros comprimidos en los formatos \textbf{zip} o \textbf{jar} que pueden ser utilizados directamente por JDK, conteniendo en su interior los archivos \textbf{class}.
\end{itemize}

\subsection{Codificación, Compilación y Ejecución de Aplicaciones}
Una vez que la configuración del entorno de Java y tenemos el código fuente de nuestro programa escrito en un archivo con extensión \textbf{.java}, la compilación de aplicaciones se realiza mediante el programa \textbf{javac} incluido en JDK.

Para llevar a cabo esta compilación deberemos usar el comando \textbf{\textit{javac archivo.java}}, desde la línea de comandos, donde archivo.java es el archivo con nuestro código fuente.

El resultado de la compilación sera un nuevo archivo con el mismo nombre que el nuestro pero con una extensión \textbf{.class}. Este es el archivo con el código a bytecode, es decir, con el código precompilado. Si en el código fuente de nuestro programa figuraran más de una clase, veremos como al realizar la compilación se generarán tantos archivos .class como clases tengamos. Además, si esta clases tenía el método \textbf{main()} podremos ejecutarlas por separado para ver el funcionamiento de dichas clases.

Para que el programa pueda ser ejecutado, siempre y cuando este incluido en el interior el método \textbf{main()}, podemos usar el interprete incluido en JDK. Para ello, usaremos el comando \textbf{\textit{java archivo}}.

Donde \textbf{java} es el interprete y \textbf{archivo} es el archivo con el código precompilado a bytecode, es decir, el archivo con extensión \textbf{.class}. Hay que destacar que no hay que incluir la extensión del archivo .class al llamar al interprete, solo debemos poner el nombre del archivo.

\subsubsection{Estandarización del Código}
Cada vez que escribamos código es importante que sigamos unas normas o estándares que nos ayuden a realizar este proceso siempre de la misma manera. De este modo todos los programas tendrán una estructura similar y nos resultará mucho más sencillo localizar los componentes en cada uno.

En caso del lenguaje Java ya hemos visto la estructura básica de un programa. A partir de aquí, vamos a desarrollar una plantilla que nos ayudará a desarrollar nuestro programas sin tener que reescribir las partes comunes una y otra vez.

Nuestra plantilla podría tener la siguiente \textbf{estructura}:

\begin{enumerate}
    \item \textbf{Declaración de la clase principal}: aquí podríamos poner el \textbf{nombre de nuestro programa}. Es decir, en lugar de llamar a la clase \textbf{ClasePrincipal}, podríamos llamar \textbf{Concurso}, \textbf{Juego}, \textbf{CalculoDeAreas}, etc. Esto es, algún nombre que nos de una pista sobre el funcionamiento de nuestro programa.

    \item \textbf{Método main}: dentro del componente anterior y encerrado entre llaves. Este nombre no se puede cambiar. En su interior estarán las líneas de código de nuestro programa:

    \begin{enumerate}
        \item \textbf{Declaración de constantes y variables}:
        \begin{enumerate}
            \item Declaración de \textbf{constantes}
            \item Declaración de \textbf{variables de entrada}
            \item Declaración de \textbf{variables de salida}
            \item Declaración de \textbf{variables auxiliares}
        \end{enumerate}
        \item \textbf{Cuerpo del Programa}
        \begin{enumerate}
            \item \textbf{Entrada de datos}
            \item \textbf{Procedimientos}
            \item \textbf{Salida de datos}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

Si seguimos esta estructura, será muy fácil analizar nuestro programas pues estarán divididos en distintos elementos con significado propio cada uno de ellos. Ahora bien, tampoco hay que ser excesivamente rígidos. Dependiendo de la naturaleza y al complejidad del	programa es posible que alguna vez estas tres partes se fundan en una, especialmente cuando el programa sea interactivo y se sigan introduciendo datos a la vez que se van procesando e incluso devolviendo resultados.

\subsubsection{Problemas con Caracteres Acentuados}
A veces cuando intentamos ejecutar un programa Java y este tiene caracteres acentuados podemos obtener símbolos extraños, en vez de dichos caracteres, especialmente si estamos trabajando con la consola de comandos.

Una solución simple que suele funcionar en la mayoría de los casos es compilar el archivo de código fuente con normalidad, indicando cuando se vaya a realizar su ejecución la opción \textit{\textbf{-Dfile.encoding}} con la codificación que queremos emplear, es decir:


\begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
    \scriptsize
    \begin{verbatim}


java -Dfile.encoding=cp850 PROG_programa1
    \end{verbatim}
\end{tcolorbox}

En este ejemplo, la página de códigos que usamos es la 850, pero se puede forzar al interprete a usar cualquier codificación que queramos, siempre y cuando este la soporte. Para saber que codificación usa nuestro sistema, podemos usar el comando \textbf{\textit{chcp}} desde la consola, que nos mostrará dicha codificación.

\subsection{Tipos de Aplicaciones en Java}
La versatilidad del lenguaje de programación Java permite al programador crear distintos tipos de aplicaciones, los cuales listamos a continuación:

\begin{itemize}
    \item \textbf{Aplicaciones de Consola}
    \begin{itemize}
        \item Son programas independientes al igual que los creados con otros lenguajes tradicionales.
        \item Se componen como mínimo de un archivo \textbf{.class} que debe contener necesariamente el método \textbf{main()}.
        \item No necesitan un navegador y se ejecutan cuando invocamos el comando \textbf{java}. Si no se encuentra el método \textbf{main()} la aplicación no podrá ejecutarse.
        \item Estas aplicaciones leen y escriben hacia y desde la entrada y salida estándar, sin ninguna interfaz de usuario.
    \end{itemize}

    \item \textbf{Aplicaciones Gráficas}
    \begin{itemize}
        \item Aquellas que utilizan clases con capacidades gráficas, como \textbf{Swing}, que es la biblioteca para la interfaz gráfica de la API de Java.
        \item Incluyen instrucciones de tipo \textbf{import}, que indican al compilador de Java que clases del paquete \textbf{javax.swing} se incluyan en la compilación.
    \end{itemize}

    \item \textbf{Applets}
    \begin{itemize}
        \item Son programas incrustados en otras aplicaciones, normalmente páginas web que se muestran en el navegador. Cuando el navegador carga una web que contienen applets, estos se descargan en el navegador y comienza su ejecución. Esto nos permite crear programas que cualquier usuario con un navegador web puede utilizar.
        \item Los applets se descargan junto con una página HTML y se ejecutan en la máquina del cliente.
        \item No tienen acceso a partes sensibles a menos que uno le de los permisos oportunos.
        \item No tienen un método principal.
        \item Son multiplataforma y pueden ejecutarse en cualquier navegador que soporte Java.
    \end{itemize}

    \textbf{Servlets}
    \begin{itemize}
        \item Son componente de la parte del servidor de Java EE, encargados de generar respuestas a las peticiones realizadas por los usuarios.
        \item Al contrario que los applets, están pensados para trabajar en el lado del servidor y procesar las peticiones de los clientes.
    \end{itemize}

    \item \textbf{Midlets}
    \begin{itemize}
        \item Son aplicaciones Java creadas para su ejecución en sistemas de propósito simple o móviles.
        \item Se usan en dispositivos embebidos, mas específicamente para la máquina virtual Java Micron Editio (Java ME).
        \item Generalmente son juegos y aplicaciones que se ejecutan en teléfonos móviles.
    \end{itemize}
\end{itemize}

Como vemos, la variedad de aplicaciones que podemos crear con Java es enorme, ya dependerá de lo que estemos interesados en crear, usaremos unas u otras opciones y librerías.

\section{Entornos Integrados de Desarrollo}
En los comienzos de Java la utilización de la línea de comandos era algo habitual. El programador escribía el código utilizando un editor de textos básico y a continuación utilizaba el compilador para obtener el código compilado. En un paso posterior necesitaba usar una herramienta para ensamblar el programa. Por último, podía probar el programa desde la línea de comandos. El problema surgía cuando ocurría algún error y había que iniciar el proceso de nuevo.

Esto hacía que el proceso de desarrollo no estuviera optimizado. Con el paso del tiempo se fueron desarrollando aplicaciones que incluían todas las herramientas necesarias para que el proceso de desarrollo fuera más rápido, sencillo y fiable. Para cada lenguaje de programación existen múltiples entornos de desarrollo, cada uno con sus ventajas e inconvenientes. Dependiendo de las necesidades y gustos del programador, se elegirá uno u otro.

Para el lenguaje de programación Java existen diferentes alternativas, siendo los principales entornos de desarrollo \textbf{Netbeans}, desarrollado por Sun y \textbf{Eclipse}. Ambos gratuitos, con soporte de idiomas y multiplataforma (Windows, Linux y MacOS).

En nuestro caso, el entorno que vamos a usar durante nuestros desarrollos va a ser \textbf{Netbeans}, ya que es de código abierto y además ha sido desarrollado por la misma compañía que desarrollo el lenguaje Java.

\subsection{¿Que es un IDE?}
Los \textbf{IDE} (Integrated Development Environment) son aplicaciones que permiten llevar todo el proceso de desarrollo de software a través de una misma aplicación. Podremos realizar labores de edición, compilación, depuración, detección de errores, corrección y ejecución de programas escritos en Java o en otros lenguajes de programación bajo un entorno gráfico. Junto a estas características, cada entorno añade otras que ayudan a realizar el proceso de programación, como por ejemplo: resaltado de sintaxis, plantillas de diferentes tipos de aplicaciones, creación de proyectos, etc...

Hay que tener en cuenta que un IDE es solo una fachada para el proceso de desarrollo, por lo que tendremos que tener instalados compiladores, interpretes y demás para su correcto funcionamiento.

\subsection{IDE Actuales}
Existen una gran variedad de IDEs en el mercado para el lenguaje de programación Java, orientados a principiantes, para profesionales, gratuitos, de pago, libres, propietarios, etc. A continuación damos una lista de los principales.

\begin{itemize}
    \item IDEs Gratuitos y de Libre Distribución:
    \begin{itemize}
        \item \textbf{Netbeans}
        \item \textbf{Eclipse}
        \item \textbf{BlueJ}
        \item \textbf{jGRASP}
        \item \textbf{JCreator LE}
    \end{itemize}

    \item IDEs Propietarios:
    \begin{itemize}
        \item \textbf{IntelliJ IDEA}
        \item \textbf{JDeveloper}
    \end{itemize}
\end{itemize}

Actualmente, los más utilizados por la comunidad son \textbf{Netbeans}, \textbf{Eclipse} y \textbf{IntelliJ IDEA}. En los siguiente epígrafes vamos a ver las características de \textbf{Netbeans}, aunque si quieres ver una comparativa más exhaustiva sobre los diferentes IDE puede consultar \href{https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Java}{esta entrada en Wikipedia}.

\subsection{El Entorno Netbeans}
Como hemos comentado anteriormente, nosotros vamos a usar \textbf{Netbeans} como entorno de desarrollo, así que lo primero que vamos a hacer es estudiar sus características y ver que puede aportar al proceso de desarrollo.

Se trata de un entorno de desarrollo \textbf{orientado} principalmente al \textbf{lenguaje de programación Java}, aunque también soporta otros lenguajes. Es un entorno libre y gratuito sin restricciones de uso, siendo un \textbf{proyecto de código abierto} con una gran comunidad de usuario en continuo crecimiento y apoyado por varias empresas.

Netbeans lleva un tiempo pugnando con Eclipse por convertirse en la plataforma mas importante de desarrollo de aplicaciones Java y hasta el nombre, Eclipse, es una declaración de intenciones por hacerle la competencia a Oracle, la empresa propietaria de Netbeans. Aunque Oracle adquirió Sun Microsistems en 2009, Netbeans sigue siendo de código abierto y ofrece las siguiente características, entre otras:

\begin{itemize}
    \item Permite escribir código en \textbf{C++}, \textbf{C}, \textbf{Ruby}, \textbf{Groovy}, \textbf{Javascript}, \textbf{CSS} y \textbf{PHP}, además de por supuesto, \textbf{Java}.
    \item Permite crear aplicaciones \textbf{J2EE} gracias a que incorpora servidores de aplicaciones Java como \textbf{Glassfish} y \textbf{Tomcat}.
    \item Permite crear aplicaciones gráficas con \textbf{Swing} de forma sencilla al estilo del Visual Studio de Microsoft.
    \item Permite crear aplicaciones \textbf{JME} para dispositivos móviles.
\end{itemize}

La plataforma Netbeans permite el desarrollo de aplicaciones a partir de un conjunto de componente de software llamados módulos. Un \textbf{módulo} no es más que un archivo Java que contiene un conjunto de clases escritas para interactuar con la API de Netbeans y un archivo especial, \textbf{manifest file}, que lo identifica como módulo.

Las aplicaciones creadas a partir de módulos pueden ser extendidas añadiendo más módulos. Debido a que los módulos pueden ser desarrollados por cualquiera, las aplicaciones basadas en esta plataforma pueden ser extendidas por cualquier desarrollador.

Cada módulo provee una función bien definida, tales como soporte para Java, edición o soporte para sistemas de control de versiones. Netbeans contiene todos los módulos necesarios para el desarrollo de aplicaciones Java en una sola descarga, permitiendo que la persona que va a trabajar con el comience a hacerlo inmediatamente.

En la \href{https://netbeans.apache.org/}{página oficial de Netbeans} puede encontrar toda la información que necesites sobre este IDE, así como aprender de forma más exhaustiva su uso diario.

\subsection{Instalación y Configuración}
En este curso, vamos utilizar la versión \textbf{Netbeans 19} del IDE, que es la última versión estable disponible. Para realizar su instalación debemos seguir los siguientes pasos:

\begin{enumerate}
    \item Descargar la versión que deseemos de su página oficial, la cual podemos encontrar en \href{https://netbeans.apache.org/download/index.html}{este enlace}. En nuestro caso, descargaremos la versión 19.
    \item Ejecutar el fichero de instalación, en caso de que sea en Windows, o utilizar el gestor de paquetes APT para realizar la instalación del paquete, en caso de que usemos Linux.
\end{enumerate}

A continuación, se proporcionan 2 enlace donde se explica la instalación y creación de un proyecto con Netbeans. Estos vídeos son sobre la versión 16 de Netbeans, pero el proceso es el mismo que la versión 19, que es la que usaremos.

\begin{itemize}
    \item \href{https://www.youtube.com/watch?v=7c-JgO7QhMY&t=1s}{Instalación de Netbeans 16 - YouTube}
    \item \href{https://www.youtube.com/watch?v=AxAJdvikdtk}{Creación del primer proyecto con Netbeans - YouTube}
\end{itemize}

\subsection{Aspecto del Entorno y Gestión de Proyectos}
La pantalla inicial de nuestro entorno ofrece accesos directos a las operaciones más usuales: aprendizaje inicial, tutoriales, ejemplos, demos, los últimos programas realizados y las novedades de la versión.

Para describir el aspecto del entorno, es necesario crear un nuevo proyecto accediendo al menú ``\textbf{\textit{File -> New Project}}'', donde indicaremos el tipo de aplicación que vamos a crear.

Una vez creado nuestro proyecto, la interfaz de Netbeans cambiará, y nos mostrará un conjunto de pestañas he información que podemos ver de forma resumida en la siguiente figura.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.40]{Tema1/netbeans-1.png}
    \caption{Ventana de proyecto de Netbeans}
\end{figure}

Cuando trabajemos con Netbeans nuestros proyectos harán usos de clases para poder desarrollar las operaciones de nuestros programas. Estas clases se agrupan en paquetes. En la siguiente figura se muestra un esquema de como se gestiona la creación de paquetes.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.40]{Tema1/netbeans-2.png}
    \caption{Creación de paquetes en Netbeans}
\end{figure}

Al igual que los paquetes, las clases se pueden crear de la misma forma, solo tenemos que seleccionar la opción ``\textbf{Java Class}'' en el menú que se muestra en al figura anterior, en vez de la opción ``\textbf{Java Package}''.

Una de las ventajas que ofrece este entorno es que podemos examinar nuestro proyectos a través de la vista \textbf{Archivos}. Esta vista nos enseña los archivos del proyecto, como la carpeta \textbf{build}, que contiene los archivos \textbf{.class}, la carpeta \textbf{src}, que es donde se encuentran los archivos de código fuente y el resto, son archivos creador por Netbeans para comprobar la configuración del proyecto o los archivos necesarios para interpretación del código en otros sistema. Para activar esta vista, seleccionar la opción ``\textbf{Window --> Files}.

\section{Variables e Identificadores}
Un programa maneja datos para hacer cálculos, presentar resultados, solicitarlos al usuario, guardarlos en disco, etc. Para poder manejar estos datos, el programa los guarda en \textbf{variables}.

Una \textbf{variable} es una zona de memoria del computador que puede almacenar un valor de un determinado tipo para ser usado más tarde en el programa. Las variables vienen determinadas por:

\begin{itemize}
    \item Un \textbf{nombre} que permite al programa acceder al valor que contiene en memoria. Debe ser un identificador válido, por ejemplo, podría llamarse \textit{precioVenta}. A este nombre, se le conoce como \textbf{identificador}.

    \item Un \textbf{tipo de datos}, que especifica la clase de información que puede ser guardada por la variable en esta zona de memoria. Por ejemplo, puede ser de tipo entero, o de tipo de cadena de caracteres, o de tipo real, etc. La variable anterior, si pretendemos que almacene precios, podría definirse como de tipo real, para que admita decimales. Cualquier lenguaje permitirá definir uno o varios tipos de reales. En Java, por ejemplo, \textbf{float} y \textbf{double} sería dos tipos de reales.

    \item Un \textbf{rango de valores} que puede admitir dicha variable. Establece el valor máximo y mínimo que se puede almacenar en la variable, así como la precisión. Normalmente va asociado al tipo de dato de la variable. Siguiendo con el ejemplo, en Java la diferencia entre definir una variable de tipo \textbf{float} o \textbf{double} supone que se podrán almacenar números reales más pequeños o más grandes y en la precisión que se puede usar. Así, para un precio, con \textbf{float} tendremos suficiente rango y precisión, ya que solo necesitamos 2 decimales y este tipo nos permite usar incluso más.
\end{itemize}

\subsection{Identificadores}
Un \textbf{identificador} en Java es una secuencia ilimitada, sin espacios, de letras y dígitos Unicode, de forma que el \textbf{primer símbolo} de la secuencia \textbf{debe ser una letra}, un \textbf{símbolo de subrayado} (\_) o el \textbf{símbolo del dolar} (\$). A continuación vemos unos ejemplos de identificadores válidos y no válidos.


\begin{itemize}
    \item Identificadores \textbf{válidos}: \textit{x5}, \textit{NUM\_MAX}, \textit{numCuenta}, \textit{\_data} o \textit{\$PI}.
    \item Identificadores \textbf{no válidos}: \textit{5p}, \textit{-precio} o \textit{\%porcentaje}
\end{itemize}

En la definición anterior decimos que un identificador puede ser una secuencia ilimitada de caracteres Unicode, pero... ¿qué es Unicode? Unicode es un código de caracteres o o sistema de codificación, un alfabeto que recoge prácticamente todos los caracteres de los idiomas más importantes del mundo. Las lineas de código en los programas se escriben usando este conjunto de caracteres.

El estándar Unicode originalmente utilizaba 16 bits, pudiéndose representar hasta 65.536 caracteres distintos. Actualmente, Unicode puede utilizar más o menos bits dependiendo del formato que se utilice, así, \textbf{UTF-8}, \textbf{UTF-16} o \textbf{UTF-32} pueden usar 8, 16 y 32 bits respectivamente.

A cada carácter le corresponde un número entero unívoco perteneciente al intervalo de 0 a 2 elevado a n, siendo n el número de bits utilizado para representar los caracteres. Por ejemplo, la letra ñ es el entero 164. Además, el código Unicode es compatible con el \textbf{código ASCII}, ya que para los caracteres del código ASCII, Unicode asigna como código los mismos 8 bits, a los que se les añade a la izquierda otros 8 bits todos a 0. Así, la conversión de un carácter ASCII a Unicode es inmediata.

\subsection{Convenios y Reglas}
A la hora de escribir el nombre de las variables existen una \textbf{reglas de estilo} que, aunque no son obligatorias, se aceptan por convenio y se usan en la mayor parte del código escrito en Java, lo que ayuda a entender más rápidamente la semántica de cada identificador. Estas reglas para la nomenclatura de variables se pueden resumir en:

\begin{itemize}
    \item Java \textbf{distingue mayúsculas de minúsculas}. Por ejemplo, \textbf{Alumno} y \textbf{alumno} son variables diferentes.

    \item \textbf{No} se suelen emplear identificadores que \textbf{comiencen por ``\textit{\$}'' o ``\textit{\_}''}. Además, el símbolo del dolar, no se suele emplear nunca para identificadores que define el usuario.

    \item \textbf{No} se puede usar como nombre los valores booleanos \textbf{true} o \textbf{false}, así como tampoco el valor nulo, \textbf{null}.

    \item Los \textbf{identificadores} deben ser lo \textbf{más descriptivos posible}. Es mejor usar palabras completas en vez de abreviaciones crípticas. En muchos casos también hará que nuestro código se \textbf{autodocumente}. Por ejemplo, si tenemos que darle nombre a una variable que almacena los datos de un cliente sería recomendable que la misma se llamara algo como \textbf{FicheroCliente} ó \textbf{ManejadorCliente}, y no algo poco descriptivo como \textbf{Cl33}, por más que Java lo considere correcto.
\end{itemize}

Además de esta restricciones, en la siguiente tabla puedes ver otras convenciones, que no siendo obligatorias, sí son recomendable a la hora de crear identificadores en Java.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/ident-java.png}
    \caption{Convenciones de identificadores en Java}
\end{figure}

\subsection{Palabras Reservadas}
Las \textbf{palabras reservadas} son secuencias de caracteres ASCII cuyo uso se reserva para el lenguaje, y por tanto, \textbf{no pueden utilizarse} para crear identificadores. En la siguiente tabla se muestran todas las palabras reservadas en Java:

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{Tema1/palabras-reservadas.png}
    \caption{Palabras reservadas en Java}
\end{figure}

Hay palabras reservadas como \textbf{const} o \textbf{goto}, que apenas se usan en la implementación actual de Java. Por otro lado, puede haber otro tipo de palabras que aunque no sean reservadas tampoco se pueden usar para la creación de identificadores. Es el caso de \textbf{true} y \textbf{false}, que son \textbf{literales booleanos}. Igualmente, \textbf{null} es considerada un literal, no una palabra reservada.

\subsection{Tipos de Variables}
Dentro de un programa podemos encontrar diferentes tipos de variables. La diferencia entre unas otras dependerá de diferentes factores como el tipo de dato que representan, si el valor puede cambiar o no, o cual es el papel que cumple en el programa.

En el \textbf{lenguaje de programación Java}, podemos distinguir los tipos de variables según los siguientes criterios:

\begin{itemize}
    \item Según el \textbf{tipo de información} que contengan, podemos hablar de \textbf{variables de tipos primitivos} o \textbf{variables referencia}. En función de al grupo que pertenezca, podrá tomar unos valores u otros, y se podrán definir sobre ella unas operaciones u otras.

    \item Dependiendo de su \textbf{mutabilidad}, podemos hablar de variables \textbf{mutables} ó \textbf{inmutables}, es decir, según su valor pueda ser modificado o no durante la ejecución del programa.
\end{itemize}

En conclusión podemos decir sobre una variable que:

\begin{enumerate}
    \item Es un \textbf{almacén temporal de información} que usan los programas para registrar datos y operar con ellos.
    \item Puede contener un valor de \textbf{tipo primitivo} (entero, real, carácter,...) o bien \textbf{una referencia} (una dirección de memoria) a una zona de memoria que contendrá información mucho más compleja que un simple valor primitivo.
    \item Se crea y se usa \textbf{dentro de un bloque de código}.
    \item Deja de existir, es decir, \textbf{se destruye}, cuando la ejecución de ese bloque de código finaliza.
\end{enumerate}

A continuación vamos a ver un ejemplo de definición de variables. Como vemos, en algunos casos se han indicado un valor inicial, mientras que en otros no.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{Tema1/ejemplo-variables.png}
\end{figure}

Como vemos, son pequeños casilleros donde se almacenan cierta información básica (tipos \textbf{primitivos})o bien una referencia (dirección de memoria) a información más compleja (tipos \textbf{referenciados}). En unos casos puede tratarse de información cambiante (\textbf{mutable}) y en otros constante (\textbf{inmutable}).

Por último, apuntar que en \textbf{Java}, para indicar que que una variables es \textbf{inmutable} o \textbf{constante}, se emplea el modificador \textbf{\textit{final}} en su declaración.

En el siguiente ejemplo, vemos la creación de dos variables:

\begin{itemize}
    \item \textbf{MAXIMO}: variable \textbf{inmutable} (\textbf{final}), con el valor \textbf{4.245}. Al haber sido declarada como constante no podrá modificarse a lo largo de la vida del programa.

    \item \textbf{y}: variable \textbf{mutable} que solo podrá ser accedida dentro del bloque de código donde se ha declarado, en este caso, el método \textbf{main()}, ya que fuera de él no existe. Podrá modificarse el valor que contiene tantas veces como se quiera a lo largo de la vida del programa.
\end{itemize}

En aparatados posteriores veremos como expandir más la funcionalidad de nuestro programas, por ahora, este ejemplo, solo muestra 3 líneas indicando que este es el primer programa y el valor de las variables.

\begin{figure}[H]
    \includegraphics[scale=0.65]{Tema1/ejemplo-variables-2.png}
\end{figure}

La salida del programa por pantalla será la siguientes:

\begin{figure}[H]
    \includegraphics[scale=0.50]{Tema1/salida-ejemplo-variables-2.png}
\end{figure}

\section{Los Tipos de Datos}
En los \textbf{lenguajes fuertemente tipados}, como es el caso de Java, a todo dato le corresponde un tipo que es conocido antes de que se ejecute el programa.

El tipo, limita el valor de la variable o expresión, las operaciones que se pueden realizar sobre esos valores y el significado de esas operaciones. Esto es así porque \textbf{un tipo}, no es más que la \textbf{especificación} de los valores que son \textbf{válidos} para esa variable y las operaciones que se pueden realizar sobre ella.

Durante el proceso de compilación, el compilador revisa todas las variables y sus tipos, sabiendo de antemano que rango de valores va a contener cada una. En el caso de que intentemos asignar a una variable un valor de otro tipo, el compilador mostrará un error. Aún así, en Java podemos realizar \textbf{conversiones entre ciertos tipos de datos}, lo que se conoce como \textbf{casting}.

Aunque ahora no vamos a entrar en detalle sobre la conversión de tipos, si es conveniente que sepas los tipos de datos que podemos encontrar en Java. Estos tipos de datos, pueden ser principalmente de dos categorías:

\begin{itemize}
    \item \textbf{Tipos de datos primitivos}: representan valores simples que vienen predefinidos en el lenguaje, como por ejemplo, un carácter o un número.

    \item \textbf{Tipos de datos referencia}: se definen como un nombre o referencia que contiene la dirección de memoria de un valor o grupo de valores. Dentro de este tipo podemos encontrar, por ejemplo, los \textbf{vectores}, más usualmente conocidos como \textbf{arrays}, que son una serie de elementos del mismo tipo, o las \textbf{clases}, que son los modelos a partir de los cuales se crean objetos.
\end{itemize}

En los siguientes apartados veremos con más detalle estos dos tipos de datos.

\subsection{Tipos de Datos Primitivos}
Los \textbf{tipos primitivos} son aquellos datos sencillos que constituyen el tipo de datos más habituales: números, caracteres y valores lógicos. Al contrario que en otros lenguajes de programación, en Java, estos valores \textbf{no son objetos}.

Una de las mayores \textbf{ventajas} de tratar con datos primitivos es que el compilador puede optimizar mejor su uso. Además, cada uno de los tipos tiene \textbf{idéntico tamaño} en las \textbf{diferentes versiones de Java} y para \textbf{cualquier tipo de ordenador}. Esto quiere decir que no debemos de preocuparnos como se representa cada tipo de datos en las diferentes plataformas, asegurando la \textbf{portabilidad} de los programas, a diferencia de lo que ocurro con otros lenguajes.

Es importante que consultes \href{https://dcodingames.com/tipos-de-datos-en-java/}{este enlace}, donde se explica con más detalle los diferentes tipos de datos primitivos que nos podemos encontrar en Java y el rango de valores que pueden tomar.

\subsubsection{Tipo Entero y Carácter}

Hay una peculiaridad con los datos primitivos en Java, y es que el tipo de dato \textbf{\textit{char}} es considerado un número por el compilador, ya que los valores que guarda son el código Unicode correspondiente al carácter que representa, no en carácter en sí, por lo que \textbf{puede operarse con caracteres} como si fueran \textbf{números}.

A la hora de elegir un tipo deberemos \textbf{tener en cuenta} como es la información que va a almacenar, si es un número, una letra, un valor booleano,.. así como el tango de valores que va a poder tomar. En este sentido, hay veces que aunque no queramos representar un número con decimales, deberemos usar un número real.

Por ejemplo, si queremos representar la población mundial del planeta, no podremos usar un dato de tipo \textbf{int}, ya que el valor máximo que puede alcanzar es 2.147.483.647, siendo este el número máximo de combinaciones posibles con 32 bits, teniendo en cuenta que en Java la representación de los números enteros se realiza en complemento a 2. Si queremos representar a la población mundial deberemos usar al menos un tipo de dato \textbf{long}, o si tenemos problemas de espacio, de tipo \textbf{\textit{float}}. Sin embargo los \textbf{tipos reales} tiene otro problema, \textbf{la precisión}.

\subsubsection{Tipo Real}
El \textbf{tipo de dato real} permite representar números con decimales. Al igual que ocurre con los enteros, la mayoría de lenguajes define diferentes tipos de datos reales, dependiendo del número de bits que utilicen para realizar la representación. Cuanto mayor bits se usen:

\begin{itemize}
    \item \textbf{Más grande} podrá ser el número real representado.
    \item \textbf{Mayor será} la \textbf{precisión} de la parte decimal.
\end{itemize}

Entre dos números reales cualesquiera, matemáticamente siempre tendremos infinitos números reales, pero un ordenador no puede representar infinitos números, porque no dispone de capacidad ilimitada, por lo que la mayoría de números reales \textbf{se representan} de \textbf{forma aproximada}.

Los números reales se representan en \textbf{coma flotante} o \textbf{notación científica}, que consiste en trasladar la coma a la primera cifra significativa del valor, con objeto de poder representar el máximo de números posibles.

Internamente, un número se representa en el interior de un computador con la siguiente formula:

\begin{equation*}\label{key}
    Valor = mantisa*2^{exponente}
\end{equation*}

Donde la \textbf{mantisa} son las cifras significativas del número. De este modo, para almacenar el número, solo se guardan la mantisa y el exponente al que va a ser elevada la base. Los bits empleados por la \textbf{mantisa} representan la \textbf{precisión} del número real, es decir, el número de cifras decimales significativas que puede tener el número, mientras que los bits del \textbf{exponente} representan la diferencia entre el mayor y menor número representable, es decir, el \textbf{intervalo de representación}.

En Java las variables de tipo \textbf{\textit{float}} se emplean para representar los números de coma flotante de simple precisión de \textbf{32 bits}, de los cuales 24 bits son para la mantisa y 8 bits para el \textbf{exponente}. Por su parte, las variables de tipo \textbf{\textit{double}} representan los números en coma flotante con doble precisión de \textbf{64 bits}, de los cuales 53 son para la mantisa y 11 para el exponente.

La mayoría de programadores usa \textbf{\textit{double}} en Java cuando están tratando con datos de tipo real. Es una forma de asegurarse que los errores cometidos en la sucesivas aproximaciones sea menor. De hecho, Java considera los datos de tipo coma flotante como \textbf{\textit{double}} por defecto. Así el literal \textbf{3.25} será considerado como tipo double. En caso de querer representarlo como float deberemos indicarlo en su definición con \textbf{3.25f} o \textbf{3.25F}.

Con objetivo de conseguir la máxima portabilidad de los programas, Java usa el estándar \href{https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/}{IEE 754} para la representación interna de los números en coma flotante, para asegurarse que el resultado de los cálculos sea el mismo en todas las plataformas.

\subsection{Tipos Referenciados}
A partir de los tipos de datos primitivos, se pueden construir otros tipos de datos. Estos tipos de datos se llaman \textbf{tipos referenciados} o \textbf{referencias}, porque se utilizan para almacenar la dirección de los datos en la memoria del ordenador.

\begin{figure}[H]
    \includegraphics[scale=1]{Tema1/ejemplo-referencia.png}
\end{figure}

En la primera línea declaramos una lista de elementos del mismo tipo, en este caso, enteros, lo que se suele conocer como un \textbf{array de enteros}. En la segunda línea declaramos un objeto, \textbf{\textit{cuentaCliente}}, como una referencia del tipo \textbf{Cuenta}.

Cualquier aplicación de hoy en día necesita tratar con un conjunto de datos. Cuando estos datos tiene características similares suelen agruparse en estructuras para facilitar el acceso a los mismos. Son los llamados \textbf{datos estructurados}. Algunos ejemplos de estos datos son los \textbf{arrays}, \textbf{listas}, \textbf{arboles}, etc. Pueden estar en la memoria del programa en ejecución,	guardados en el disco como ficheros o almacenados en una base de datos.

Además de los 8 tipos de datos primitivos visto anteriormente, Java proporciona un tratamiento especial a los textos o cadenas de caracteres mediante el tipo de dato \textbf{\textit{String}}. Java crea automáticamente este tipo de dato cuando se encuentra un cadena de caracteres encerrada entre comillas dobles. En realidad se trata de \textbf{objetos} y por tanto son \textbf{tipos referenciados}, aunque el lenguaje nos permite usarlos de forma sencilla como si fueran tipos primitivos.

En esta unidad no veremos como definir ni tratar los datos referenciados, los cuales veremos en unidades posteriores de este curso con más detalle.

\subsection{Tipos Enumerados}
Los \textbf{tipos de datos enumerados} permiten declarar una variable con un conjunto restringido de valores. Por ejemplo: los dias de las semana, los meses de un año, etc..

Para declararlos, se usa la palabra reservada \textbf{\textit{enum}}, seguida del nombre de la variable y la lista de valores que puede tomar entre llaves. Los valores que puede tomar se consideran constantes, van separados por comas y deben ser valores únicos.

Este tipo de dato es considerado por Java como un tipo de clase, por lo que no solo podemos definir los valores del tipo enumerado, sino que también podemos definir operaciones a realizar con él y otro tipo de elementos, lo que hace que este tipo de dato sea más versátil y potente que en otros lenguajes de programación. Por el momento debemos quedarnos con el \textbf{tipo enum} nos \textbf{permite definir} un nuevo \textbf{tipo de dato} donde los valores que puede tomar son los que nosotros indicamos.

A continuación tienes un ejemplo de creación y uso del tipo de dato \textbf{enum} en Java. Declaramos un \textbf{enum Dias} que contiene valores que representan todos los posibles días de la semana. Para acceder a cada valor, se utiliza el nombre del \textbf{enum}, seguido de un punto y el valor de la lista.

\begin{figure}[H]
    \includegraphics[scale=0.70]{Tema1/ejemplo-enum.png}
\end{figure}

Este ejemplo ademas de declarar \textbf{enum Dias} con su posibles valores declara dos variables de ese nuevo tipo (\textbf{diaActual y diaSiguiente}) que acabamos de definir y les asigna valores de entre el conjunto de valores posibles.

\subsection{Declaración e Inicialización}
Como podrás imaginar, debemos de crear la variables antes de utilizarlas en nuestro programas, indicando que nombre van a tener y que tipo de información van a almacenar, es decir, debemos \textbf{declarar la variable}.

Las variables se pueden declarar en cualquier bloque de código, dentro de llaves. Y lo hacemos indicando su \textbf{identificador} y el \textbf{tipo de datos}, separadas por comas si vamos a declarar varias a la vez, por ejemplo:

\begin{figure}[H]
    \includegraphics[scale=1]{Tema1/declaracion-variables-1.png}
\end{figure}

De esta forma, estamos declarando \textbf{numeroAlumnos} como una variable de tipo \textbf{int} y otras dos variables, \textbf{radio} e \textbf{importe}, de tipo \textbf{double}. En este caso se les asigna una valor en la declaración de las variables para inicializarlas, aunque esto no es obligatorio.

Si la variable va a permanecer inalterable a lo largo del programa, la declararemos \textbf{constante}, utilizando la palabra reservada \textbf{final} de la siguiente forma:

\begin{figure}[H]
    \includegraphics[scale=1]{Tema1/declaracion-variables-2.png}
\end{figure}

En algunas ocasiones declararemos variables sin asignarles un valor. Hay que tener en cuenta que las \textbf{variables} \textbf{no se inicializan de forma automática}, por lo que deberemos ser nosotros los que les asignemos un valor antes de ser usadas, ya que si el compilador detecta que intentamos usar una variable antes de que sea inicializada nos devolverá un error.

Por último, vamos a ver un ejemplo de declaración y uso de todos los tipos primitivos que hemos visto (lo referenciados se verán mas adelante), aunque también se incluye el tipo \textbf{\textit{String}}, que es de tipo referenciado pero Java permite trabajar con el como si fuera un tipo primitivo.

\begin{figure}[H]
    \includegraphics[scale=0.65]{Tema1/declaracion-variables-4.png}
\end{figure}

El resultado que se obtendrá por pantalla al ejecutar este programa tendrá el siguiente aspecto:

\begin{figure}[H]
    \includegraphics[scale=0.55]{Tema1/declaracion-variables-4-salida.png}
\end{figure}

\section{Literales de los Tipos Primitivos}
Un \textbf{literal} es un valor concreto para para los tipos de datos primitivos del lenguaje, el tipo \textbf{string} o el valor \textbf{null}.

Los \textbf{literales booleanos} son dos únicos valores, los que puede aceptar el tipo: \textbf{true} y \textbf{false}. Por ejemplo, con las instrucción \textbf{\textit{boolean encontrar = true;}} estamos declarando una variable de tipo booleana a la cual hemos asignado el valor literal \textbf{true}.

Los \textbf{literales enteros} se pueden representar con tres notaciones diferentes:

\begin{itemize}
    \item \textbf{Decimal}: es la forma más común. Por ejemplo, \textbf{20} es un literal entero decimal.
    \item \textbf{Octal}: un número representado en base octal, que siempre comenzará por cero e irá seguido de dígitos octales (0 a 7). Por ejemplo, \textbf{024}.
    \item \textbf{Hexadecimal}: un número en base hexadecimal que siempre empezará por \textbf{0x} e irá seguido de dígitos hexadecimales (de 0 a 9 y de `a' a la `f` o de `A` a la `F`). Por ejemplo: \textbf{0x14}.
\end{itemize}

A los \textbf{literales de long} se les debe añadir detrás de una ele mayúscula o minúscula (\textbf{l} ó \textbf{L}), por ejemplo, \textbf{837L}, de lo contrario, se considera por defecto un literal de tipo \textbf{int}. Se suele usar \textbf{L} para evitar la confusión entre la ele minúscula y \textbf{1}.

Los \textbf{literales reales} se expresan con como decimal o en notación científica, osea, seguidos de un exponente \textbf{e}. El valor puede finalizarse con una \textbf{f} ó \textbf{F} para indicar que se trata de un literal de tipo \textbf{float} o con una \textbf{d} ó \textbf{D} para indicar que el formato es \textbf{double}, por defecto, si no se pone nada, se entiende que es de tipo \textbf{double}. Por ejemplo, podríamos representar un mismo literal de las siguientes formas: \textbf{13.2}, \textbf{13.2D}, \textbf{1.32e1} ó \textbf{1.32E1}.

Desde Java SE 7 y posteriores, puede aparecer el carácter ``\textbf{\_}'' entre dígitos de un literal numérico. La idea subyacente es mejorar la legibilidad del código. Así, por ejemplo, sería válido escribir:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


long numeroTarjeta = 1234_5678_9021_3456L
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Un \textbf{literal carácter} puede escribir con un carácter entre comillas simples, como \textbf{`a'}, \textbf{`ñ'},\textbf{`Z'}, etc., o por su código de la tabla Unicode, anteponiendo la secuencia de escape \textbf{`\'} si el valor lo pones en octal, \textbf{`\textbackslash u'} si el valor lo ponemos en hexadecimal. Por ejemplo, si sabemos tanto que tanto en código ASCII como en Unicode, la letra A (mayúscula) es el símbolo número 65, y que 65 en octal es 101 y 41 en hexadecimal, podemos representar esta letra comom \textbf{\textbackslash 101} en octal o \textbf{\textbackslash u0041}. Existen, ademas, unos caracteres especiales que se presentan utilizando secuencias de escape.

    \begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/secuencias-escape.png}
    \caption{Secuencias de escape en Java}
\end{figure}

Normalmente lo objetos en Java deben crearse empleando el operador \textbf{\textit{new}}. Sin embargo, los literales \textbf{\textit{String}} no lo necesitan ya que son objetos que se crean implícitamente	por Java, pudiendo prescindir del uso del operador \textbf{\textit{new}}.

Los \textbf{literales de cadenas de caracteres} se indican entre comillas dobles. En el ejemplo anterior ``\textbf{El primer mensaje}'' es un literal de tipo cadena de caracteres. Al construir una cadena de caracteres se puede incluir cualquier carácter Unicode excepto un carácter de retorno de carro. Por ejemplo, en la siguiente instrucción utilizamos la secuencia de escale ``\'' para escribir dobles comillas dentro del mensaje:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


String texto = "Juan dijo: \"Hoy hace un dia fantastico\"";
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

En el ejemplo del apartado anterior ya estábamos usando secuencias de escape para introducir un salto de línea en una cadena de caracteres, utilizando el carácter especial `\textbf{\textbackslash n}'.

\section{Operadores y Expresiones}
Los \textbf{operadores} llevan a cabo operaciones sobre un conjunto de datos u operandos, representados por literales o identificadores. Los operadores pueden ser \textbf{unarios}, \textbf{binarios} o \textbf{terciarios}, según el número de operandos que utilicen sean uno, dos o tres, respectivamente. Los operadores actúan sobre los tipos de datos primitivos y también devuelven tipos de datos primitivos.

Los operandos se combinan con los literales y/o identificadores para formar \textbf{expresiones}. Una \textbf{expresión} es una combinación de operadores y operandos que se evalúa produciendo un único resultado de un tipo determinado.

El resultado de una expresión puede ser usado en otra expresión o en una sentencia. Las expresiones, combinadas con algunas palabras reservadas o por sí solas forman las \textbf{sentencias} o \textbf{instrucciones}. Por ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}i + 1\end{verbatim}
    \end{tcolorbox}
\end{figure}

Con esta expresión estamos usando operador aritmético para sumarle una cantidad a la variable \textbf{\textit{i}}, pero es necesario indicar al programa que hacer con el resultado. Así, podrías escribir:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}suma = i + 1\end{verbatim}
    \end{tcolorbox}
\end{figure}

De esta forma, le indicaríamos al programa que almacena el valor de esa expresión en la variable \textbf{\textit{suma}}, formando lo que se conoce como una \textbf{sentencia} o \textbf{instrucción}.

Más ejemplos de sentencias lo tenemos en la declaración de variables, que vimos en el apartado anterior o en las estructuras de control del lenguaje, como bucles, que veremos en puntos posteriores.

Como curiosidad comentar que las \textbf{expresiones de asignación}, al poder ser usadas como parte de otras asignaciones u operaciones, son consideradas tanto expresiones en sí mismas como sentencias.

\subsection{Operadores Aritméticos}
Los operadores aritméticos son aquellos operadores que combinados con los operandos forman expresiones matemáticas o aritméticas. En la siguiente tabla, podemos ver los operadores aritméticos básicos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/operadores-aritmeticos.png}
    \caption{Operadores aritméticos básicos}
\end{figure}

Dependiendo del tipo de operandos que se empleen en con estos operadores, el resultado de la operación tendrá un tipo u otro. Así, en la siguiente tabla podemos ver el tipo resultante dependiendo del tipo de los operandos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/operadores-resultado.png}
    \caption{Tipo del resultado según operandos}
\end{figure}

Además de estos operadores aritméticos, otro tipo de \textbf{operadores unarios} son los de \textbf{incremento y decremento}. Producen un resultado del mismo tipo que el operando y podemos usarlos con \textbf{notación prefija}, si el operador aparece antes que el operando, o \textbf{notación sufija} si el operador aparece después que el operando. En la siguiente tabla se ve un ejemplo del uso de estos operadores.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/operadores-unarios.png}
    \caption{Operadores de incremento y decremento}
\end{figure}

En la siguiente tabla, podemos ver un ejemplo de uso de los \textbf{operadores aritméticos} en un programa básico donde se muestra además por pantalla el resultado de cada operación.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.62]{Tema1/operadores-ejemplo.png}
    \caption{Ejemplo de uso de operadores aritméticos}
\end{figure}

\subsection{Operadores de Asignación}
El principal operador de esta categoría es el \textbf{operador de asignación} ``\textbf{\textit{=}}'', que permite al programa asignar un valor a una variable y que ya hemos usado varias veces en esta unidad. Además de este operador, Java proporcionar otros operadores de asignación combinados con operadores aritméticos que permiten abreviar operaciones.

Por ejemplo, el operador ``\textbf{+=}'', suma el valor de la expresión a la derecha del operando con el valor de la variable que hay a la izquierda del operador y almacena el resultado en dicha variable. En la siguiente tabla, se muestran todos los operadores de asignación que podemos encontrarnos en Java.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{Tema1/operadores-asignacion.png}
    \caption{Operadores de asignación}
\end{figure}

\subsection{Operadores de Relación}
Los \textbf{operadores relacionales} se utilizan para \textbf{comparar datos primitivos} (número, carácter y booleano). El resultado de la comparación se usará en otras expresiones o sentencias, que permitan comprobar en una condición dicho resultado, y ejecutar una acción u otra en función de si se cumple ésta o no.

Estas expresiones en Java dan como resultado un valor booleano, \textbf{true} o \textbf{false}. En la siguiente tabla vemos todos los operadores relacionales que podemos encontrarnos en Java.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{Tema1/operadores-relacionales.png}
    \caption{Operadores relacionales}
\end{figure}

Hasta ahora hemos visto ejemplos que creaban variables y se inicializaban a alguna valor. Pero si queremos que el usuario introduzca un valor, en vez de asignarlo, deberemos añadirle interactividad, añadiendo por ejemplo la función
\textbf{Scanner}. Aunque no hemos visto aún que son las clases y los objetos, de momento vamos a pensar que la clase \textbf{Scanner} nos va a permitir leer datos que se escriben por el teclado y que para usarla es necesario importar el paquete que la contiene.

\begin{figure}[H]
    \includegraphics[scale=0.48]{Tema1/uso-scanner.png}
\end{figure}

En este código de ejemplo, el programa se quedará esperando a que el usuario escriba algo por teclado y pulse la tecla intro. En ese momento se convierte el valor leído aun valor de tipo \textbf{int} y lo guarda en la variable indicada. Además de los operadores relacionales, en este ejemplo ejemplo usamos también el operador condiciona, que compara si los números son iguales o no. si lo son, devuelve la cadena iguales, y si no, la cadena distintos.

\subsection{Operadores Lógicos}
Los \textbf{operadores lógicos} realizan operaciones sobre valores booleanos o resultados de expresiones relacionales, dando como resultado un valor booleano.

Existen ciertos casos en los que el \textbf{segundo operando} de una expresión \textbf{no se evalúa}, para ahorrar tiempo de ejecución, porque con la evaluación del primero ya es suficiente para saber cual será el resultado de la expresión.

Por ejemplo, en la expresión \textbf{\textit{a \&\& b}}, sí \textbf{\textit{a}} es falso, no se sigue comprobando, ya que se sabe que la condición de que ambos sean verdaderos no se va a cumplir. En estos casos, es recomendable colocar el operando más propenso a ser falso en en lado de la izquierda. Igualmente ocurre con el operador \textbf{\textit{||}}, donde se deberá colocar a la izquierda el operando con más posibilidades de ser verdadero.

A continuación se muestra una tabla con los principales operadores booleanos que podemos encontrarnos en Java.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{Tema1/operadores-booleanos.png}
    \caption{Operadores lógicos}
\end{figure}

En el siguiente código podemos ver algunos ejemplos del uso de los operadores lógicos que hemos visto en este apartado.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
    System.out.println(" false & false es : " + (false & false));
    System.out.println(" true  & false es : " + (true & false));
    System.out.println(" true  | false es : " + (true | false));
    System.out.println(" false ^ true  es : " + (false ^ true));
    System.out.println(" false && true  es : " + (false && true));
    System.out.println(" true  && true  es : " + (true && true));
    System.out.println(" true  || false es : " + (true || false));
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsection{Operador Condicional}
El \textbf{operador condicional} ``\textbf{\textit{? :}}'', sirve para \textbf{evaluar una condición} y \textbf{devolver un resultado} u \textbf{otro} en función de si esta es verdadera o falsa. Es el único \textbf{operador ternario} de Java, y como tal, necesita tres operandos.

\begin{itemize}
    \item El \textbf{primer operando} se sitúa a la \textbf{izquierda del símbolo de interrogación} (\textbf{\textit{?}})y siempre será una expresión booleana, también llamada condición.
    \item El \textbf{segundo operador} se sitúa a la \textbf{derecha del signo de interrogación} (\textbf{\textit{?}}) y \textbf{antes de los dos puntos} (\textbf{\textit{:}}), y es el \textbf{valor que se devolverá} si la expresión del primer operando \textbf{es verdadera}.
    \item El \textbf{tercer y último operando}, que se sitúa \textbf{después de los dos puntos} (\textbf{\textit{:}}), es la expresión cuyo \textbf{valor de devolverá} si la condición evaluada en el operando primero \textbf{es falsa}.
\end{itemize}

En la siguiente tabla, se muestra con más detalle la sintaxis de este operador para que quede más clara la idea.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{Tema1/operadores-condicionales.png}
    \caption{Operador condicional}
\end{figure}

Por ejemplo, en la siguiente expresión:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
(x>y) ? x : y ;
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Se evalúa la condición de si \textbf{x es mayor que y}, en caso de que ésta \textbf{sea verdadera}, se \textbf{devolverá el valor de x}, en caso contrario, se \textbf{devolverá el valor de y}.

\subsection{Operadores de Bits}
Los \textbf{operadores a nivel de bits} se caracterizan porque realizan operaciones sobre los números enteros (o char) en su representación binaria, es decir, sobre cada dígito binario.

Aunque estos operadores no son de uso frecuente, sino más bien para aplicaciones especificas, no esta de más que al menos sepas cuales son. En la siguiente tabla, tienes todos los operadores binarios que podemos encontrar en Java.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.52]{Tema1/operadores-binarios.png}
    \caption{Operadores binarios}
\end{figure}

\subsection{Trabajo con Cadenas}
Ya hemos visto en la sección sobre literales que el objeto \textbf{\textit{String}} se corresponde con una secuencia de caracteres entrecomillados, por ejemplo, \textbf{\textit{``Hola''}}. Este tipo de literal se puede emplear en Java como si de un tipo primitivo se tratase, y como caso especial que es, no es necesario el uso del operador \textbf{\textit{new}}.

En ese punto vamos a utilizar determinadas operaciones sobre el objeto \textbf{\textit{String}}, y lo verás más claro con ejemplos descriptivos.

Para aplicar una operación a una variable de tipo de \textbf{\textit{String}}, escribiremos su nombre seguido de la operación, separados por un punto. En el siguiente ejemplo, vemos todas las operaciones que se pueden realizar sobre cadenas, las cuales pasaremos a explicar a continuación:

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{Tema1/operaciones-cadenas.png}
\end{figure}


Entre las principales operaciones que podemos ver en el código anterior tenemos las siguientes:

\begin{itemize}
    \item \textbf{Creación}: como hemos visto en la sección de literales, podemos crear una variable de tipo \textbf{\textit{String}} simplemente asignándole una cadena de caracteres entre comillas dobles.
    \item \textbf{Obtención del carácter}: podemos obtener el carácter que se encuentra en una posición determinada. Para ello se utiliza el método \textbf{charAt}.
    \item \textbf{Obtención de longitud}: si necesitamos obtener la longitud de un \textbf{\textit{String}}, podemos usar el método \textbf{\textit{length}}
    \item \textbf{Concatenación}: se utiliza el operador \textbf{\textit{+}} entre dos cadenas de caracteres o el método \textbf{\textit{concat()}} para concatenar cadenas de caracteres.
    \item \textbf{Comparación}: el método \textbf{\textit{equals}} nos devuelve un valor booleano que nos indica si las dos cadenas son iguales o no. El método \textbf{\textit{equalsIgnoreCase}} hace lo mismo, pero ignorando las mayúsculas de las cadenas que se comparan. La comparación entre objetos \textbf{\textit{String}}, \textbf{nunca} debe realizarse utilizando el operador \textbf{\textit{==}}.
    \item \textbf{Obtención de subcadenas}: podemos obtener cadenas derivadas de una cadena original mediante el método \textbf{\textit{substring()}}, en el cual debemos indicar la posición de inicio y de fin de la subcadena a obtener.
    \item \textbf{Cambio de mayúsculas/minúsculas}: los métodos \textbf{\textit{toUpperCase}} y \textbf{\textit{toLowerCase}} devuelven una nueva cadena con todos los caracteres en mayúsculas o minúsculas respectivamente.
    \item \textbf{Conversiones}: utilizaremos el método \textbf{\textit{valueOf}} para convertir un tipo de dato primitivo a una variable de tipo \textbf{\textit{String}}.
\end{itemize}

Sabiendo ya para que se usa cada operación, el resultado del ejemplo anterior que obtendríamos en la consola sería el siguiente:

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/operaciones-cadenas-salida.png}
\end{figure}

\subsection{Precedencia de Operadores}
El \textbf{orden de precedencia de los operadores} determina la secuencia en la que deben realizarse las operaciones cuando en una expresión intervienen diferentes operadores. Las reglas de operadores que utiliza Java \textbf{coinciden} con las \textbf{reglas de álgebra convencional}. Por ejemplo:

\begin{itemize}
    \item La \textbf{multiplicación}, \textbf{división} y \textbf{resto} de una expresión se \textbf{evalúan en primer lugar}. Si dentro de la expresión hay varias operaciones de este tipo, se evaluarán de izquierda a derecha.
    \item La \textbf{suma} y la \textbf{resta} se evalúan después de los operadores anteriores. De igual manera, si se tiene varias operaciones de suma o resta se evaluarán de izquierda a derecha.
\end{itemize}

A la hora de evaluar una expresión, hay que tener también en cuenta las \textbf{asociatividad} de los operadores. La asociatividad nos indica que operador se evalúa antes, en condiciones de igualdad de precedencia.

Los \textbf{operadores de asignación}, el \textbf{operador condicional}, los \textbf{operadores incrementales} y el \textbf{casting}, son asociativos por la derecha. En cambio, el \textbf{resto de operadores} son asociativos por la izquierda, es decir, se evalúan en el orden en el que están escritos. Por ejemplo, en la siguiente expresión:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
 10 / 2 * 5
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Realmente la operación que se realiza es \textbf{(10/2) * 5}, porque ambos operadores, división y multiplicación, tiene igual precedencia y por tanto se evalúa primero el que antes nos encontramos por la izquierda, que es la división. El resultado de la operación es \textbf{25}. Si fueran asociados por la derecha el resultado sería \textbf{1}, ya que primero se multiplicaría \textbf{2 * 5} y después se realizaría la división entre \textbf{10}. En cambio, en la siguiente sentencia:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
 x = y = z = 1
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Realmente la operación que se realiza es \textbf{x = (y = (z = 1))}. Primero se le asigna el valor a la variable\textbf{z}, luego a la variable \textbf{y}, para terminar asignando el resultado a la variable \textbf{x}.

En la siguiente tabla se detalla el orden de preferencia y la asociatividad de todos los operadores que hemos visto en este apartado. Los operadores se muestran de mayor a menor preferencia.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{Tema1/preferencia-operadores.png}
    \caption{Preferencia de operadores}
\end{figure}

\section{Conversión de Tipos}
Las \textbf{conversiones de tipo} se realizan para hacer que el resultado de una expresión sea del tipo que nosotros queremos. Por ejemplo, para hacer el resultado de una operación de división entre enteros sea de tipo real, con decimales, deberemos hacer una conversión de tipos. Existen dos tipos de conversiones:

\begin{itemize}
    \item \textbf{Conversiones implícitas}: cuando a una variable de un tipo se le asigna un valor de otro tipo que requiere menos bits para su representación se realiza una conversión de forma automática del tipo con menos bits al tipo que necesita más. En este caso se dice que el valor se ha \textbf{promocionado} al tipo más grande, el de la variable, para poder hacer la asignación. También se realizan conversiones automáticas en las operaciones aritméticas, cuando estamos usando valores de distinto tipo. En este caso, el valor más pequeño se promociona al valor más grande, ya que el tipo más grande siempre podrá representar un valor del tipo menor, por ejemplo, de \textbf{\textit{int}} a \textbf{\textit{long}} o de \textbf{\textit{float}} a \textbf{double}.

    \item \textbf{Conversiones explícitas}: cuando hacemos una conversión de un tipo con más bits a un tipo con menos bits, debemos indicar que queremos hacer la conversión de manera expresa, ya que se puede producir una perdida de datos y hemos de ser conscientes de ello. Este tipo de operaciones se realiza con el \textbf{operador \textit{cast}}. El operador \textbf{\textit{cast}} es un operador unario que se forma colocando delante del valor a convertir el tipo de dato entre paréntesis. Tiene la misma precedencia que el resto de operadores unarios y se asocia de derecha a izquierda. Las conversiones explícitas suelen ser conocidas como \textbf{casting}.
\end{itemize}

Debemos tener en cuenta que \textbf{un valor numérico} nunca puede ser asignado de una variable de \textbf{menos rango} si no es con una conversión explícita. Por ejemplo:

\begin{figure}[H]
    \includegraphics[scale=0.80]{Tema1/casting.png}
\end{figure}

En este ejemplo vemos un caso típico de error de tipos, ya que estamos intentado asignar a la variable \textbf{\textit{b}} el valor de \textbf{\textit{a}}, siendo \textbf{\textit{b}} de un tipo más pequeño. El compilador detecta que \textbf{\textit{a}} es un ``recipiente más grande'', y que por tanto puede no caber en \textbf{\textit{b}}, que es un ``recipiente más pequeño'', y podría perderse información por un desbordamiento.

Lo correcto es forzar la conversión realizando una conversión explícita del tipo \textbf{\textit{a}}, al tipo de dato \textbf{byte} y entonces asignarle su valor a la variable \textbf{\textit{b}}.

Por último, consulta el \textbf{Anexo A.1} donde podrás ver información importante sobre la conversión de tipos en Java, tanto de la implícita como la explícita.

\section{Comentarios}
Los \textbf{comentarios} son muy importantes a la hora de describir que hace un determinado programa. A lo largo de la unidad los hemos utilizado para documentar ejemplos y mejorar la compresión del código. Para lograr este objetivo, es normal que cada programa comience con unas líneas de comentario que indiquen, al menos, una breve descripción del programa, el autor/a del mismo y la última fecha en la que se ha modificado.

Todos los lenguajes de programación disponen de alguna forma de introducir comentarios en el código. En el caso de Java, no podemos encontrar con los siguientes tipos de comentarios:

\begin{itemize}
    \item \textbf{Comentarios de una sola línea}: utilizaremos el delimitador \textbf{\textit{//}} para introducir comentarios de una sola línea, como podemos ver a continuación.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
\begin{verbatim}
// comentario de una sola línea
\end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Comentarios de múltiples líneas}: para introducir este tipo de comentarios, utilizaremos una barra inclinada y un asterisco (\textbf{\textit{/*}}), al principio del párrafo, y un asterisco con una barra inclinada (\textbf{\textit{*/}}) al final del mismo. Aunque no es obligatorio poner asteriscos al comienzo de cada nueva línea, suele hacerse para que quede más claro de forma visual que líneas forman parte del comentario. A continuación, vemos un ejemplo.

    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
    /* Esto es un comentario de
     * varias lineas */

     /* Esto es otro comentario de
      de varias lineas */
\end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item \textbf{Comentarios Javadoc}: para este tipo de comentarios usaremos los delimitadores \textbf{\textit{/**}} y \textbf{\textit{*/}}. Al igual que los comentarios tradicionales, el texto incluido entre estos delimitadores será ignorado por el compilador. Este tipo de comentarios se emplea para generar documentación del programa de forma automática. A través de \textbf{javadoc}, incluido en Java SE, se recogen todos estos comentarios y se llevan a un documento \textbf{HTML}.

    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
    /** Comentario de documentacion
     * Javadoc recopila los comentarios del código y
     * genera un documento HTML a partir de ellos.
     */
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\end{itemize}

\chapter{Uso de Estructuras de Control}
En esta unidad vamos a estudiar las estructuras de control, que nos permitirán controlar el flujo de ejecución del código según ciertas condiciones. Así, veremos las estructuras condicionales, iterativas y de salto condicional. También veremos por encima la gestión de errores, pruebas y depuración del código Java con Netbeans.

\section{Introducción}
Si has programado alguna vez o tienes ciertos conocimientos básicos sobre lenguajes de programación, sabes que la gran mayoría de lenguajes poseen estructuras que permiten a los programadores controlas el flujo de información de sus programas. Esto tiene una ventaja para una persona que esta aprendiendo un lenguaje y tiene pensado aprender otros, ya que estás estructuras suelen ser comunes a todos los lenguajes de programación, con algunos cambios léxicos. Es decir, si conocías \textbf{sentencias de control de flujo} de otro lenguajes lo que vamos a ver a lo largo de esta unidad te sonará bastante.

Para alguien que no ha programado nunca, un ejemplo sencillo le hará entender que son las sentencias de control de flujo.

Piensa en un fontanero (programador), principalmente trabaja con agua (datos) y se encarga de hacer que fluya por donde el quiere (programa), a través de un conjunto de tuberías, codos, latiguillos, llaves de paso, etc.., (sentencias de control de flujo). Pues esas \textbf{estructuras de control de flujo} son las que estudiaremos, conoceremos su estructura, funcionamiento, como utilizarlas y dónde. Al utilizarla en nuestros programas, podremos hacer que nuestros datos fluyan por los caminos adecuados para representar la realidad del problema y obtener los resultados que queremos.

Los \textbf{tipos} de estructuras de programación que se usan \textbf{para el control de flujo} de los datos, en cualquier lenguaje, son las siguientes:

\begin{itemize}
    \item \textbf{Secuenciales}: compuestas por 0, 1 o más sentencias que se ejecutan en el orden que han sido escritas. Es la estructura más sencilla y sobre la que se construirán el resto de estructuras. Es, de hecho, la que hemos usado en en los ejemplos y ejercicios del tema anterior.

    \item \textbf{Condicional o Selectiva}: es un tipo especial de sentencia que permite \textbf{tomar decisiones}, dependiendo del \textbf{valor de una condición} (expresión lógica). Según la evaluación de la condición se ejecutarán unas sentencias u otras. Estás pueden ser:

    \begin{itemize}
        \item \textbf{Selectiva Simple}
        \item \textbf{Selectiva Compuesta}
        \item \textbf{Selectiva Múltiple}
    \end{itemize}

    \item \textbf{Iterativa, Repetitiva o Cíclica}: es un tipo especial de sentencia que permite \textbf{repetir la ejecución de una secuencia o bloque de instrucciones} según el resultado evaluado de una condición. Es decir, la secuencia de instrucciones se ejecutara repetidamente si la condición arroja un valor correcto, en otro caso, la secuencia dejará de ejecutarse y se pasará a ejecutar la siguiente secuencia después del ciclo.
\end{itemize}

Además de las sentencias típicas de control de flujo, en esta unidad haremos una revisión de las \textbf{sentencias de salto incondicional}, que aunque son \textbf{altamente desaconsejables en la mayoría de los casos}, y generalmente resultar innecesario recurrir a ellas, no está de más conocerlas por si te la encuentras por ahí en programas que no hayas escrito tú.

Por último, veremos la manera de llevar a cabo la \textbf{depuración} del programa para localizar errores en nuestro código, empleando para ello Netbens.

\section{Estructura Secuencia: Sentencias y Bloques}

% Apéndice
\appendix

% Change appendix display options
\titleformat{\chapter}{\bfseries\Huge}{\thechapter.}{1ex}{}

\chapter{Anexos Tema 1}

\section{Conversión de Tipos de Datos en Java}
Es este anexo se va a profundizar un poco en la conversión de tipos de Java, para complementar lo visto en la unidad 1 sobre este tema. En primer lugar, vamos a mostrar una tabla con todos los tipos de conversión que se pueden realizar en Java, especificando cuales se permiten, cuales se realizan de forma automática y cuales de forma explícita.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{Tema1/anexo-conversiones-1.png}
    \caption{Conversión de Tipos en Java}
\end{figure}

Explicación de los símbolos utilizados:

\begin{itemize}
    \item \textbf{N}: conversión no permitida. Un booleano no se puede convertir a otro tipo de dato y viceversa.
    \item \textbf{CI}: conversión implícita. Un asterisco indica que puede haber posible perdida de datos.
    \item \textbf{C}: casting de tipos o conversión explícita.
    \item \textbf{-}: mismo tipo, no hay que realizar conversión.
\end{itemize}

El asterisco indica que puede haber \textbf{perdida de datos}, por ejemplo, al convertir un \textbf{int} que usa 32 bits para la representación, a un tipo \textbf{float}, que también usa 32 bits para la representación pero 8 bits se usan para el exponente.

En cualquier caso, la conversión de \textbf{números de coma flotante} a \textbf{números enteros} siempre necesitarán un casting, y debemos de tener mucho cuidado con la perdida de precisión que supone esta conversión.

\subsection*{Reglas de Promoción de Tipo de Datos}
Cuando en una expresión hay datos o variables de distinto tipo el compilador hace una conversión de unos tipos a otros, para obtener como resultado el tipo final de la expresión. Esta promoción de tipos se realiza siguiendo unas reglas básicas, que son las siguientes:

\begin{itemize}
    \item Si uno de los operandos es de tipo \textbf{double}, el otro es convertido a \textbf{double}.
    \item En cualquier otro caso:
    \begin{itemize}
        \item Si uno de los operandos es \textbf{float}, el otro se convierte a \textbf{float}.
        \item Si uno de los operandos es \textbf{long}, el otro se convierte a \textbf{long}.
        \item Si no se cumple ninguna de estás reglas, entonces ambos operandos son convertidos a \textbf{int}.
    \end{itemize}
\end{itemize}

Por último, en la siguiente tabla, se exponen algunas últimas consideraciones a tener en cuenta sobre la conversión de tipos de diferentes datos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{Tema1/conversion-consideraciones.png}
    \caption{Consideraciones para la conversión de tipos}
\end{figure}



% Bibliography

\addcontentsline{toc}{chapter}{Bibliografía}
\bibliography{citas}
\bibliographystyle{unsrt}

\end{document}