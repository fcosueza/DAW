\input{preambulo.tex}

%----------------------------------------------------------------------------------------
%	TÍTULO Y DATOS DEL ALUMNO
%----------------------------------------------------------------------------------------

\title{
\normalfont \normalsize
\textsc{{\bfseries Curso 2022-2023} \\ Ciclo Superior de Desarrollo de Aplicaciones Web \\ IES Aguadulce} \\ [25pt]
\horrule{0.5pt} \\[0.4cm]
\huge Lenguajes de Marcas y Sistemas de Gestión de la Información\\
\horrule{0.5pt} \\[0.4cm]
}

\author{Francisco Javier Sueza Rodríguez}
\date{\normalsize\today}

%----------------------------------------------------------------------------------------
%                                     DOCUMENTO
%----------------------------------------------------------------------------------------

\makeglossaries
\loadglsentries{glossary.tex}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\listoffigures

%\listoftables

\newpage
\chapter{Lenguajes de Marcas y Sistemas de Gestión de la Información}
En esta unidad vamos a estudiar los aspectos básicos de los lenguajes de marcas y los sistemas de gestión de la información. Por un lado, veremos la evolución de los \textbf{lenguajes de marcas}, desde GML hasta HTML, así como sus elementos y atributos, haciendo especial énfasis en XML. A continuación, veremos en que consisten los \textbf{sistemas de gestión de la información}, en concreto los \textbf{ERP}, sus características, configuración básica, personalización,..etc.

\section{Definición y Clasificación de los Lenguajes de Marcas}
Los <<lenguajes de marcas>> sirven para \textbf{codificar un documentos}. Estos incorporan \textbf{etiquetas} o marcas con \textbf{información adicional} sobre como se estructura el texto o como se presenta. El lenguaje de marcas será el que defina que etiquetas se permiten, donde deben colocarse y que significado tienen.

Todo lenguaje de marcas esta definido en un documento denominado \textbf{\gls{DTD}}, donde se establecen las marcas, los elementos utilizados por dicho lenguaje y sus correspondientes etiquetas y atributos, así como su sintaxis.

Los lenguajes de marcas se pueden clasificar, principalmente, en tres grupos:

\begin{itemize}
    \item \textbf{Orientados a la presentación}: son los utilizados generalmente por los procesadores de texto y definen como debe presentarse el documento, es decir, el formato que tiene.
    \item \textbf{De procedimientos}: orientados también a la presentación, pero en este caso, dentro de un \textbf{marco procedural} que permite la definición de macros, es decir, el programa que representa el documento debe interpretar el código en el mismo orden que aparece. Algunos ejemplos son \textbf{TeX}, \textbf{LaTeX} y \textbf{Postscript}
    \item \textbf{Descriptivos o semánticos}: estos lenguajes no describen la presentación del documento, sino que \textbf{describen la información}, que es lo que se esta representando sin especificar como debe presentarse.
\end{itemize}

Algunos ejemplos de lenguajes de marcado agrupados por su ámbito de uso son los siguientes:

\begin{itemize}
    \item \textbf{Documentación Electrónica}:
    \begin{itemize}
        \item \textbf{RTF} (Rich Text Format): fue desarrollado por Microsoft en 1987 y permite el intercambio de documentos entre los diferentes procesador de texto.
        \item \textbf{TeX}: creado por \href{https://es.wikipedia.org/wiki/Donald_Knuth}{Donald Knuth}, este lenguaje esta especialmente enfocado en la creación de textos científicos. Es considerado la mejor forma de componer formulas matemáticas complejas. \cite{tex}
        \item \textbf{Wikitexto}: permite la creación de páginas wiki en servidores preparados para soportar este lenguaje.
        \item \textbf{DocBook}: permite generar documentos separando la estructura lógica del documento de su formato, permitiendo que estos documentos puedan publicarse en diferentes formatos sin tener que modificar el documento original.
    \end{itemize}
    \item \textbf{Tecnologías de Internet}:
    \begin{itemize}
        \item \textbf{HTML},\textbf{XHTML} (Hypertext Markup Language, eXtensible Hypertext Markup Language): estos lenguajes están orientados a la creación de páginas web.
        \item \textbf{RSS} (Really Simple Sindication): permite la difusión de contenido web mediante la sindicación de contenidos.
    \end{itemize}
    \item Otros lenguajes especializados:
    \begin{itemize}
        \item \textbf{MathML} (Mathematica Markup Language): especializado en expresar los formalismos matemáticos de forma que puedan ser entendidos por diferentes aplicaciones.
        \item \textbf{VoiceXML} (Voice eXtended Markup Language): permite el intercambio de información entre usuarios y una aplicación con capacidad de reconocer el habla.
        \item \textbf{MusicXML}: permite el intercambio de partituras entre diferentes editores de partituras.
    \end{itemize}
\end{itemize}

\section{Evolución de los Lenguajes de Marcas}
A finales de los \textbf{años 60} surgen unos lenguajes informáticos, diferentes de los lenguajes de programación, orientados a la gestión de la información. Con el desarrollo de los editores y procesadores de texto surgen los primeros lenguajes informáticos orientados a la descripción y estructuración de la información: \textbf{los lenguajes de marcas}. Paralelamente también surgen otros lenguajes orientados a la representación, almacenamiento y consultar de grandes cantidades de datos: lenguajes y sistemas de bases de datos.

Los lenguajes de marcas surgieron inicialmente como lenguajes formados por un conjunto de códigos que los procesadores de textos insertaban en los documentos para dirigir el proceso de presentación (impresión) mediante una impresora. Al igual que los lenguajes de programación, estos estaban \textbf{ligados} a las características de los \textbf{procesadores de texto}y las \textbf{impresoras} en los que se usaban y no permitían a los programadores abstraerse de dichas características.

Posteriormente se añadió como medio de presentación a la pantalla y se automatizó el proceso, teniendo ya solo que pulsar una combinación teclas para lograr los resultados deseados en vez de hacerlo a mano. Este marcado estaba orientado exclusivamente a la presentación de la información, aunque posteriormente se le dieron nuevos uso surgiendo con ello el \textbf{formato generalizado}.

\subsection{El origen: GML y SGML}
Uno de los problemas que ha tenido la informática ha sido la \textbf{falta de estandarización} en los formatos de información usados por los diferentes programas.

En los años 60, \textbf{IBM} encargo a \textbf{Charles F. Goldfarb} la construcción de un sistema de edición, almacenamiento y búsqueda de documentos legales. Después de analizar el funcionamiento de la empresa se llego a la conclusión de que necesitaban un formato estándar a todos los departamentos para gestionar la documentación.

Así fue como se creó \textbf{\gls{GML}}, un formato que permitía describir los documentos de tal forma que el resultado fuese independiente de la plataforma o la aplicación utilizada. Este formato evolucionó hasta que en 1986 se creó el estándar \textbf{ISO 8879} donde se especificaba el formato \textbf{\gls{SGML}}, un lenguaje muy complejo y que requería de unas herramientas de software caras, por lo que su uso quedó relegado a grandes aplicaciones industriales.


\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
      \scriptsize
      \begin{verbatim}
<email>
    <remitente>
        <nombre>Peter</nombre>
        <apellido>Pan</apellido>
    </remitente>
    <destinatario>
        <direccion>campanilla@paisdenuncajamas.com</direccion>
    </destinatario>
    <asunto>Paseo</asunto>
    <mensaje>¿Te apetece dar una vuelta?</mensaje>
</email>
      \end{verbatim}
    \end{tcolorbox}
\caption{Documento SGML simple}
\end{figure}

\subsection{La Popularización: HTML}

En 1990, \href{https://es.wikipedia.org/wiki/Tim_Berners-Lee}{\textbf{Tim Berners-Lee}} creó el World Wide Web y conociendo SGML, se encontró con la necesidad de compatibilizar, enlazar y organizar gran cantidad de documentos procedentes de diversos sistemas. Como solución, a partir de la sintaxis de SGML, creó un lenguaje de descripción de documentos llamado \textbf{\gls{HTML}}, combinando dos estándares ya existentes:

\begin{itemize}
    \item \textbf{\gls{ASCII}}: código basado en el alfabeto latino, tal como se usa en inglés moderno \cite{ascii}. Cualquier procesador de textos simple puede reconocer y almacenar este formato, permitiendo la transferencia de datos entre dos ordenadores.
    \item \textbf{SGML}: lenguaje que permite dar estructura al texto aplicando diferentes formatos.
\end{itemize}

\textbf{HTML} es una \textbf{versión simplificada de SGML}, ya que solo utiliza las instrucciones absolutamente necesarias. Gracias a su simplicidad, tuvo un éxito rotundo en la World Wide Web, convirtiéndose rápidamente en el \textbf{estándar general} para la \textbf{creación de páginas web}. Actualmente, HTML es el tipo de documento más utilizado en el mundo.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Ejemplo1</title>
    </head>
    <body>
        <p>Párrafo de ejemplo</p>
    </body>
</html>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento HTML simple}
\end{figure}

\subsection{La Madurez: XML}
Uno de los problemas que surgió con HTML es que la cantidad de documentos escritos en este lenguaje creció exponencialmente, muchos de los cuales no se ceñían a ningún estándar generando bastante caos. Como respuesta es ese problema, el \textbf{\gls{W3C}} estableció en 1998 el estándar internacional \textbf{\gls{XML}}, un lenguaje de marcas puramente estructural, que \textbf{no incluye información sobre el diseño}, y permite la creación de etiquetas adaptadas a las necesidades, convirtiéndose con rapidez en el estándar para intercambio de datos en la web.

\textbf{XML} es un \textbf{\gls{metalenguaje}} con las siguientes características:

\begin{itemize}
    \item Permitir definir etiquetas propias.
    \item Permitir asignar atributos a las etiquetas.
    \item Utilizar un esquema para definir de forma exacta las etiquetas y sus atributos.
    \item La estructura y el diseño son independientes.
\end{itemize}

En realizad XML es un \textbf{conjunto de estándares} relacionados entre sí y que comprende los siguientes:

\begin{itemize}
    \item \textbf{XLS} (eXtensible Style Language): permite definir hojas de estilo para XML e incluye capacidad de transformación de documentos.
    \item \textbf{XML Linking Language}: determina aspectos sobre los enlaces entre documentos XML e incluye \textbf{Xpath}, \textbf{Xlink} y \textbf{Xpointer}.
    \item \textbf{XML Namespaces}: proveen de un contexto donde se aplican las marcas del documento XML y que se diferencian de otras con el mismo nombre válidas en otros contextos.
    \item \textbf{XML Schemas}: permiten definir restricciones que se aplicarán a un documento XML. Actualmente las mas utilizadas son \textbf{DTD}.
\end{itemize}


\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
      \scriptsize
      \begin{verbatim}
<?xml version="1.0" encoding="UTF-8xºx"?>
<!DOCTYPE biblioteca>

<biblioteca>
    <ejemplar tipo="libro" isbn="978-2-7460-4958-1" edicion="1">
        <titulo>XML practico</titulo>
        <editorial>Ediciones Eni</editorial>
        <autor>Sebastien Lecomte</autor>
        <autor>Thierry Boulanger</autor>
        <autor funcion="traductor">Ángel Belinchon Calleja</autor>
        <prestamos>
            <lector inicio="13/05/2014" devolucion="15/05/2014">Pedro López</lector>
            <lector inicio="13/07/2015" devolucion="15/07/2015">Ali Méndez</lector>
        </prestamos>
     </ejemplar>
</biblioteca>
      \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML simple}
\end{figure}

\subsection{Comparación XML y SGML}
Aunque XML esta basado en SGML, estos tienen muchas diferencias. A continuación se muestra una tabla con las principales diferencias de estos dos lenguajes de marcas.

 \begin{table}[h]
     \centering
    {\renewcommand{\arraystretch}{1.5}
        \begin{tabular}[c]{ |l|l| }
            \hline
            \multicolumn{1}{|c|}{\textbf{XML}} & \multicolumn{1}{|c|}{\textbf{SGML}} \\ \hline
            Su uso es sencillo & Su uso es my complejo \\ \hline
            Trabaja con documentos bien formados & Solo Trabaja con documentos válidos \\ \hline
            Desarrollo de aplicaciones a bajo coste & Aplicaciones para procesarlo costosas \\ \hline
            Muy utilizado en informática y otras áreas & Se utiliza en sectores muy específicos\\ \hline
            Compatibilidad e integración con HTML & No hay compatibilidad con HTML \\ \hline
            Formateo y estilos fáciles de aplicar & Formateo y estilo relativamente complejos \\ \hline
    \end{tabular}}
 \end{table}

Como vemos en esta tabla, SGML es un un lenguaje mas complejo y costoso que XML, además de imponer mas restricciones, haciéndolo un lenguaje menos flexible que XML y mas orientado a sectores concretos. Para obtener más información sobre XML, podemos consultar el \href{https://www.w3.org/TR/REC-xml/}{Estándar XML} publicado por la W3C.

\subsection{Comparación XML y HTML}
Aunque tanto XML como HTML se crearon a partir de SGML y su sintaxis es similar, son lenguajes diferentes con propósitos diferentes, como podemos ver en la siguiente tabla.

 \begin{table}[h]
    \centering
    {\renewcommand{\arraystretch}{1.5}
        \begin{tabular}[c]{ |l|l| }
            \hline
            \multicolumn{1}{|c|}{\textbf{XML}} & \multicolumn{1}{|c|}{\textbf{HTML}} \\ \hline
            Es un perfil de SGML & Es una aplicación de SGML \\ \hline
            Permite definir conjuntos de etiquetas & Aplica un conjunto limitado de etiquetas \\ \hline
            Modelo de hiperenlaces complejo & Modelo de hiperenlaces simple \\ \hline
            Navegador como plataforma de desarrollo & Navegador como visor de páginas \\ \hline
            Compatibilidad e integración con HTML & No hay compatibilidad con HTML \\ \hline
            Fin de las etiquetas propietarias & Problema de la no compatibilidad en navegadores \\ \hline
    \end{tabular}}
\end{table}

\section{Etiquetas, Elementos y Atributos}
Los lenguajes de marcas usan una serie de etiquetas intercaladas en un documento sin formato, las cuales serán posteriormente por el interprete del lenguaje.

Existen tres términos ampliamente utilizados en los lenguajes de marcas:

\begin{itemize}
    \item \textbf{Etiquetas}: una etiqueta, también llamada \textbf{tag}, es un pequeño bloque de código que se escribe encerrado entre los símbolos \textbf{menor que} (\textbf{<}) y \textbf{mayor que} (\textbf{>}). Normalmente se utilizan \textbf{dos etiquetas}, una de \textbf{inicio} y otra de \textbf{fin}, para indicar que el efecto que queríamos conseguir ha finalizado, con la única diferencia que a la etiqueta de fin se le añade el carácter \textbf{/} antes del nombre.
    \item \textbf{Elemento}: representan estructuras mediante las que se organiza el contenido del documento, o acciones que se desencadenan cuando el navegador lo interpreta. Está \textbf{compuesto} de la \textbf{etiqueta de apertura}, la \textbf{etiqueta de cierre} y el \textbf{contenido entre ambas}.
    \item \textbf{Atributo}: es un par \textbf{nombre-valor}, que se encuentra al inicio de un elemento e indican diferentes propiedades asociadas a ese elemento
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.50]{elemento-HTML.png}
    \caption{Partes de un elemento HTML}
\end{figure}

\section{Herramientas de Edición}
Para trabajar con XML es necesario, por un lado, editar los documentos, y por otro procesarlos. Por ello, necesitaremos dos tipos de herramientas para trabajar con él, estas son:

\begin{itemize}
    \item \textbf{Editores XML}

    Una característica de los lenguajes de marcas es que se basan en la utilización de ficheros de \textbf{\gls{texto plano}}, por lo que basta con usar cualquier editor de texto para construir un documento XML.

    Aunque podemos usar cualquier editor, cuando elaboramos documentos XML complejos es conveniente usar
    algún software de edición XML. Estos nos ayudan a crear estructuras y etiquetas de los elementos usados en XML, resaltan las etiquetas para diferenciarlas más cómodamente y ademas incluyen ayudas para la creación de otros elementos como DTD, hojas de estilo CSS o XLS,.. El W3C ha desarrollado un editor HTML, XHTML, CSS y XML gratuito llamado Amaya, pero existen otros muchos gratuitos como: Notepad++, VSCode, Sublime Text, Netbeans,..etc

    \item \textbf{Procesadores XML}

    Para interpretar un documento XML puede usarse cualquier navegador. Los procesadores XML permiten visualizar los documentos XML y acceder a su contenido y estructura. Un \textbf{procesador} es un conjunto de módulos de software entre los que se encuentra un \textbf{parser}, que comprueba que el documento cumple las normas establecidas para que pueda abrirse. Estás normas pueden corresponderse a las necesarias para trabajar con documentos de tipo válido o solo exigir que el documento este bien formado. A los primeros se le conocen como \textbf{procesadores validadores} y a los segundos como \textbf{procesadores no validadores}.

    Para publicar documentos XML en internet se usan \textbf{procesadores XSLT}, que permiten generar archivos HTML a partir de XML.

    Puesto que XML se usa para el intercambio de archivos entre aplicaciones, hay que recurrir a motores independientes como <<XML para Java>> de IBM, JAXP de Sun, etc
\end{itemize}

\section{XML}
\textbf{XML}, que significa \textit{eXtensible Markup Language}, es un lenguaje que permite definir lenguajes de marcas desarrollado por el W3C y utilizado para almacenar datos de forma legible. Proviene del lenguaje SGML y permite definir la gramática de lenguajes específicos para estructurar documentos. \cite{xml}

Su importancia radica en que permite \textbf{compartir datos} entre diferentes equipos y aplicaciones de forma \textbf{segura}, \textbf{fiable} y \textbf{sencilla}. El hecho de que diferentes equipos y aplicaciones puedan leer y generar archivos en este formato lo convierte en una herramienta muy útil para el envío de información a través de la Web. Aunque a veces suele confundirse con HTML, podemos decir que HTML esta diseñado para mostrar datos en nuestras pantallas mientras que XML esta diseñado para almacenar y compartir esos datos.

El XML ahorra tiempos de desarrollo y proporciona ventajas, dotando a webs y aplicaciones de un método muy potente para almacenar y compartir información. Por ello, se ha convertido en un formato universal usado por todo tipo de sistemas operativos y dispositivos.

\subsection{Estructura y Sintaxis}
Un documento XML es un documento de de texto, con la \textbf{extensión .xml}, compuesto de un \textbf{conjunto de etiquetas}, \textbf{estructuradas en árbol}, que describen la organización del documento y que es interpretado por un navegador Web.

La \textbf{características básicas} de XML son las siguientes:

\begin{itemize}
    \item Es directamente \textbf{compatible} con protocolos usados en en la Web como \textbf{HTTP} y \textbf{URL}.
    \item Todo documento que verifique las reglas de XML esta \textbf{conforme con SGML}.
    \item \textbf{No se requieren conocimientos de programación} para realizar tareas sencillas en XML.
    \item Los documentos XML son\textbf{ fáciles de crear}.
    \item \textbf{La difusión} de documentos XML \textbf{está asegurada}, ya que cualquier procesador de XML puede leer documentos XML.
    \item El marcado de XML es \textbf{legible para los humanos}.
    \item El diseño de XML es \textbf{formal y conciso}.
    \item XML es \textbf{extensible}, \textbf{adaptable} y \textbf{aplicable} a una gran variedad de situaciones.
    \item XML es \textbf{orientado a objetos}
    \item Todo documento XML se \textbf{compone} de \textbf{datos de marcado} y \textbf{datos carácter} entremezclados.
\end{itemize}

El \textbf{proceso de creación} de un documento pasa por varias etapas en las que el éxito de cada una de ellas se basa en la calidad de la anterior. Estas etapas son:

\begin{enumerate}
    \item Especificación de requisitos.
    \item Diseño de etiquetas.
    \item Marcado de los documentos.
\end{enumerate}

El \textbf{marcado} son etiquetas que se añaden para estructurar los documentos y permitir a los ordenadores interpretar los textos. Los \textbf{datos carácter} son los que componen la verdad información del documento.

Los documentos XML también pueden \textbf{contener comentarios}, que son interpretados por el intérprete XML y que comienzan con la cadena \textit{<!--} y finalizan con \textit{-->}. Pueden estar en cualquier posición del documento salvo en:

\begin{itemize}
    \item El prólogo
    \item Dentro de una etiqueta
\end{itemize}

Los XML están \textbf{formados} por dos partes, \textbf{el prólogo} y \textbf{el ejemplar}, los cuales veremos a continuación.

\subsection{El Prólogo}
El prólogo es la primera parte que nos encontramos en cualquier documento XML y siempre debe preceder al ejemplar del documento. Éste se divide en dos partes, la \textbf{declaración XML} y la \textbf{declaración de la codificación} empleada, los cuales explicamos a continuación.

\begin{enumerate}
    \item\textbf{La declaración XML}: es la primera linea del documento, de no ser así, se genera un error que impide que el documento sea procesado. En caso de que sea opcional, se permite el procesamiento de documentos HTML y SGML como si fueran documentos XML, si es obligatoria, estos deberán incluir la declaración de la versión XML. Esta declaración permite indicar de forma explicita que el documento es de tipo XML.

    El prologó puede tener \textbf{tres funciones}:

    \begin{enumerate}
        \item \textbf{Declaración de la versión} utilizada de XML:
        \begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
             \begin{verbatim}               <?xml version= “1.0”?>\end{verbatim}
         \end{tcolorbox}

         \item \textbf{Declaración de la codificación empleada}:
         \begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
          \begin{verbatim}     <?xml version= “1.0” encoding=”iso-8859-1” ?>\end{verbatim}
        \end{tcolorbox}

         En este caso se usa el código código iso-8859-1 (Latin-1) que permite el uso de tildes o caracteres como la <<ñ>>. Otro de los códigos a tener en cuenta es \textbf{\gls{UTF-8}} (\textbf{\gls{unicode}}). Esta codificación soporta más caracteres que iso-8859-1 y permite que estos se visualicen correctamente en más sistemas. Es la \textbf{codificación estándar} recomendada para todos los documentos y la usaremos siempre, salvo que por algún motivo no pueda ser empleada.

         Para consultar más información sobre codificación de caracteres en sistemas informáticos y cuales son los más empleados podemos visitar  \href{https://en.wikipedia.org/wiki/Character_encoding}{página de Wikipedia} sobre codificación de caracteres.

         \item \textbf{Declaración de autonomía del documento}:

         Indica si el documento necesita de otro para su interpretación. Para declararlo, hay que definir el prólogo completo:
         \begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
             \small
             \begin{verbatim}<?xml version= “1.0” encoding=”iso-8859-1” standalone=”yes” ?>\end{verbatim}
         \end{tcolorbox}

         La opción \textit{standalone} indica al procesador XML si un documento es independiente (\textit{standalone="yes"}), o si depende de un documento externo, como declaraciones de marcas externas o una DTD externa (\textit{standalone="no"}). Por defecto el documento se considera independiente.
    \end{enumerate}

    \item \textbf{La declaración del tipo de documento}:

    Esta declaración define el tipo de documento que estamos creando para que sea procesado correctamente. Toda declaración de tipo de documento comienza con la cadena:

    \begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
        \begin{verbatim}                 <!DOCTYPE Nombre_tipo ...>\end{verbatim}
    \end{tcolorbox}
\end{enumerate}

\subsection{El Ejemplar}
Es la parte más importante de un documento XML ya que contiene los \textbf{datos reales} del documento. Es el \textbf{elemento raíz} de un documento XML y este se nombrará igual que la declaración del tipo de documento (\textit{!DOCTYPE}). Suele estar compuesto de \textbf{elementos anidados}.

En el siguiente ejemplo, el ejemplar es el elemento \textit{<libro>}, que a su vez esta compuesto de los elementos \textit{<titulo>}, \textit{<autoria>}, \textit{<editorial>}, \textit{<isbn>}, \textit{<edicion>} y \textit{<paginas>}.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
      <?xml version="1.0" encoding="utf-8" standalone="yes"?>
      <!DOCTYPE libro>

      <libro>
        <titulo>XML práctico</titulo>
        <autoria>
            <autor>Sebastien Lecomte</autor>
            <autor>Thierry Boulanger</autor>
        </autoria>
        <editorial>Ediciones Eni</editorial>
        <isbn>978-2-7460-4958-1</isbn>
        <edicion>1</edicion>
        <paginas>347</paginas>
      </libro>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Ejemplo del \textit{ejemplar} en un documento XML}
\end{figure}

Es recomendable \textbf{establecer un criterio} y mantenerlo durante todo el documento, por ejemplo, que las etiquetas vayan escritas \textbf{siempre en minúsculas}.

Por otro lado, es conveniente anidar los elementos para una visualización óptima del documento, esto se hará \textbf{indentando} o \textbf{tabulando} el código. A continuación se muestran dos figuras, una sin indentación (errónea) y otra con indentación (correcta).

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <!DOCTYPE libro>

        <libro>
        <titulo>XML práctico</titulo>
        <autoria>
        <autor>Sebastien Lecomte</autor>
        <autor>Thierry Boulanger</autor>
        </autoria>
        <editorial>Ediciones Eni</editorial>
        <isbn>978-2-7460-4958-1</isbn>
        </libro>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Código XML sin indentación (incorrecto)}
\end{figure}

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <!DOCTYPE libro>

        <libro>
            <titulo>XML práctico</titulo>
            <autoria>
                <autor>Sebastien Lecomte</autor>
                <autor>Thierry Boulanger</autor>
            </autoria>
            <editorial>Ediciones Eni</editorial>
            <isbn>978-2-7460-4958-1</isbn>
        </libro>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Código XML con indentación (correcto)}
\end{figure}

Como podemos observar, en la segunda figura se reconoce más fácilmente la estructura del documento y se facilita la lectura de este.

Por último, es recomendable \textbf{anidar grupos de datos relacionados}, como se ha hecho en el ejemplo anterior con los elementos \textit{<autor>} dentro del elemento \textit{<autoria}, ya que el documento que \textbf{mas limpio} y \textbf{ordenado}.

\subsubsection{Elementos}
\textbf{Todos los datos} de un documento XML deben \textbf{pertenecer} a un \textbf{elemento del mismo}.

Los elementos son los diferentes \textbf{bloques de información} que permiten definir la \textbf{estructura} del documento XML. Estos está delimitados por una \textbf{etiqueta de apertura} y una \textbf{etiqueta de cierre}. Pueden estar \textbf{compuestos} por \textbf{otros elementos}.

Los \textbf{nombres} de las etiquetas deben ser \textbf{autodescriptivos}, es decir, que ilustren su contenido. Por ejemplo, si estamos con datos relativo a un libro, una etiqueta no debería ser \textit{<caracteristicas>}, ya que es demasiado ambiguo, deberíamos utilizar nombres como \textit{<titulo>}, \textit{<isbn}, etc...

La \textbf{formación de elementos} debe cumplir ciertas \textbf{normas} para que queden bien definidos y que el documento XML al que pertenecen pueda ser procesado sin generar ningún error fatal. Estas normas son las siguientes:

\begin{itemize}
    \item En todo documento XML debe existir \textbf{un documento raíz} y \textbf{solo uno}.
    \item \textbf{Todos} los elementos tienen una \textbf{etiqueta de inicio} y \textbf{otra de cierre}. En caso de que en el documento existan \textbf{elementos vacíos}, se pueden sustituir las etiquetas de apertura y cierre por una de elemento vacío. Esta se construye como una etiqueta de inicio pero añadiendo \textbf{/}, es decir, \textit{<elemento/>} en vez de \textit{<elemento>}. Esta considerada una etiqueta de apertura y cierre.
    \item Al anidar hay que tener en cuenta que \textbf{no puede cerrarse} ningún\textbf{ elemento} que \textbf{contenga otro elemento} que aún \textbf{no se haya cerrado}.
    \item Los \textbf{nombres} de las \textbf{etiquetas de apertura y cierre} deben ser \textbf{idénticos}, respetando las mayúsculas y minúsculas. Pueden ser cualquier cadena alfanumérica que no contenga espacios ni tildes, y que no comience por dos puntos (\textbf{:}), ni por la cadena \textbf{xml}.
    \item El contenido de los elementos \textbf{no puede contener} la cadena <<\textbf{\textit{]]>}}>>, por compatibilidad con SGML. Además, no se pueden utilizar los caracteres \textbf{mayor que} (\textbf{>}), \textbf{menor que} (\textbf{<}), \textbf{ampersand} (\textbf{\&}), \textbf{dobles comillas} (\textbf{"}) y \textbf{apostrofe} (\textbf{`}).

    En caso de tener que utilizar alguno de estos caracteres, se deben sustituir por las siguientes cadenas:

    \begin{table}[ht]
        \centering
        {\renewcommand{\arraystretch}{1.5}
            \begin{tabular}{ |l|l| }
                \hline
                \multicolumn{1}{|c|}{\textbf{Caracteres}} & \multicolumn{1}{|c|}{\textbf{Cadena}} \\ \hline
                \multicolumn{1}{|c|}{>} & \multicolumn{1}{|c|}{\&gt;} \\ \hline
                \multicolumn{1}{|c|}{<} & \multicolumn{1}{|c|}{<\&lt;} \\ \hline
                \multicolumn{1}{|c|}{\&} & \multicolumn{1}{|c|}{\&amp;} \\ \hline
        \end{tabular}}
         \quad
        {\renewcommand{\arraystretch}{1.5}
            \begin{tabular}{ |l|l| }
                \hline
                \multicolumn{1}{|c|}{\textbf{Caracteres}} & \multicolumn{1}{|c|}{\textbf{Cadena}} \\ \hline
                \multicolumn{1}{|c|}{"} & \multicolumn{1}{|c|}{\&quot;} \\ \hline
                \multicolumn{1}{|c|}{'} & \multicolumn{1}{|c|}{\&apos;} \\ \hline
                \multicolumn{1}{|c}{}& \\ \hline
        \end{tabular}}
     \end{table}

     \item Para \textbf{utilizar caracteres especiales}, como £, ©, ®,... hay que usar las expresiones \textit{\textbf{\&\#D;}} o \textit{\textbf{\&\#H;}}, donde D y H se corresponden con el número decimal o hexadecimal, respectivamente, correspondiente al carácter que se quiere representar en código \textbf{UNICODE}.

     En los siguientes enlaces puedes consultar tanto los códigos ASCII y su equivalente en HTML, como el código correspondiente a cada carácter en UNICODE.

     \begin{itemize}
         \item ASCII - \url{https://www.asciitable.com/}
         \item UTF-8 - \url{https://www.charset.org/utf-8}
     \end{itemize}
\end{itemize}

\subsubsection{Atributos}
Las etiquetas pueden tener \textbf{atributos}, que \textbf{permiten definir propiedades} a los elementos de un documento. Los atributos, a diferencia de los elementos, no puede organizarse en ninguna jerarquía	o estructura de árbol, no pueden contener ningún otro elemento, no pueden contener valores múltiples y no reflejan ninguna estructura lógica. En definitiva, los atributos \textbf{no se podrán extender fácilmente} en futuros cambios.

Un elemento puede tener varios atributos, pero ninguno de estos puede estar vacío, además todos los atributos dentro de un elemento \textbf{deben ser únicos}. Los atributos se codifican de la siguiente forma:

\begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
    \begin{verbatim}        <etiqueta atributo="valor_atributo"></etiqueta>\end{verbatim}
\end{tcolorbox}

No debe usarse un atributo para almacenar información susceptible de ser dividida, sino para proporcionar información adicional sobre el elemento. A continuación vamos a ver un ejemplo de la utilización de atributos en un documento XML.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
       <?xml version="1.0" encoding="utf-8" standalone="yes"?>
       <centro_educativo>
           <alumno sexo="Varón" fecha_nacimiento="05/06/1990">
               <nombre>Pablo</nombre>
               <apellido>Pérez</apellido>
               <telefono tipo="Móvil">666666666</telefono>
               <direccion tipo="Calle">Policar, 34</direccion>
           </alumno>
        </centro_educativo>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Uso de atributos en documentos XML}
\end{figure}

Por norma general, intentaremos \textbf{evitar el uso} de atributos o procurar \textbf{no abusar de ellos}. Normalmente \textbf{los usaremos} para \textbf{metadatos} o información que no sea relevante para los datos. Se puede ver como una manera de incorporar características o propiedades a los elementos, como en el siguientes ejemplo: \textit{<perro raza=``Pastor''>Lolo</perro>}. También se suelen para especificar unidades de medida y similares: \textit{altura unidad\_altura=``cm''>178</altura>}. Hay que destacar que toda la información que se almacena en atributos se podría almacenar igualmente en elementos.

Lo que si es recomendable es que \textbf{una vez elegido un estilo}, mantenerlo dentro de todo el documento XML, teniendo en cuenta que los \textbf{nombres de los atributos} tienen que cumplir las \textbf{mismas normas} que los \textbf{elementos}, y no pueden contener el carácter menor que ``<''.

\section{Documentos XML bien formados}
Los documentos XML deben de estar \textbf{bien formados}, es decir, ser documentos \textbf{válidos}.

Los \textbf{documentos bien formados} son aquellos que cumplen las reglas sintácticas de creación de documentos XML ya mencionados en los puntos anteriores, como por ejemplo, que usan caracteres válidos para la creación de nombres de etiquetas o atributos, que las etiquetas estén cerradas correctamente, etc...

Los \textbf{documentos válidos} son aquellos que, ademas de estar bien formados, cumplen los requisitos de una definición de estructura (DTD, Schema,..), que veremos en la siguientes unidad.

Por lo tanto, para que un documento esté bien formado, debe \textbf{verificar} las \textbf{reglas sintácticas} que define la recomendación de la W3C para el \textbf{estándar XML}. Estas normas básicas se pueden resumir en las siguientes:

\begin{itemize}
    \item El documento ha de tener \textbf{definido} una \textbf{declaración XML} en el prólogo:

    \begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
        \begin{verbatim}  <?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\end{verbatim}
    \end{tcolorbox}

    Hay que tener en cuenta que aunque es posible omitir el prólogo, hay navegadores que nos pueden devolver un error al procesar el documento, por lo que siempre hay que incluirlo para evitar problemas. En caso de omitirlo, los valores por defecto son los mostrados encima de este párrafo.

    \item Existe un \textbf{único elemento raíz} por cada documento: es un solo elemento en el que todos los demás contenidos y elementos se encuentran anidados.
    \item Los elementos se organizan entre sí en un \textbf{estructura jerárquica} y \textbf{no se permite} el \textbf{solapamiento} de éstos.
    \item Hay que \textbf{cumplir reglas sintácticas} a la hora de definir el nombre de elementos y atributos. Estas normas se pueden resumir en:
    \begin{itemize}
        \item El \textbf{nombre de elementos} puede contener como \textbf{primer carácter} los siguientes: \textit{[A-Z]},  \textit{[a-z]} y \textit{``\_''}. Para el resto de caracteres, ademas de estos, se pueden emplear: \textit{[0-9]}, \textit{``-''} y \textit{``.''}.
        \item Las \textbf{etiquetas de apertura y cierre} deben ser \textbf{idénticas}, teniendo en cuenta que XML es sensible a mayúsculas y minúsculas.
        \item Los \textbf{valores de los atributos} se escribirán siempre entre \textbf{comillas dobles o simples}. Si quisiéramos usar alguno de estos caracteres dentro del nombre usaríamos \&quot; (") y \&apos; ('). También hay que tener en cuenta que hay nombres reservados para el uso del lenguaje.
        \item \textbf{Los comentarios} en XML se escriben así: \textit{ <!-- Comentario -->}
    \end{itemize}
\end{itemize}

\subsection{Espacios de Nombres}
Los \textbf{espacios de nombres} permiten definir la pertenencia de los elementos y nombres a un contexto de vocabulario XML. De esta forma se resuelven las ambigüedades que se pueden producir al juntar dos documentos donde os autores han usado nombres similares para diferentes elementos.

Los espacios de nombres, también conocidos como \textbf{XML namespaces}, permiten dar nombre único a un elemento, indexándolo según un nombre de vocabulario adecuado. Además, están asociados a una \textbf{\gls{URI}}.

En el documento, las etiquetas ambiguas se sustituyen por otras con el nombre precedido de un \textbf{prefijo}, que determina el contexto al que pertenece dicho nombre:

\begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
    \begin{verbatim}       <prefijo:nombre_etiqueta></prefijo:nombre_etiqueta>\end{verbatim}
\end{tcolorbox}

Esta etiqueta de denomina \textbf{nombre cualificado}. Al definir el prefijo hay que tener en cuenta que no se pueden usar espacios ni caracteres especiales y que no puede comenzar por un dígito.

Antes de poder usar el espacio de nombres hay que declararlo, es decir, asociar un índice con la URI asignada al espacio de nombres, mediante un atributo \textbf{xmlns}. Esto se hace entre el prólogo y el ejemplar y tiene la siguientes sintaxis:

\begin{tcolorbox}[sharp corners, colback=yellow!40, colframe=white!20]
    \begin{verbatim}   <conexion>://<direccionservidor>/<apartado1>/<apartado2>/...\end{verbatim}
\end{tcolorbox}

Si queremos consultar más información acerca de los espacios de nombres, podemos consultar el estándar en la \href{https://www.w3.org/TR/REC-xml-names/}{recomendación en XML de la W3C}.

\section{Sistemas de Gestión Empresarial}
Lo primero que debemos de entender antes de meternos de lleno en los sistemas de gestión empresarial es como fluye el flujo de información en una empresa, es decir, conocer sus recursos empresariales y gestionarlos eficientemente. Estos flujos de información son los siguientes:

\begin{itemize}
    \item Entre los empleados de la empresa.
    \item Entre los empleados y la empresa.
    \item Entre la empresa con sus clientes y proveedores.
\end{itemize}

Estos \textbf{flujos de información} se puede clasificar en dos tipos:

\begin{itemize}
    \item Informales y no estructurados.
    \item Formales y estructurados, que se centran en información de procesos críticos de la empresa.
\end{itemize}

Para facilitar estos flujos de información es conveniente tener instalado un \textbf{Sistema de Información}, que facilite el conocimiento propio de la empresa para mejorar la \textbf{planificación}, la \textbf{gestión} y el \textbf{control}.

Un \textbf{Sistema de Información} se define como un conjunto organizado, de elementos relacionados, orientados  al tratamiento y administración de la información. Esta compuesto por elementos físicos, humanos y por un conjunto de normas y protocolos.

La utilización de sistema de información ofrece \textbf{ventajas competitivas} a las empresas, mejorando su eficiencia, calidad del producto o mejorando los servicios ofrecidos a los clientes. También ayudan, entre otras cosas, a la captación de clientes.

La automatización de los flujos de información cambió sustancialmente con el surgimiento de los \textbf{\gls{ERP}} y los \textbf{\gls{CRM}}, en los que se integran las diferentes aplicaciones que soportan los procesos de la empresa.

\subsection{ERP}
En una empresa, salvo que esta sea muy pequeña, es necesario usar algún sistema automatizado de gestión para controlar todos los recursos empresariales y procesos. Aquí es donde entran en juego los ERP.

Un \textbf{ERP} es un \textbf{sistema de gestión de la información} que se caracteriza por ser \textbf{una aplicación} donde hay \textbf{varias partes integradas} y se \textbf{especializa en manejar} todos los \textbf{datos relevantes} para la continuidad de la empresa. Estas partes gestionan diferentes procesos, por ejemplo producción, ventas, compras, pedidos, nóminas, etc...

Un \textbf{CRM} es un tipo de ERP que se centra en la \textbf{relación con los clientes} que tiene una empresa, es decir, información de contacto orientada a ventas.

Los \textbf{objetivos principales} de un ERP son los siguientes:

\begin{itemize}
    \item \textbf{Optimizar} los procesos empresariales.
    \item \textbf{Acceder} a la información de forma confiables y precisa.
    \item \textbf{Permitir} compartir información entre los componentes de la organización.
    \item \textbf{Eliminar} los datos y operaciones innecesarias.
\end{itemize}

Las \textbf{características} que diferencia a los ERPs de otras aplicaciones, es que deben ser \textbf{sistemas integrales}, \textbf{modulares} y \textbf{adaptables}. Sus principales características son:

\begin{itemize}
    \item Ser un programa con \textbf{acceso de una base de datos}.
    \item Sus \textbf{componentes interactúan} entre sí.
    \item Las \textbf{datos} deben ser \textbf{consistentes}, \textbf{completos}.
\end{itemize}

Suelen ser \textbf{sistemas complejos} de implantar ya que necesitan un desarrollo personalizado para las necesidades de la empresa a partir del paquete básico. Estas adaptaciones, suelen estar a cargo de \textbf{consultorías}.

Las \textbf{consultorías} en materia de \textbf{ERP} suelen ser de dos tipos:

\begin{itemize}
    \item \textbf{Consultoría de negocios}: estudia los procesos de negocio de la compañía y personaliza el ERP para ajustarlo a las necesidades de la organización.
    \item \textbf{Consultoría técnica}: estudia los recursos tecnológicos existente.
\end{itemize}

En la actualidad, la mayoría de sistemas ERP poseen \textbf{interfaz web} que mejora la accesibilidad al sistema desde prácticamente cualquier lugar y dispositivo.

\subsubsection{Características}
Las características que distinguen a un sistema de gestión empresarial son las siguientes:

\begin{itemize}
    \item \textbf{Integración}: un sistema ERP \textbf{integra todos los procesos de la empresa}, considerándolos como un serie de áreas que se relacionan entre sí para conseguir una mayor eficiencia, reduciendo tiempo y costes.
    \item \textbf{Modularidad}: \textbf{cada módulo} de un sistema ERP se corresponde con un \textbf{área funcional} de la empresa. Gracias a una \textbf{base de datos centralizada}, todos los módulos pueden compartir información entre sí, facilitando la adaptabilidad, personalización e integración. Cada módulo suele usar un software específico para su funcionalidad.
    \item \textbf{Adaptabilidad}: aunque las dos características anteriores facilitan la adaptabilidad del ERP a los requisitos de la empresa, a veces se utiliza una solución más genérica, para abaratar costes, y se modifican algunos procesos para adaptarlos al sistema ERP.
\end{itemize}

Gracias a la modularidad y la capacidad de integración de las funcionalidades, los ERPs se pueden adaptar fácilmente a las necesidades de cada empresa. Los diferentes módulos se interconectan entre sí de forma que una única herramienta ERP puede adaptarse a diferentes empresas cambiando el conjunto de módulos activos y sus relaciones.

Los \textbf{módulos principales} que forman un ERP son los siguientes:

\begin{itemize}
    \item \textbf{Ventas/Marketing}: interfaz pública que interactúa con los clientes, pedidos, estrategias de ventas, precios, promociones, publicidad, etc..
    \item \textbf{Finanzas}: es la base de cada ERP, donde se almacenan las transacciones facilitando las auditorías.
    \item \textbf{Inventario/Logística}: controla el stock y los flujos de entrada y salida.
    \item \textbf{Recursos Humanos}: gestión de personal, nómina, productividad, incentivos, etc..
    \item \textbf{Producción}: en núcleo que se encarga de los movimientos físicos del producto, planificación de materiales, etc..
\end{itemize}

Estos módulos son considerados los básicos, pero se pueden añadir muchos más como proyectos, planificación de ventas, configuración de productos a medida, etc..

No todos los \textbf{trabajadores} accederán al ERP de la misma forma, ya que cada grupo tiene su \textbf{rol}, que será supervisado por un administrador, por lo que dependiendo de este rol el trabajador tendrá unos u otros módulos habilitados.

Mención especial requieren los \textbf{CRM} (Customer Relationship Management), que surgen como consecuencia de la aplicación especifica de los ERP a las interacciones con los clientes. Están centrados en mantener, crear y potencias las relaciones con clientes sirviendo de apoyo a las políticas de marketing de la empresa.

En la actualidad los sistemas globales de CRM se pueden dividir en:

\begin{itemize}
    \item \textbf{Aplicaciones} electrónicas para los \textbf{canales de distribución} de la empresa.
    \item Centros de \textbf{atención telefónica}.
    \item \textbf{Autoservicio} para los clientes.
    \item \textbf{Gestión} electrónica de las \textbf{actividades} que afecten a los clientes.
    \item \textbf{Ventas}.
\end{itemize}

Entres sus \textbf{principales características} se encuentran la facilidad de \textbf{toma de decisiones} en \textbf{tiempo real}, \textbf{incremento de la rentabilidad} del clientes gracias a que se obtiene información muy útil a través de datos complejos, por ejemplo, identificando a los clientes que compran o que no están interesados y actuar en consecuencia.

\subsubsection{Ventajas e Inconvenientes}
Contar con un \textbf{sistema ERP personalizado}, permite a la empresa tener integradas diferentes utilidades que facilitan la gestión de la información. Aunque estos sistemas ofrecen muchas ventajas para una empresa, también tiene sus inconvenientes, como podemos ver en la siguiente lista.

\begin{itemize}
    \item \textbf{Ventajas}
    \begin{itemize}
        \item \textbf{Aumento} de la \textbf{información} que tiene la empresa sobre sus \textbf{potenciales clientes}. Los ERP que incluyen CRM aportan beneficios relacionados con la gestión de clientes de la empresa. Algunos incluyen control de calidad de los productos, permitiendo enfocar la oferta en las necesidades y deseos de los clientes, con la consecuente mejora de la satisfacción de estos.
        \item \textbf{Aumento} de las \textbf{ventas}.
        \item Permiten \textbf{resolver problemas} relacionados con el \textbf{tratamiento de la información} derivado del uso de sistemas anteriores.
        \item \textbf{Aumenta} la \textbf{eficiencia operativa}.
        \item \textbf{Facilitan} el \textbf{acceso de la información} y constituyen una mejora en las herramientas de tratamiento de la misma.
        \item \textbf{Reducción} de \textbf{costes empresariales}, especialmente los relacionados con las operaciones de las tecnologías de la información y comunicaciones.
        \item Permiten mayor \textbf{facilidad de configuración} de los sistemas de la empresa.
        \item Mejoran el \textbf{entorno de integración} de todas sus acciones.
    \end{itemize}
    \item \textbf{Inconvenientes}
    \begin{itemize}
        \item El ERP ha de ser usado y realizado por \textbf{personal capacitado}.
        \item La \textbf{instalación} del ERP es \textbf{muy costosa}.
        \item Los ERP son vistos como \textbf{sistemas muy rígidos} y difíciles de adaptar al modo de trabajo de las empresas.
        \item Son sistemas que sufren de problemas de \textbf{cuello de botella}, es decir, todos los usuarios se pueden ver afectados por la ineficiencia en uno de los departamentos.
        \item Altos \textbf{coste de modificación} de un ERP ya implantado.
    \end{itemize}
\end{itemize}

\subsubsection{ERP de Software Libre}
Dentro de los ERP de software libre encontramos una gran variedad de aplicaciones para la gestión empresarial. Entre ellas podemos destacar \textbf{Openbravo}, que es una iniciativa de origen español y \textbf{OpenERP}, actualmente conocido como \textbf{Odoo}, de origen belga y que se carateriza por tener una gran cantidad de módulos.

\textbf{Openbravo} es una aplicación de código abierto de planificación de recursos empresariales. Utiliza una arquitectura \textbf{cliente/servidor} web y esta escrita en \textbf{Java}. Se ejecuta sobre un servidor web y ofrece \textbf{soporte} para la diferentes bases de datos \textbf{Oracle} y \textbf{PostgreSQL}. Consta de dos versiones:

\begin{itemize}
    \item \textbf{Openbravo Community Edition}: versión libre y gratuita desde la que no se puede acceder a los módulos comerciales. Tiene licencia \textbf{\gls{OBPL}}.
    \item \textbf{Openbravo Network Edition}: versión bajo licencia \textbf{\gls{OBCL}} que ofrece actualizaciones de código y si ofrece acceso a los módulos comerciales.
\end{itemize}

Además de estas dos versiones, Openbravo ofrece dos soluciones diferentes:

\begin{itemize}
    \item \textbf{Suite de comercio Openbravo}: solución de comercio para minoristas.
    \item \textbf{Suite de negocio Openbravo}: solución global para empresas.
\end{itemize}

Por otro lado tenemos \textbf{Odoo} (anteriormente \textbf{OpenERP}) que resuelve problemas complejos haciendo uso de soluciones sencillas. Esta escrita en \textbf{Python} y hace uso de la base de datos \textbf{PostgreSQL}.

\textbf{OpenERP} fue creado en el año 2005 por un joven informático belga llamado \textbf{Fabien Pickaers}, causando gran sorpresa de que creara un programa de estas características y lo pusiera de forma gratuita en internet, mientras otras empresas venden sus productos a precios desorbitados. El modelo de Odoo esta basado en los servicios prestados en torno al software y tiene colaboradores alrededor de todo el mundo. En este enlace podemos ver el motivo del \href{https://openerpspain.com/}{cambio de nombre de OpenERP a Odoo}, así como la respuesta a algunas preguntas interesantes.

A continuación se muestran algunos enlaces de interese sobre estos ERPs:

\begin{itemize}
    \item \textbf{Página oficial Openbravo} - \url{www.openbravo.com/es/}
    \item \textbf{Wiki sobre OpenBravo} - \url{http://wiki.openbravo.com/wiki/Main_Page}
    \item \textbf{Página oficial de Odoo} - \url{http://www.openerp.com/es}
    \item \textbf{Doc. de usuario de Odoo} - \url{https://www.odoo.com/documentation/8.0/}
    \item \textbf{Doc. ténica de Odoo} - \url{https://www.odoo.com/documentation/user/}
\end{itemize}

\subsubsection{Instalación}
Para realizar la instalación de paquete de gestión empresarial, primero tenemos que definir \textbf{cuales} son las \textbf{necesidades que debe cubrir} el software y buscar aquel que se ajuste mejor.

En general, las \textbf{tareas} implicadas en la \textbf{instalación e implantación} de un ERP son las siguientes:

\begin{itemize}
    \item \textbf{Diseño de la instalación}: antes de iniciar la instalación deberá hacerse una análisis de cuales son las necesidades de la empresa y como las resuelve el ERP.
    \item \textbf{Instalación de equipos servidores y clientes}: será necesario revisar y actualizar el hardware de la empresa para que cumpla los requisitos el ERP.
    \item \textbf{Instalación del software}: instalación del ERP y del software que este necesite para su correcto funcionamiento.
    \item \textbf{Adaptación y migración del programa}: una vez instalado, será necesario configurarlo y adaptarlo a la empresa del cliente.
    \item \textbf{Migración de datos}: este proceso es de gran importancia ya que los datos son vitales para el correcto funcionamiento de la empresa. En ocasiones, si no hay forma de automatizar el proceso, deberá hacerse de forma manual.
    \item \textbf{Realización de pruebas}: la instalación del nuevo software puede conllevar un tiempo de transición en el que convivirá con el anterior software de gestión de la empresa. Durante este periodo de tiempo de deberán realizar pruebas para comprobar que el ERP funciona correctamente y los resultados son satisfactorios.
    \item \textbf{Documentación del sistema}: en esta fase se deben elaborar los manuales y documentos necesarios y ponerlos a disposición de la organización mediante los medios de difusión interna de los que disponga, como correo electrónico, tablón de anuncios, etc..
    \item \textbf{Formación de usuarios}: por último hay que formar a los usuarios en la utilización del ERP, empezando por los responsables de proyecto y siguiendo por los usuarios finales.
\end{itemize}

En la mayoría de los casos el sistema ERP correrán en una plataforma \textbf{cliente-servidor}, pero también pueden correr en un \textbf{servidor Web} o utilizar \textbf{tecnologías \gls{SaaS}}.

Independientemente del sistema operativo que tengamos instalado en nuestra empresa o que decidamos usar para implementar nuestro ERP, tenemos que \textbf{tener en cuenta} lo siguientes:

\begin{itemize}
    \item Tener un \textbf{servidor} donde instalaremos nuestros ERP.
    \item Instalar nuestra \textbf{base de datos} y conectarla con nuestro ERP.
    \item Instalar los \textbf{módulos necesarios ERP} que hayamos decidido adquirir.
    \item \textbf{Configurar} los diferentes \textbf{clientes} para que accedan al servidor y puedan realizar peticiones al ERP.
\end{itemize}

Hay que tener en cuenta que es \textbf{imprescindible} tener una \textbf{base de datos} instalada en nuestra empresa, ya que el sistema ERP se basa en la utilización de una base de datos para realizar los informes y las consultar. Así mismo, si decidimos incorporar el ERP a la \textbf{intranet} de la empresa será necesario disponer de un \textbf{servidor web} con soporte para el lenguaje de script en el que se haya programado la aplicación.

Los \textbf{tipos de instalación} de un sistema ERP/CRM dependerá de la plataforma con la que vayamos a trabajar con él. Los mas habituales son los siguientes:

\begin{itemize}
    \item \textbf{Instalación en máquina virtual}: la aplicaciones y programas necesarios se proporcionarán en una máquina virtual lista para su utilización. Esta opción \textbf{no es apta} para entornos de \textbf{producción}, sino que se suele usar para probar el ERP.
    \item \textbf{Instalación de paquetes en entorno gráfico}: en este caso la instalación se hace mediante el entorno gráfico del sistema operativo, usando asistentes que instalan y resuelven las dependencias de los paquetes. Aunque esta opción se puede usar en producción. los \textbf{paquetes} pueden \textbf{no estar actualizados} a la última versión.
    \item \textbf{Instalación personalizada}: si queremos instalar la versión mas reciente de la aplicación podemos descargarnos los paquetes desde la pagina web que los contenga y instalarlos de forma manual mediante comandos. Esta opción permite un mayor control sobre los paquetes que se instalan aunque también es mas compleja de llevar a cabo.
    \item \textbf{No instalar y acceder a la aplicación online}: algunos ERP nos permiten usar el software sin necesidad de instalarlo, accediendo a ir mediante internet conectándonos a un servidor que tiene todos los datos y programas de aplicación. Esta es la opción utilizada por los proveedores de ERP que ofrecen el servicio SaaS.
\end{itemize}

En \textbf{Odoo} podemos realizar diferentes tipos de instalaciones, desde paquetes, donde no tendremos que hacer prácticamente nada, hasta instalaciones paso a paso donde tendremos que instalar y configurar cada componente. Desde la \textbf{versión 8.0}, el \textbf{servicio de acceso} de \textbf{cliente de escritorio} no existe, y su acceso se \textbf{realiza} a través de un \textbf{cliente web}. Esta es la forma de acceso a la mayoría de los ERP actualmente.

\subsubsection{Personalización}
Los sistemas ERP actuales permiten la incorporación de diferentes módulos predefinidos que facilitan la personalización de la aplicación.

Un \textbf{módulo} es una aplicación que se crea para realizar una determinada función. Existen unos \textbf{módulos básicos} que se pueden cargar durante la instalación y otros que pueden instalarse posteriormente. La \textbf{integración} de estos módulos pueden realizarse durante la instalación del sistema o posteriormente durante su \textbf{ampliación}.

La integración de estos módulos se puede realizar en el momento de la instalación o posteriormente. Éstos ofrecen una una gran variedad de recursos, como creación de informes avanzados, servicios de comunicación para plataformas móviles, etc.. Hoy en día la mayoría de ERP también incluyen un modulo CRM integrado.

Para instalar los módulos hay que acceder al ERP con un usuario que tenga permisos de administrador y usar el cargador de módulos que tienen estos paquetes.

Los \textbf{principales módulos} que nos podemos encontrar en un ERP son:

\begin{itemize}
    \item \textbf{Gestión contable y financiera}: se encarga de recoger todas las operaciones contables de la compañía, centralizándolas para su consulta, publicación y control. Es módulo necesita estar integrado con un módulo de ventas para evitar duplicidades y poder acceder a los datos en tiempo real.
    \item \textbf{Compras, ventas y almacén}: el módulo de compras y ventas se encarga de registrar todas las operaciones de solicitudes de presupuestos, a proveedor, recepción de precios y creación de pedidos de compra. El módulo almacén permite gestionar las existencias de productos en almacén.
    \item \textbf{Facturación}: se encarga de generar todo tipo de información generado con la facturación de productos y servicios.
    \item \textbf{Gestión de Personal}: es módulo lleva a cabo la planificación y realización de las nominas, contratos, altas, bajas, control de horarios y datos del personal, además del sistema de pago a los empleados.
    \item \textbf{Gestión de relaciones con el cliente}: estos módulos, los \textbf{CRM}, permiten registrar todo lo relativo a la relación comercial con los clientes o posibles clientes.
\end{itemize}

En los siguientes enlaces, podemos consultar los diferentes módulos que tiene los dos ERPs que hemos tratado en esta unidad.

\begin{itemize}
    \item Módulos de Odoo - \url{https://openerpspain.com/funcionalidades-de-odoo/}
    \item Módulos de Openbravo - \url{https://www.openbravo.com/es/soluciones}
\end{itemize}

\subsubsection{Seguridad: Planificación, Usuarios y Roles}
En primer lugar, para \textbf{aumentar la seguridad} de nuestro ERP, debemos analizar los tipos de riesgos a los que está sometido. Estos se pueden clasificar en \textbf{dos tipos}:

\begin{itemize}
    \item \textbf{Riesgos Físicos}: cuando ocurre un fallo en un componente electrónico de nuestro sistema. Pueden fallar principalmente por agresiones externas, como altas temperaturas, incendios, inundaciones,etc...
    \item \textbf{Riesgos Lógicos}: sucede cuando no hay una política adecuada en los sistemas informáticos y se producen accesos no autorizados, bugs, errores en el sistema operativo o en el software, intrusiones externas, etc...
\end{itemize}

Para mitigar estos riesgos, los sistemas ERP implementan una serie de \textbf{medidas de seguridad} que se basan en los siguientes aspectos:

\begin{itemize}
    \item \textbf{Niveles de acceso configurables para los usuarios según su rol}: en función de las tareas que deba realizar un usuario, éste debe contar con una serie de políticas que le permitan acceder a los datos que necesita, quedando otros datos reservados para usuarios con un nivel de toma de decisiones mas elevado.
    \item \textbf{Auditoría de cada transacción}: se controla cada envío de datos, lo que garantiza las operaciones realizadas.
    \item \textbf{Soporte para la conexión segura con https}: para garantizar la comunicación segura entre los clientes y el servidor se usa una conexión segura. Especialmente durante el proceso de autenticación de los usuarios.
\end{itemize}

Uno de los puntos más importantes es la \textbf{buena asignación de roles}, ya que esto permite que los usuarios solo puedan acceder a los datos que necesitan dejando, restringiendo su acceso a datos más sensibles solo disponibles a usuarios con mayores privilegios. Esta asignación se realiza mediante un \textbf{usuario administrador}.

Los paquetes básicos de ERP y módulos suelen tener varios \textbf{usuarios disponibles}:

\begin{itemize}
    \item \textbf{Administrador}: es el usuario con \textbf{mayores privilegios}, tanto en el acceso a datos como en la gestión del sistema (creación de usuarios, instalación de módulos,...)
    \item \textbf{Usuario Normal}: usuario que no tiene privilegios de gestión pero si tiene acceso a \textbf{toda la información} almacenada.
    \item \textbf{Usuario Grupo}: se crean para recibir correo entrante para distribución.
    \item \textbf{Usuario de Portal}: permite a los usuarios \textbf{acceder a los portales} creados en el entorno pero \textbf{no a la aplicación}.
\end{itemize}

Hay aplicaciones en las que los usuarios no pueden borrarse directamente, sino que hay que hacerlo desde la base de datos.

Además de los diferentes usuarios, es necesario conocer las características de los \textbf{roles} que hay definidos para los usuarios de una aplicación. Estos roles definen \textbf{ciertos privilegios} a la hora de realizar \textbf{tares específicas}.

Las \textbf{características} de los \textbf{roles} son las siguientes:

\begin{itemize}
    \item Un \textbf{rol} es un \textbf{grupo particular de privilegios}.
    \item El rol solo \textbf{tiene validez} si esta \textbf{asignado a un usuario}.
    \item Un \textbf{usuario} puede tener asignados \textbf{varios roles}, en este caso prevalece el más restrictivo.
    \item Los \textbf{cambios} realizados en los roles no son \textbf{efectivos} hasta que no se \textbf{inicia sesión} de nuevo.
    \item Si un rol \textbf{niega el acceso} a un módulo, se pierde la opción de ver cualquier subpanel perteneciente a éste.
\end{itemize}


\section{Enlaces de Interés}
En esta última sección solo vamos a incluir unos enlaces para completar y aclarar algunos de los conceptos que hemos visto en esta unidad, así como para expandir un poco el contenido.

\begin{itemize}
    \item Introducción a XML - \url{https://youtu.be/bCd2xaQrTAo}
    \item Mi primer documento XML - \url{https://youtu.be/LljEw3Std1Y}
    \item Documentos XML bien formados - \url{https://youtu.be/s1RgyhO9F2I}
    \item Introducción a XML Namespaces - \url{https://youtu.be/YGFcD3-WO6c}
    \item Resumen teórico y práctico . \url{https://youtu.be/YGFcD3-WO6c}
\end{itemize}

\chapter{Definición de Esquemas y Vocabulario XML}

En este tema vamos a estudiar como establecer y definir la estructura de un documento XML. Para ello, vamos a emplear dos herramientas como son \textbf{Document Type Definition} (\textbf{DTD}) y \textbf{XML SChema Definition} (\textbf{XSD}).

Tanto DTD como XSD nos permitirán definir restricciones tanto de tipos como de estructura para un documento XML. Cada uno tiene sus ventajas he inconvenientes, las cuales estudiaremos en los siguientes puntos. También veremos algunas herramientas que nos ayudarán tanto en la creación como en la validación de documentos XML, así como de los documentos escritos en DTD o XDS.

\section{Documento XML: Estructura y Sintaxis}
Hasta ahora solo hemos trabajado con documentos XML muy básicos, los cuales podemos considera incompletos ya que solo hemos declarado que tipo de documento vamos a definir, pero no que características tiene.

Si recordamos la estructura de un documento XML que vimos en el tema anterior, este se compone de las siguientes partes:

\begin{itemize}
    \item \textbf{Prólogo}: informa al intérprete encargado de procesar el documento de todos aquellos datos que necesita para realizar su trabajo. Este consta de:
    \begin{itemize}
        \item \textbf{Definición de XML}: aquí se indica la versión de XML que se utiliza, el código de los datos a procesar y la autonomía del documento. Este ultimo dato, hasta ahora, siempre ha tenido la opción ``\textit{yes}'', ya que los documentos que hemos definido hasta ahora han sido independientes.

        \item \textbf{Declaración del tipo de documento}: hasta ahora somo hemos dicho que esta parte se compone del nombre del ejemplar precedido de la declaración ``\textit{!DOCTYPE}'' y separado de esta al menos por un espacio y seguido de  ``\textit{>}''.
    \end{itemize}

    \item \textbf{Ejemplar}: contiene los datos del documento que se quiere procesar. Es el \textbf{elemento raíz} del documento y ha de \textbf{ser único}. Esta compuesto de elementos con una estructura de árbol en la que el elemento raíz es el ejemplar y la hojas los elementos terminales, es decir, aquellos que no contienen más elementos. Los elementos, a su vez, pueden estar compuestos por atributos.
\end{itemize}

Una vez que hemos recordado la estructura básica de un documento XML, vamos a profundizar y expandir las definiciones que tenemos sobre los elementos de esta estructura y a ampliar la opciones que nos proporcionan para personalizar un documento XML.

\subsection{Declaración de Tipo de Documento}
Ya habíamos visto que esto permite al autor definir \textbf{restricciones y características} del documento. Ahora, vamos a profundizar en las partes que lo forman.

\begin{itemize}
    \item \textbf{Declaración del tipo de documento}: comienza con el texto que indica el nombre del tipo, precedido por la cadena ``\textbf{!DOCTYPE}'' separado del nombre del tipo por al menos un espacio. El nombre del tipo debe ser idéntico al del ejemplar del documento XML en el que se ésta trabajando.

    \item \textbf{Definición del tipo de documento}: permite asociar al documento una definición de tipo \textbf{DTD}, la cual se encarga de definir las cualidades del tipo. Es decir, define los tipos de elementos, atributos y notaciones que se pueden usar en el documento, así como las restricciones del documento, valores por defecto, etc.

    Para formalizar todo esto, XML esta provisto de ciertas estructuras llamadas \textbf{declaraciones de marcado}, las cuales pueden ser internas o externas. En este último caso, deben declararse en un documento donde encontrar las declaraciones, además de indicar en la declaración de XML que el documento no es autónomo. Las diferencias entre este tipo de declaraciones de marcado dan lugar a dos subconjuntos, el \textbf{interno} y el \textbf{externo}. Durante el procesado de un documento XML, siempre se procesa primero el conjunto interno y después el externo, lo que permite sobrescribir declaraciones externas compartidas entre varios documentos y ajustar el DTD al documento específico.

    Las principales de características de los dos subconjuntos son las siguientes:

    \begin{itemize}
        \item \textbf{Subconjunto interno}: contiene las declaraciones que pertenecen a un \textbf{único documento} y no es posible compartirlas. Se localizan dentro de unos corches que siguen a la declaración del tipo de documento.

        \item \textbf{Subconjunto externo}: están localizadas en un documento con extensión \textbf{dtd} que puede situarse en el mismo directorio del documento XML. Habitualmente son declaraciones que pueden ser compartidas entre múltiples documentos XML que pertenecen al mismo tipo. En este caso, la declaración de documento autónomo ha de ser negativa, ya que es necesario el fichero con el subconjunto externo para su correcta interpretación. Esto implica que el procesado del documento se hará más lento, ya que antes de procesarlo el procesador debe obtener todas las entidades.

        Para declarar el documento externo, deberá realizarse una declaración explicita de subconjunto externo que podrá realizarse de las siguientes dos formas:

        \begin{itemize}
            \item \textbf{<!DOCTYPE nombre\_ejemplar ``URI''>}

            Se especifica una URI donde podrán localizarse las declaraciones.

            \item \textbf{<!DOCTYPE nombre\_ejemplar PUBLIC ``id\_publico'' ``URI''>}

            En este caso, también se especifica un identificador, que puede ser utilizado por el procesador para generar una URI alternativo, posiblemente basado en alguna tabla. Como se puede observar, también es necesario incluir una URI.
        \end{itemize}
    \end{itemize}
\end{itemize}

Ya que hemos visto como declarar el tipo de documento, en el siguiente punto veremos con se declara la sintaxis de un documento XML.

\subsection{Definición de Sintaxis de XML}
En los documentos de lenguajes de marcas, la distribución de los elementos esta jerarquizada según un estructura de árbol, lo que implica que es posible anidarlos pero no entrelazarlos. En este caso, el orden es significativo, pero no es así para los atributos, cuyo orden no importa, aunque si cabe recordar que no puede haber dos atributos con el mismo nombre.

Sabemos que los atributos no pueden tener nodos que dependan de ellos, por lo tanto solo pueden corresponder con las hojas de la estructura de árbol que jerarquiza los datos. Pero no solo los atributos pueden ser hojas de esta estructura, sino que los elementos pueden serlo también.

Por lo tanto, ¿que criterios podemos utilizar para decidir si un dato debe ser representado como un elemento o un atributo? Bueno, aunque no siempre se respetan, podemos tener en cuenta los siguientes criterios:

\begin{itemize}
    \item El \textbf{dato} será \textbf{un elemento} si cumple algunas de las siguientes condiciones:
    \begin{itemize}
        \item Contiene otras subestructuras.
        \item Es de tamaño considerable.
        \item Su valor cambia frecuentemente.
        \item Su valor va a ser mostrado a un usuario o aplicación.
    \end{itemize}

    \item  Un \textbf{dato} sera un \textbf{atributo}. si cumple:
    \begin{itemize}
        \item El dato es de pequeño tamaño y su valor raramente cambia, aunque hay situaciones en las que este caso se puede representar como un elemento también.
        \item El dato solo puede tener unos cuantos valores fijos.
        \item El dato guía el procesamiento de XML pero no se muestra.
    \end{itemize}
\end{itemize}

A la hora de decidir si un dato debe ser representado como atributo o elemento, por tanto, podemos comprobar si cumple unas u otras características, aunque como hemos comentado, esto no debe ser tomado como una ``guía absoluta'', ya que puede haber datos que aunque cumplan características de un atributo, pueden, o deben, ser representados como un elemento, y viceversa.

\subsubsection{XML Namespace}
Como sabemos, no puede haber atributos dentro de un mismo elemento con el mismo nombre, así como no podemos nombrar dos elementos diferentes con el mismo nombre. Para eso, XML nos proporciona los \textbf{namespaces} o \textbf{espacios de nombres}.

Un \textbf{espacio de nombre} se usan para proveer de nombres únicos a los elementos y atributos de XML, siendo su uso una recomendación de la W3C. \cite{namespace} En esencia, son una URI que referencia a una definición de vocabulario y nos permite:

\begin{itemize}
    \item Diferenciar entre los atributos y elementos de diferentes vocabularios y con diferente significado que comparten nombre.
    \item Agrupar todos los elementos y atributos de una aplicación XML para que el software pueda reconocerlos con facilidad.
\end{itemize}


Los espacios de nombres se pueden declaran usando el atributo \textbf{xmlns}, y se pueden definir de la siguiente forma.

\begin{itemize}
    \item \textbf{xmlns:``URI\_namespace''}

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


    <nombre xmlns="https://educacionadistancia.es/EspacioNombres">Ejemplo</nombre>
            \end{verbatim}
        \end{tcolorbox}

    \end{figure}

    \item \textbf{xmlns:prefijo=``URI\_namespace''}
    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


<EN:nombre xmlns:EN="https://educacionadistancia.es/EspacioNombres">Ejemplo</EN:nombre>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

En el segundo ejemplo se usa un prefijo, que nos informa de cuál es el vocabulario a la que esta asociada la definición. En ambos casos, \textbf{URI\_namespace} hace referencia al conjunto de vocabulario del espacio de nombres.

\section{Definiciones de Tipo de Documento (DTD)}
Una \textbf{definición de tipo de documento} o \textbf{DTD}, es una descripción de estructura y sintaxis de un documento XML o SGML. Su función básica es la definición de una estructura de datos, para usar un diseño común y mantener la consistencia entre los diferentes documentos que usen el mismo DTD. De esta forma, los documentos pueden ser validados, conociendo la estructura de los elementos y la descripción que trae consigo cada documento.

Así, dos o mas documentos que tengan el mismo DTD se construyen de forma similar, tienen el mismo tipo de etiquetas, en el lugar y orden que especifica el DTD.

En el tema anterior se explicó cuando un documento XML estaba bien formado o era correcto, pero un documento bien formado no es necesariamente un documento válido. Para que un documento XML sea válido tiene primero que estar bien formado, y después seguir las especificaciones dictadas por la DTD.

Las DTD \textbf{están formadas} por una \textbf{relación precisa} de \textbf{que elementos} pueden aparecer o no en el documento y \textbf{donde}, así como \textbf{el contenido} y los \textbf{atributos} de los mismos. Garantiza que los datos de un documento XML cumplen las restricciones que se le ha impuesto en el DTD, ya que éstas permiten:

\begin{itemize}
    \item \textbf{Especificar} la \textbf{estructura} del documento.
    \item Reflejar una \textbf{restricción de integridad referencial} mínima utilizando ID e IDREF.
    \item Utilizar unos pequeños mecanismos de abstracción comparables a las macro, las \textbf{entidades}.
    \item Incluir \textbf{documentos externos}.
\end{itemize}

Aunque como vemos, DTD tiene muchas ventajas, también tiene sus \textbf{inconvenientes}, siendo los principales los siguientes:

\begin{itemize}
    \item Su sintaxis \textbf{no es XML}.
    \item \textbf{No} soporta \textbf{espacio de nombres}.
    \item \textbf{No define tipos} para los datos, solo hay un tipo de elementos terminales, que son los datos textuales.
    \item\textbf{ No permite} las \textbf{secuencias no ordenadas}.
    \item \textbf{No} es posible \textbf{formar claves} a partir de \textbf{varios atributos o elementos}.
    \item Una vez que se define un DTD, \textbf{no} es posible \textbf{añadir más vocabularios}.
\end{itemize}

A continuación se muestra un ejemplo de un documento XML que queremos validar, y cual sería el resultado de aplicar un DTD que lo valide.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
 <?xml version="1.0"?>
 <pelicula>
 <titulo>Titanic</titulo>
 </pelicula>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML que queremos validar}
\end{figure}

Con ``\textbf{!DOCTYPE pelicula /[}'' comienza la DTD y finaliza con ``\textbf{]>}''. El nombre que aparece a continuación debe ser la raíz del documento, es decir, \textbf{pelicula}, que a su vez indica que la etiqueta \textbf{titulo} esta dentro de la etiqueta \textbf{pelicula}. En la siguiente figura vemos el DTD que deberemos crear para validar este documento.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE pelicula [
<!ELEMENT pelicula (titulo)>
<!ELEMENT titulo (#PCDATA)>
]>

<pelicula>
<titulo>Titanic</titulo>
</pelicula>
        \end{verbatim}
    \end{tcolorbox}
    \caption{DTD para validar el documento}
\end{figure}

\subsection{Declaración de la DTD}
Existen dos formas de definir la DTD que describirá la estructura de un documento XML. Se puede incluir dentro del mismo documento o incluirlo en un documento externo e indicar su ubicación.

\begin{itemize}
    \item \textbf{DTD incrustada}: es posible incluir la DTD en el mismo documento, como hemos visto en el punto anterior. En la siguiente figura podemos ver un ejemplo.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pelicula [
<!ELEMENT pelicula (titulo)>
<!ELEMENT titulo (#PCDATA)>
]>
<pelicula>
<titulo>Titanic</titulo>
</pelicula>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Declaración DTD incrustada}
    \end{figure}

    Cuando se declara de esta forma, se puede proporcionar una ayuda al analizador de XML, si a través de instrucciones de proceso presentes en el código, se indica que el documento es independiente y que todo lo que necesita está contenido en el mismo. Para ello, basta con añadir el atributo \textbf{standalone=``yes''}, como puede verse a continuación:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    El valor por defecto del atributo standalone es ``yes'', por lo que no sería estrictamente necesario incluirlo en este caso.

    \item \textbf{DTD externa}: otra opción es separar la declaración DTD del documento XML, realizando ésta en un documento externo e indicando donde se puede encontrar este documento. En el siguiente ejemplo, cargamos un fichero externo, \textit{cine.dtd} con la declaración DTD.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<?xml version="1.0" encoding="UTF-8" standalone="no"?> <!-- Enlace a la DTD -->
<!DOCTYPE pelicula SYSTEM "cine.dtd">
<pelicula>
<titulo>Titanic</titulo>
</pelicula>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Documento SGML simple}
    \end{figure}
\end{itemize}

Aunque las dos formas de declarar un documento DTD son igual de válidas, cabe apuntar que realizar un \textbf{declaración externa} tiene ciertas \textbf{ventajas} respecto a hacerla incrustada. Algunas de estas ventajas son estas:

\begin{itemize}
    \item Si la DTD que se va a incluir es compartida por muchos documentos XML, es preferible que se encuentre en un archivo independiente, ya que si hay que hacer algún cambio en el DTD, solo tendrá que hacerse en el archivo donde este declarado, y no en cada archivo XML.

    \item La DTD puede ubicarse en un servidor web, de forma que cualquier persona con acceso a internet puede validar el documento XML que está creando, lo que garantiza que todos los documentos creados usen la última versión de la DTD. Para declarar que la DTD se encuentra en una servidor web, se puede especificar de la siguiente forma:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <!DOCTYPE cine SYSTEM "http://cine.com/filmoteca.dtd">
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    Aunque sería más correcto si el archivo se pusiera de forma pública. Como se muestra en el siguiente código.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


<!DOCTYPE cine PUBLIC "filmoteca" "http://cine.com/filmoteca.dtd">
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    Siendo \textbf{``filmoteca''} el nombre de la DTD.
\end{itemize}

\subsection{Tipos de Elementos Terminales}

Los \textbf{tipos de elementos terminales} son aquellos elementos que dentro de la estructura de árbol de un documento XML serían representados por la hojas.

La declaración de tipos de elementos esta formada por la cadena ``\textbf{<!ELEMENT}'', separada por un espacio del nombre del elementos XML que se declara y seguido de la declaración de contenido de dicho elemento. En el caso de los elementos terminales, es decir, aquellos que no tienen más elementos anidados, esta declaración de contenido puede tomar los siguientes valores:

\begin{itemize}
    \item \textbf{EMPTY}: indica que el elemento no es un contenedor, es decir, que el elemento está vacío y no puede tener contenido. Para definir un elemento de este tipo se usa la siguiente definición:

        \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


      <!ELEMENT ejemplo EMPTY>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \begin{itemize}
        \item XML asociado \textbf{correcto}:

     \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
           \scriptsize
           \begin{verbatim}


       <ejemplo></ejemplo> ó <ejemplo />
           \end{verbatim}
       \end{tcolorbox}
    \end{figure}

    \item XML asociado \textbf{incorrecto}:

     \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


       <ejemplo>Esto es un ejemplo</ejemplo> ó <ejemplo><a></a></ejemplo>
            \end{verbatim}
        \end{tcolorbox}
     \end{figure}
    \end{itemize}

    \item \textbf{(\#PCDATA)}: indica que los datos son analizados en busca de etiquetas, resultando que el elemento no puede contener otros elementos, es decir, solo puede contener datos de tipo carácter, exceptuando \textbf{<}, \textbf{[}, \textbf{\&}, \textbf{]}, \textbf{>}. El elemento también podrá estar vacío. Un elemento de este tipo tendrá un definición así:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


       <!ELEMENT ejemplo (#PCDATA)>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \begin{itemize}
        \item XML asociado \textbf{correcto}:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


       <ejemplo>Esto es un ejemplo</ejemplo> ó <ejemplo />
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}

        \item XML asociado \textbf{incorrecto}:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


        <ejemplo><a></a></ejemplo>
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}
    \end{itemize}

    \item \textbf{ANY}: permite que el contenido de un elemento sea cualquier cosa, ya sea vacío, texto u otro elemento. \textbf{No} es \textbf{recomendable} es uso de este tipo de elemento. Para definir un elemento como ANY se usa la siguiente sentencia:

     \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


        <!ELEMENT ejemplo ANY>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    El problema con este tipo de dato es que no pone prácticamente restricciones al elemento, pudiendo este adoptar diferentes formas lo que hace que esta declaración de tipos sea muy poco específica. Por ejemplo, si tenemos en cuenta la siguiente declaración DTD:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
       <?xml version="1.0" encoding="UTF-8"?>
       <!DOCTYPE mascota[
         <!ELEMENT mascota ANY>
         <!ELEMENT nombre (#PCDATA)>
         <!ELEMENT tipo(#PCDATA)>
          <!ELEMENT raza(#PCDATA)>
       ]>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    Todos los elementos que vemos a continuación, serían válidos:


        \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
        <mascota>
        <nombre>Coco</nombre> es mi mascota.
        Es una <tipo>chinchilla</tipo> <raza>blanca</raza>.
        </mascota>



        <mascota>
        Coco es mi mascota.
        Es una <tipo>chinchilla</tipo> <raza>blanca</raza>.
        </mascota>


         <mascota>
        <nombre>Coco</nombre>.
        </mascota>

        <mascota/>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    Por lo tanto, aunque su uso es correcto y hay determinadas situaciones en las que se debe usar, no se recomienda de forma general declarar elementos de este tipo.
\end{itemize}

\subsection{Elementos No Terminales}
Una vez que hemos visto como declarar los elementos terminales, es decir, la hojas del árbol de la estructura, ahora vamos a ver como declarar los elementos \textbf{no terminales}, es decir, \textbf{elementos formados} por \textbf{otros elementos}, lo que serían las \textbf{ramas} del árbol de la estructura de un documento XML.

Para definir estos elementos, debemos hacer referencia a las elementos que las componen, como vemos en este ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


      <!ELEMENT A(B C)>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

En este caso, se ha definido \textbf{un elemento A}, que esta \textbf{formado} por un \textbf{elemento B} seguido de un \textbf{elemento C}. Cuando un elemento aparece varias veces en un documento, también deberemos indicarlo. Para ello, se usan los siguientes operadores, que nos permiten definir la \textbf{cardinalidad} de un elemento:

\begin{itemize}
    \item \textbf{Operador opción} (\textbf{?}): este operador indica que un elemento es opcional, por lo que podrá o no aparecer en la estructura del elemento:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


      <!ELEMENT telefono (trabajo? casa)>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Operador uno-o-más} (\textbf{+}): define un componente que aparece al menos una vez. En el siguiente ejemplo se define un elemento formado por el nombre de una provincia y otro grupo, que puede aparecer una o varias veces:

      \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


      <!ELEMENT provincia (nombre, (cp, ciudad)+ )>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Operador cero-o-más} (\textbf{*}): este operador permite definir un elemento que aparece cero, una o más veces. Siguiendo con el ejemplo anterior, en este caso el grupo (cp, ciudad) podría no aparecer, o hacerlo varias veces:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


       <!ELEMENT provincia (nombre, (cp, ciudad)* )>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Operador de elección} (\textbf{|}): cuando se utiliza para sustituir las comas en la declaración de grupos indica que para formar el documento XML hay que elegir entre los elementos separados por este operador. En el siguiente ejemplo, el elemento \textit{provincia} estará formado por el elemento \textit{nombre} y el elemento \textit{cp} ó el elemento \textit{ciudad}.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


      <!ELEMENT provincia (nombre, (cp | ciudad) )>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

Ya hemos visto como se realizan las declaraciones tanto de elementos terminales como no terminales, el siguiente paso será ver como se declaran los atributos que tienen estos elementos.

\subsection{Atributos de los Elementos}
En esta sección vamos a ver como se declaran los atributos que lleva un elemento, independientemente de si es terminal o no terminal. Para ellos, se usa la cadena \textbf{<!ATTLIST} seguida del nombre del elemento asociado al atributo que se declara, luego el nombre del atributo seguido de su tipo y modificador.

    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


<! ATTLIST nombre_elemento nombre_atributo tipo_del_atributo "Valor_por_defecto">
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Este elemento puede usarse para declarar una lista de atributos asociados a un elemento, o repetirse el número de veces necesario para asociar a dicho elemento esa lista de atributos, pero individualmente. Si un elemento tiene más de una atributo se puede expresar de la siguiente forma:

    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}

 <! ATTLIST nombre_elemento nombre_atributo1  tipo_del_atributo1  "Valor_por_defecto"
                            nombre_atributo2  tipo_del_atributo2  "Valor_por_defecto"
                            nombre_atributo3  tipo_del_atributo3  "Valor_por_defecto"
            ........................................................................>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Al igual que los elementos, no todos los atributos son del mismo tipo. Los tipos más destacados con los que podemos definir un atributo son los siguientes:

\begin{itemize}
    \item \textbf{Enumeración}:  con el tipo, el atributo solo podrá tomar uno de los valores especificados dentro del paréntesis, los cuales irán separados por el operador \textbf{|}. En el siguiente ejemplo, vemos que el atributo \textit{dia\_semana} solo puede tomar como valor unos de los siete días de la semana:

     \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


<!ATTLIST fecha dia_semana (lunes|martes|miércoles|jueves|viernes|sábado|domingo)>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{CDATA}: este tipo se usa para especificar que un atributo es una cadena de texto. En el siguiente ejemplo se define el atributo \textit{color} del elemento ejemplo como CDATA:

     \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<!ATTLIST ejemplo color CDATA #REQUIRED>

<ejemplo color="verde" />
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}


    \item \textbf{ID}: permite declarar que el valor del atributo debe ser único y no se puede repetir en otros elementos ni atributos. Hay que tener en cuenta que los números no son nombres válidos en XML, por tanto no son un identificado legal.  Para resolverlo, suele incluirse un prefijo en los valores y separarlo con un guión o letra, como en el siguiente ejemplo:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<!ATTLIST libro codigo ID #REQUIRED>

<libro codigo="Q1">El Quijote</libro>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{IDREF}: permite hacer referencia a un identificador. En esta caso, el valor del atributo ha de corresponder con el identificador de algún elemento del documento XML.

    \item \textbf{NMTOKEN}: permite definir que el valor de un atributo ha de ser solo una palabra compuesta por los caracteres permitidos en XML, es decir, letras, números y los caracteres: ``\textbf{:}'', ``\textbf{\_}'', ``\textbf{-}'' y ``\textbf{.}''.
\end{itemize}

Además de estos tipos, debemos declarar si el valor de un \textbf{atributo} es \textbf{obligatorio} o no. También podemos indicar cual será el valor por defecto de un atributo. Para todo ésto, se pueden emplear las siguiente cadenas:

\begin{itemize}
    \item \textbf{\#IMPLIED}: indica que el atributo sobre el que se aplica es opcional.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
 <!ATTLIST ejemplo color CDATA #IMPLIED>

 <ejemplo color="verde" /> ó <ejemplo color="" />
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{\#REQUIRED}: indica que el atributo sobre el que se aplica es obligatorio.

      \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <!ATTLIST ejemplo color CDATA #REQUIRED>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \begin{itemize}
        \item XML no válido:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


         <ejemplo color="" />
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}

        \item XML válido:

                \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


         <ejemplo color="verde" />
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}
    \end{itemize}

    \item \textbf{\#FIXED}: permite definir un valor fijo para un atributo independientemente de que ese atributo se defina explícitamente en una instancia del elemento del documento XML.

          \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


  <!ATTLIST ejemplo color CDATA #FIXED "verde">
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \begin{itemize}
        \item XML no válido:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


            <ejemplo color="rojo" />
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}

        \item XML válido:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}


           <ejemplo color="verde" />
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}
    \end{itemize}

    \item \textbf{Literal}: asigna por defecto a un atributo el valor indicado entre comillas, aunque este atributo también podrá tomar otros valores.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
 <!ATTLIST ejemplo color (rojo|verde|amarillo) "verde">

 <ejemplo color="verde" />
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

Ya conocemos como se declaran los elementos y atributos en un DTD. En la siguiente sección veremos que también podemos declarar entidades, que nos ayudarán a la hora de crear este tipo de documentos.

\subsection{Entidades}
Las entidades nos permite \textbf{declarar valores constantes} dentro de un documento XML. Cuando se emplean dentro de un documento XML se limitan por ``\textbf{`\&}'' y ``\textbf{;}''. Por ejemplo: \textbf{\&entidad}. El intérprete, al procesar el documento XML, sustituirá todas las apariciones de la entidad por el valor que se le haya asignado en el DTD. La entidades \textbf{no admiten recursividad}, es decir, una entidad no puede hacer referencia a sí misma.

Las entidades puede ser de dos tipos, \textbf{generales} y de \textbf{parámetro}.

\begin{itemize}
    \item \textbf{Entidades Generales}: dentro de la entidades generales podemos encontrar las \textbf{internas} y las \textbf{externas}:
    \begin{itemize}
        \item \textbf{Internas}: son las que se declaran  en el DTD y existen algunas predefinidas que podemos ver en la siguiente tabla.

            \begin{figure}[ht]

            \vspace{3ex}
            \centering

            \setlength{\tabcolsep}{10pt}
            \renewcommand{\arraystretch}{1.4}

            \begin{tabular}{| c | c |}
                \hline
                \textbf{Entidad}  & \textbf{Carácter} \\ \hline
                \textbf{\&lt;} &  < \\ \hline
                \textbf{\&gt;} &  > \\ \hline
                \textbf{\&guot;} &  " \\ \hline
                \textbf{\&apos;} &  ' \\ \hline
                \textbf{\&amp;} &  \& \\
                \hline
            \end{tabular}
            \caption{Entidades predefinidas en XML}
        \end{figure}

        Además de las entidades predefinidas, podemos definir las nuestras propias. Para ello emplearemos  la estructura ``\textbf{<!ENTITY nombre\_entidad ``valor entidad''>}, donde:
        \begin{itemize}
            \item \textbf{nombre\_entidad} es el nombre que recibe la entidad.
            \item \textbf{``valor\_entidad''} es el valor que toma dicha entidad.
        \end{itemize}

        Para hacer referencias a las entidades creadas usaremos \textbf{\&nombre\_entidad}.

        En la siguiente figura se puede ver un ejemplo de la definición de entidades internas propias. En este caso se declaran las entidades \textbf{autor} y \textbf{editorial}, que posteriormente se usan en el texto dentro de los elementos del documento.

        En la figura 2.2.7 podemos ver el resultado, y como el intérprete a sustituido cada ocurrencia de las entidades por sus valores en el momento de generar el documento.

       \begin{figure}[H]
           \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
               \scriptsize
               \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE libros [
<!ELEMENT libros (libro)+>
<!ELEMENT libro (#PCDATA)>

<!ENTITY autor "Miguel de Cervantes">
<!ENTITY editorial "Alfaguara">
]>


<libros>
<libro>Don Quijote de la Mancha fue escrito por &autor;</libro>
<libro>SIDI fue escrito por Arturo Pérez-Reverte y publicado por &editorial;</libro>
<libro>Tiempos recios fue escrito por Mario Vargas y publicado por &editorial;</libro>
</libros>
               \end{verbatim}
           \end{tcolorbox}
           \caption{Declaración de entidades internas en DTD}
       \end{figure}

            \begin{figure}[ht]
            \centering
            \includegraphics[scale=0.65]{dtd_entidades_internas.jpg}
            \caption{Documento generado con entidades internas sustituidas}
        \end{figure}

     \item \textbf{Externas}: permiten establece una relación entre el documento XML y otro documento a través de la URL de este último.

     \begin{figure}[h]
         \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
             \scriptsize
             \begin{verbatim}


 <!ENTITY nombre_entidad SYSTEM "http://localhost/docsxml/fichero_entidad.xml">
             \end{verbatim}
         \end{tcolorbox}
     \end{figure}

     En este caso el contenido de los ficheros es analizado por lo que deben seguir la sintaxis XML. Cuando es necesario incluir ficheros binarios, se utiliza la palabra reservada \textbf{NDATA} en la definición de la entidad, para que el fichero no sea analizado, y habrá que asociar a dicha entidad una declaración de notación , tal y como veremos en la siguiente sección.

     En el caso de que la entidad externa vaya a ser utilizada por varias aplicaciones, deberemos declararla de la siguiente forma:

         \begin{figure}[H]
         \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
             \scriptsize
             \begin{verbatim}


<!ENTITY nombre_entidad PUBLIC "identificador público formal" "camino hasta la DTD (uri)">
             \end{verbatim}
         \end{tcolorbox}
     \end{figure}
     \end{itemize}

    \item \textbf{Entidades de Parámetro}: al igual que la generales, éstas pueden ser \textbf{internas} y \textbf{externas}.

    \begin{itemize}
        \item \textbf{Internas}: permiten dar nombre a partes de un DTD y hacer referencias a ellas a lo largo del mismo. Son especialmente útiles cuando varios elementos del DTD comparte listas de atributos o especificaciones de contenido. Se denotan por \textbf{\%entidad}. Aquí mostramos un ejemplo de su uso.

        \begin{figure}[h]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
<!ENTITY % direccion "calle, numero?, ciudad, cp">

<!ELEMENT almacen (%direccion;, web)>
<!ELEMENT oficina (%direccion;, movil)>
<!ELEMENT central (%direccion;, telefono)>
<!ELEMENT tienda (%direccion;, fax)>
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}

    \item \textbf{Externas}: permite incluir en un DTD elementos externos, lo que se aplica al dividir la definición DTD en varios documentos.

            \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <!ENTITY %persona SYSTEM "persona.dtd">
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
    \end{itemize}
\end{itemize}

Como vemos, las entidades son bastante útiles a la hora de crear documentos DTD, y nos ayudan a establecer valores fijos para ciertos parámetro ó incluso a no tener que repetir código.

\subsection{Declaración de Notación}
En esta sección vamos a ver un tipo de declaración muy concreto que se aplica cuando queremos incluir un \textbf{fichero binario}. En este caso, deberemos indicar al intérprete que aplicación es la que se tiene que hacer cargo de procesar dicho fichero.

Para especificar la aplicación que deberá hacerse caso de ese fichero, usamos la siguiente \textbf{notación}:

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


 <!NOTATION nombre SYSTEM aplicacion>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Por ejemplo, en el caso de que quisiéramos incluir un archivo de tipo \textbf{gif}, donde indicáramos un editor que se encargar de visualizar este tipo de imagen, lo haríamos de la siguiente forma:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


 <!NOTATION gif SYSTEM "gifEditor.exe">
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

En el caso de que quisiéramos asociar una entidad externa no analiza, bastaría con declarar dicha asociación de la siguiente manera:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


 <!ENTITY dibujo SYSTEM "imagen.gif" NDATA gif>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Ya hemos visto todo lo relacionado con las declaraciones en DTD, por último, en el siguiente tema veremos las secciones condicionales y habremos concluido la parte dedicada a DTD.

\subsection{Secciones Condicionales}
Las \textbf{secciones condicionales} nos permiten incluir o ignorar partes de la declaración de un DTD. Para ellos se usan los dos siguientes tokens:

\begin{itemize}
    \item \textbf{INCLUDE}: permite que esta parte de la declaración sea visible. Su sintaxis es:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


  <![INCLUDE [Declaraciones visibles] ] >
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{IGNORE}: permite ocultar esa sección de declaraciones dentro de DTD. Su sintaxis es:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


  <![IGNORE [Declaraciones visibles] ] >
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

El uso de la secciones condicionales suele \textbf{estar ligado} al uso de \textbf{entidades paramétricas}.

\section{XML Schema}
Los \textbf{DTD} nos permiten definir el \textbf{vocabulario} de un fichero XML, pero estos no permiten definir los \textbf{tipos} de datos que vamos a emplear en cada en elemento. Para ello tenemos \textbf{XML Schema}. Estos, a diferencia de DTD que usa una sintaxis similar a SGML, son documentos \textbf{XML} y también se especifican en ficheros de \textbf{texto plano} que se denominan \textbf{XSD} (XML Schema Definition).

Los elementos XML que se utilizan para generar un esquema han de pertenecer al espacio de nombres de XML Schema, que es: \url{https://www.w3.org/2001/XMLSchema}. En esta especificación se usa el prefijo \textbf{<xsd:schema>}, aunque para abreviar se suele utilizar \textbf{<xs:schema>}.

Las estructuras que se definen en XML Schema definen a su vez numeroso atributos para uso directo en cualquier documento. Estos se encuentra en un espacio de nombres diferente, en concreto en XML Schema Instance, que está definido en \url{https://www.w3.org/2001/XMLSchema-instance}. En esta especificación se usa el prefijo \textbf{<xsi:schema>}, aunque como en el anterior, para abreviar, se suele emplear \textbf{<xs:schema>}.

De esta manera, los prefijos \textbf{<xsd:schema>}, \textbf{<xsi:schema>} y \textbf{<xs:schema} se pueden usar indistintamente para definir el esquema, teniendo en cuenta que si se usa uno de los tres, deberemos usar este en todo el documento.

El ejemplar de estos ficheros es \textbf{<xs:schema}, que contiene declaraciones para todos los elementos y atributos que pueden aparecer en un documento XML asociado válido. Los elementos hijos de este ejemplar se denominan \textbf{<xs:element>}, y nos permiten crear un globalmente un elemento. Esto significa que el elemento creado puede ser el ejemplar del documento XML asociado.

El elemento \textbf{<xs:schema>} puede tener algunos atributos. Un ejemplo de declaración de este elemento sería el siguiente:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8">

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="https://www.w3schools.com"
           xmlns="https://www.w3schools.com"
           elementFormDefault="qualified">
...

...

</xs:schema>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Declaración del ejemplar xs:schema}
\end{figure}

En esta declaración podemos ver varios elementos los cuales vamos e explicar a continuación.

\begin{itemize}
    \item \textbf{xmlns:xs=``http://www.w3.org/2001/XMLSchema''}

    Esta declaración indica que los elementos y tipos de datos usados en el esquema vienen del espacio de nombres ``http://www.w3.org/2001/XMLSchema''. También indica que los elementos y los tipos de datos que vengan de ese espacio de nombres tienen que tener el prefijo \textbf{xs:}. Este fragmento es el único \textbf{obligatorio} para que la definición sea correcta.

    \item \textbf{targetNamespace=``https://www.w3schools.com''}

    Indica que los elementos definidos en el esquema pertenecen al espacio de nombres, es decir, el espacio de nombres de destino. En este caso es ``https://www.w3schools.com''.

    \item \textbf{xmlns=``https://www.w3schools.com''}

    Indica cual es el espacio de nombres por defecto, en este caso ``https://www.w3schools.com''.

    \item \textbf{elementFormDefault=``qualified''}

    Indica que cualquier elemento usado en una instancia XML que haya sido declarada con este esquema debe ser identificado con el espacio de nombres. Por defecto, toma este valor.
\end{itemize}

Aunque hay mas atributos que puede contener el elemento \textbf{xs:schema}, estos son algunos de los principales.

\subsection{Tipos de Elementos en XML Schema}
Los \textbf{elementos} se usan para especificar las etiquetas válidas de un documento XML. Todos los elementos que se vayan a utilizar en el ejemplar XML deben estar declarados en el esquema. Su etiqueta es \textbf{<xs:element} y su declaración de elementos en XML Schema tiene una estructura diferente dependiendo de si son \textbf{simples} o \textbf{complejos}. A saber:

\begin{itemize}
    \item \textbf{Tipo simple}: no pueden contener otros elementos o atributos. Su estructura es la siguiente:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xsd:element name="nombreElemento"
             ref="elementoReferenciado"
             type="tipoDato"
             minOccurs="valor"
             maxOccurs="valor"
             fixed=”valor"
             default=”valor”/>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    Donde:

    \begin{itemize}
        \item \textbf{name}: es el nombre del elemento.
        \item \textbf{ref}: el elemento al que hace referencia esta declarado en otro lugar. No puede aparecer junto con \textbf{name}, ni si el elemento padre es \textbf{<xs:squema>}.
        \item \textbf{type}: el tipo de dato del elemento. No puede aparecer si usamos \textbf{ref}.
        \item \textbf{minOcurrs/maxOccurs} (opcionales): estos atributos indican el mínimo y máximo numero de ocurrencias del elemento respectivamente. El \textbf{valor por defecto} en ambos casos en \textbf{1}.

        Para especificar que el elemento puede aparecer un \textbf{número indeterminado} de veces el atributo \textbf{maxOccurs} toma el valor \textbf{``unbounded''}. Para especificar que el elemento \textbf{no puede aparecer}, el atributo \textbf{minOccurs} toma el valor \textbf{0}.

        Ninguno de los atributos puede aparecer si el padre del elemento es \textbf{<xs:schema>}.

        \item \textbf{fixed} (opcional): especifica un valor fijo para el elemento.
        \item \textbf{default} (opcional): especifica un valor por defecto para el elemento.
    \end{itemize}


    Podemos \textbf{crear nuevos elementos} ``simpleType'' a partir de uno ya existente, añadiendo condiciones a alguno de los tipos ya predefinidos en XML Schema. Para ello se utiliza el elemento \textbf{<xs:restriction}, como podemos ver en este ejemplo:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xsd:simpleType name="precio">
    <xsd:restriction base="xsd:decimal">
        <xsd:fractionDigits value="2"/>
    </xsd:restriction>
</xsd:simpleType>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Uso del elemento xs:restriction}
    \end{figure}

    \item \textbf{Tipo complejo}: estos elementos pueden estar compuestos por otros elementos y/o atributos. Sus elementos están definidos entre las etiquetas de inicio y final del elemento.

    \begin{itemize}
        \item \textbf{<xs:schema>}: es el ejemplo básico de elemento compuesto y contiene la definición del esquema.

        \item \textbf{<xs:complexType}: este elemento se usa para definir los elementos de tipo complejo entre su etiqueta de inicio y cierre. Pueden estar formados por subelementos predefinidos en XML Schema como:

        \begin{itemize}
            \item \textbf{Secuencias} (\textbf{<xs:sequence}): permite construir elementos complejos mediante la enumeración de los elementos que lo forma en orden correcto.  Si se altera dicho orden en el documento XML, éste no será valido.

            \item \textbf{Alternativa} (\textbf{xs:choice}): representan alternativas, teniendo en cuenta que es la elección es exclusiva, es decir, especifica un lista concreta de elementos de los que solo puede aparecer uno.

            \item \textbf{Secuencias no ordenadas} (\textbf{xs:all}): representa todos los elementos que conforman el elemento compuesto sin un orden específico. Dichos elementos podrán aparecer en cualquier orden dentro del documento XML.

            \item \textbf{Contenido mixto}: se define estableciendo en atributo \textbf{mixed} de un elemento a t\textbf{true}, es decir, \textbf{<xs:complexType mixed="true">}, y permite mezclar texto con elementos hijo. Los hijos se definen con las opciones anteriores, xs:sequence, xs:choice o xs:all.

            \item \textbf{Elemento vacío}: el elemento no puede contener texto ni otros subelementos, solo atributos. En el siguiente ejemplo vemos la definición de un elemento vacío y un XML válido para esa definición.

             \begin{figure}[h]
                \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                    \scriptsize
                    \begin{verbatim}
           <xsd:element name="asignatura">
                <xsd:complexType>
                    <xsd:attribute name='codigo' type='xs:integer'/>
                </xsd:complexType>
           </xsd:element>

           <!-- XML válido -->

           <asignatura codigo='MAT-1920'/>
                    \end{verbatim}
                \end{tcolorbox}
            \end{figure}

        \item \textbf{Referencias}: tal y como sucede en otro lenguajes, en un documento xsd podemos definir elementos de forma global y luego hacer referencias a estos desde otros elementos. Es es muy útil si a lo largo del documento se repiten determinados elementos. A continuación vemos un ejemplo del uso de referencias.

        \begin{figure}[h]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
           <?xml version="1.0" encoding="UTF-8"?>

           <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
               <xsd:element name="Direccion">
                   <xsd:complexType>
                       <xsd:sequence>
                           <xsd:element ref="via"/>
                           <xsd:element ref="numero"/>
                           <xsd:element ref="poblacion"/>
                           <xsd:element ref="provincia"/>
                           <xsd:element ref="cp"/>
                       </xsd:sequence>
                        </xsd:complexType>
                 </xsd:element>

                <!-- Declaración de los elementos -->

                 <xsd:element name="via" type="xsd:string"/>
                 <xsd:element name="numero" type="xsd:integer"/>
                 <xsd:element name="poblacion" type="xsd:string"/>
                 <xsd:element name="provincia" type="xsd:string"/>
                 <xsd:element name="cp" type="xsd:string"/>
            </xsd:schema>
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}
        \end{itemize}
    \end{itemize}
\end{itemize}

En esta sección hemos visto como se declaran los elementos en un esquema XML Schema. Como vemos, aunque es más complejo que en DTD también nos aporta más potencia. En la siguiente sección veremos la declaración de atributos.

\subsection{Atributos en XML Schema}
El \textbf{elemento ``atributo''} permite definir los atributos de los elementos en el documento xsd para usarlos adecuadamente en el documento XML. Estos elementos solo pueden aparecer en los elementos de tipo compuesto y su declaración debe realizarse siempre al final de la definición del elemento del que es atributo, es decir, justo antes del cierre \textbf{</xs:compleType>}. A continuación vemos un ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<xsd:attribute name="nombreAtributo"
               ref="atributoReferenciado"
               type="tipoAtributo"
               use="valor"
               fixed=”valor"
               default=”valor”/>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Definición del elemento atributo en }
\end{figure}

Los diferentes atributos de este elemento son los siguientes:

\begin{itemize}
    \item \textbf{name}: indica el nombre del atributo.
    \item \textbf{ref}: el atributo referenciado se encuentra definido en otra parte del esquema. No puede aparecer al mismo tiempo que \textbf{name}.
    \item \textbf{type}: indica el tipo del atributo. Tampoco puede aparecer al mismo tiempo que \textbf{ref}.
    \item \textbf{use} (opcional): indica si la aparición del atributo es opcional (\textbf{optional}), obligatoria (\textbf{required}) o prohibida (\textbf{prohibited}). Por \textbf{defecto}, toma el valor \textbf{``optional''}.
    \item \textbf{default} (opcional): valor que tomará el atributo por defecto al ser procesado si en el documento XML no se le asigna ningún valor. Solo se puede usar con tipos de datos \textbf{cadena de caracteres}. No puede aparecer si el atributo \textbf{fixed} esta presente.
    \item \textbf{fixed}: valor fijo que toma que el atributo. No puede aparecer si esta presente el atributo \textbf{default}.
\end{itemize}

Cabe mencionar que podemos usar el elemento \textbf{xs:attributeGroup} para agrupar atributos, lo que nos facilitará añadirlos después como un grupo a algún tipo de datos complejo.

\subsection{Tipos de Datos}
En esta sección vamos a ver los \textbf{tipos de datos}, que son los valores que puede tomar el atributo \textbf{type} cuando declaramos un atributo o un elemento y que determina el tipo de dato que tendrá el elemento o atributo asociado.

Los principales tipos de datos que tenemos en XML Schema son los siguientes:

\begin{itemize}
    \item \textbf{String} (\textit{xs:string}): se corresponde con una cadena de caracteres UNICODE. Puede incluir caracteres, saltos de línea y tabulaciones.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}

<xs:element name="poblacion" type="xs:string"/>

<poblacion>La Puebla de Vícar</poblacion>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Boolean} (\textit{xs:boolean}): representa valores lógicos, pudiendo tomar por tanto solo los valores \textbf{true} o \textbf{false}.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}

<xs:attibute name="cancelado" type="xs:boolean"/>

<vuelo cancelado="true">LK345</vuelo>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Integer} (\textit{xs:integer}): permite representar un número entero positivo o negativo.

     \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}

<xs:element name="precio" type="xs:integer"/>

<precio>94</precio>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Positive Integer} (\textit{xs:positiveInteger}): se usa para representar un entero positivo.
    \item \textbf{Negative Integer} (\textit{xs:negativeInteger}): se usa para representar una entero negativo.
    \item \textbf{Decimal} (\textit{xs:decimal}): para representar un subconjunto de los números reales que pueden ser representados por un número decimal, por ejemplo, 8,79.


    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}

<xs:element name="precio" type="xs:decimal"/>

<precio>8,97</precio>
<precio>8</precio>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{DateTime} (\textit{xs:dateTime}): se emplea para representar una fecha y horas absolutas. Tiene el formato ``\textbf{YYYY-MM-DDThh:mm:ss}'' y sólo es válido si se especifican todos sus componentes.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:element name="fecha" type="xs:dateTime"/>

<fecha>2020-05-20T08:20:00</fecha>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
    \item \textbf{Duration} (\textit{xs:duration}): representa una duración de tiempo expresada en meses, años, días, horas, minutos y segundos. El formato utilizado es ``\textbf{PnYnMnDTnHnMnS}''. Para indicar una duración negativa se pone el signo negativo (-) precediendo a la P.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:element name="periodo" type="xs:duration"/>

<!-- Duración de 2 años, 4 meses, 3 días, 5 horas, 6 minutos y 7 segundos -->
<periodo>P2Y4M3DT5H6M7S</periodo>

<!-- Se pueden omitir los valores nulos, luego una duración de 2 años será -->
<periodo>P2Y</periodo>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Time} (\textit{xs:time}):permite representar la hora con el formato ``\textbf{hh:mm:ss}''.
    \item \textbf{Date}: (\textit{xs:date}): permite representar una fecha con el formato ``\textbf{YYYY-MM-DD}''.
    \item \textbf{gYearMonth} (\textbf{xs:gYearMonth}): representa un mes de un año mediante el formato ``\textbf{YYYY-MM}.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:element name="fecha" type="xs:gYearMonth"/>

<fecha>2020-05</fecha>  Mayo de 2020
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{gYear} (\textit{xs:gYear}): permite representar un año  gregoriano usando el formato ``\textbf{YYYY}''.

    \item \textbf{gMonthDay} (\textit{xs:gMonthDay}): permite representar un día de un mes mediante el formato ``\textbf{--MM-DD}''.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:element name="fecha" type="xs:gMonthDay"/>

<!-- XML válido  -->
<fecha>--05-19</fecha> 19 de  Mayo

<!-- XML no válido -->
<fecha>05-19</fecha>

fecha>--05-32</fecha>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{gDay} (\textit{xs:gDay}): representa el \textbf{ordinal} de un día del mes mediante el formato ``\textbf{--DD}'', por ejemplo, el dia 4º del mes sería \textbf{--04}.
    \item \textbf{gMonth} (\textit{xs:gMonth}): representa el \textbf{ordinal} del mes mediante el formato ``\textbf{--MM}''. Como en el ejemplo anterior, el mes 4º sería \textbf{--MM}.
    \item \textbf{anyURI} (\textit{xs:anyURI}): representa una URI.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:element name="web" type="xs:anyURI"/>

<!-- XML válido  -->
<web>www.iesaguadulce.es</web>

<web>www.iesaguadulce.es#texto</web>

<!-- XML no válido -->
<web>www.iesaguadulce.es#texto#texto1</web>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Language} (\textit{xs:language}): representa los identificadores de un lenguaje, tal y como están definidos en el \href{https://www.rfc-editor.org/rfc/rfc1766}{RFC 1766}.

    \item \textbf{ID} (\textit{xs:ID}): permite declarar que el valor del atributo debe ser único y no puede repetirse en otros elementos. Al igual que con los DTD, el valor no puede empezar por un número, sino por un carácter.

    \item \textbf{IDREF} (\textit{xs:IDREF}): permite hacer referencia a un ID de otro elemento.

    \item \textbf{ENTITY} (\textit{xs:ENTITY}): permite representar una entidad, las cuales vimos en el apartado 2.2.5.

    \item \textbf{NOTATION} (\textit{xs:NOTATION}): permite representar una notación, tal y como vimos en el apartado 2.2.6.

    \item \textbf{NMTOKEN} (\textit{xs:NMTOKEN}): representa que el valor es una cadena compuesta solo por los valores permitidos en XML.
\end{itemize}

Además de estos tipos, hay otros tanto primitivos como derivados que acepta XML Schema, si queremos ampliar la información, podemos consultar podemos consultar la \href{https://www.w3.org/TR/xmlschema-2/}{Recomendación de la W3C} sobre los tipos de datos de XML Schema.

\subsection{Facetas de los Tipos de Datos}
Las \textbf{facetas} nos permiten aplicar restricciones sobre los tipos de datos. Estás solo pueden aplicarse sobre tipos de datos simples utilizando el elemento \textbf{xs:restriction}, que tiene el atributo \textbf{base} en el que se indica el tipo de datos sobre el que se quiere realizar la restricción.

Las facetas se expresan como un elemento dentro de una restricción y se pueden combinar para restringir más el valor del elemento. Entre otras, nos podemos encontrar las siguientes:

\begin{itemize}
    \item \textbf{enumeration}: restringe a un determinado número de valores.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="estado">
    <xs:restriction base="xs:string">
        <xs:enumeration value="conectado"/>
        <xs:enumeration value="ocupado"/>
    </xs:restriction>
<xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{length, minlength, maxlentgh}: restringen la longitud del tipo de datos

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="estado">
    <xs:restriction base="xs:string">
        <xs:maxLength value="9"/>
    </xs:restriction>
<xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{whitespace}: define el tratamiento de los espacios en blanco. Sus opciones pueden ser: \textbf{preserver, replace} o \textbf{collapse}.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="nombre">
    <xs:restriction base="xs:string">
        <xs:whitespace value="preserve"/>
    </xs:restriction>
<xs:simpleType
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item (\textbf{maxInclusive/maxExclusive})(\textbf{minInclusive/maxInclusive}): límites superiores e inferiores del tipo de dato. Cuando son \textbf{Inclusive} el valor que se determina es parte del conjunto de valores válidos para el dato, mientras que si son \textbf{Exclusive}, el valor no pertenece al conjunto de valores válidos.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}

<xs:element name="age">
    <xs:simpleType>
        <xs:restriction base="xs:integer">
            <xs:minInclusive value="0"/>
            <xs:maxInclusive value="120"/>
        </xs:restriction>
    </xs:simpleType>
</xs:element>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}


    \item \textbf{totalDigits}, \textbf{fractionDigits}: número de dígitos totales y decimales de un número decimal. Si lo combinamos con el minInclusive, maxInclusive, etc.., podemos aplicar bastantes restricciones a los números de tipo decimal.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="calificaciones">
    <xs:restriction base="xs:integer">
        <xs:totalDigits value="2"/>
        <xs:minExclusive value="0"/>
        <xs:maxInclusive value="10"/>
    </xs:restriction>
</xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{pattern}: permiten construir patrones que han de cumplir los datos de un elemento, mediante el uso de \textbf{expresiones regulares}. En la siguiente tabla se muestran algunos de los patrones que podemos emplear a la hora de construir las expresiones regulares:

        \begin{figure}[ht]

        \vspace{3ex}
        \centering

        \setlength{\tabcolsep}{10pt}
        \renewcommand{\arraystretch}{1.4}

        \begin{tabular}{| c | c |}
            \hline
            \textbf{Patrón}  & \textbf{Significado}  \\ \hline
            \centering \textbf{[A-Z a-z]} &  letra  \\ \hline
            \centering \textbf{[A-Z]} &  letra mayúscula  \\ \hline
            \centering \textbf{[a-z]} &  letra minúscula  \\ \hline
            \centering \textbf{[0-9]} &  dígitos decimales  \\ \hline
            \centering \textbf{\textbackslash D} &  cualquier carácter excepto dígitos  \\ \hline
            \centering \textbf{(A)} &  cadena que coincide con A  \\ \hline
            \centering \textbf{A | B} &  cadena que coincide con A o con B  \\ \hline
            \centering \textbf{AB} &  concatenación de las cadenas A y B  \\ \hline
            \centering \textbf{A?} & cero o una vez la cadena A  \\ \hline
            \centering \textbf{A+} & una o más veces la cadena A  \\ \hline
            \centering \textbf{A*} & cero o más veces la cadena A  \\ \hline
            \centering \textbf{[abcd]} & alguno de los caracteres entre corchetes  \\ \hline
            \centering \textbf{[\^abcd]} & ninguno de los caracteres que esta entre corchetes  \\             \hline
        \end{tabular}
        \caption{Patrones para expresiones regulares}
    \end{figure}

    Las expresiones regulares son una herramienta muy potente y nos ayudan a restringir de forma muy específica la cadena de texto que permitimos en lo datos. Si queremos obtener más información podemos consultar la \href{https://www.ibm.com/docs/en/integration-bus/10.0?topic=elements-message-sets-regular-expression-syntax}{página de IBM} sobre expresiones regulares, aunque realizando una búsqueda en internet podremos encontrar cientos de documentos sobre el tema, desde los más básicos a textos más avanzados.

    A continuación se muestra un ejemplo del uso de expresiones regulares, en el que se establece un patrón que restringe el formato al de un DNI:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="dni">
    <xs:restriction base="xs:string">
        <xs:pattern value="[0-9]{8}[A-Z]"/>
    </xs:restriction>
</xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

\subsection{Extensión de Datos Simples	}
Como hemos comentado en el punto 2.3.1, XML Schema permite trabajar tanto con \textbf{datos simples} como con \textbf{datos complejos}, es decir, compuesto por el anidamientos de otros datos simples o compuestos.

Aunque ya hemos visto como se define un datos simple, en este apartado vamos a ver las tres diferentes maneras que existen de extender un tipo de dato simple:

\begin{itemize}
    \item \textbf{Restricción}: se hace una restricción sobre un tipo de dato \textbf{XSD} ya definido y se establece el rango de valores que puede tomar. Las restricciones, como hemos visto en el punto anterior, son conocidas como \textbf{facetas}.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="edad">
    <xs:restriction base="xsd:positiveInteger">
        <xs:maxExclusive value="19"/>
        <xs:minInclusive value="12"/>
    </xs:restriction>
</xs:simpleType >
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Unión}: consiste en combinar dos o más tipos de datos en uno único.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="LongitudInternacional">
    <xs:restriction base="xs:string">
        <xs:enumeration value="cm" />
        <xs:enumeration value="m" />
    </xs:restriction>
</xs:simpleType>

<xs:simpleType name="LongitudSajona">
    <xs:restriction base="xs:string">
        <xs:enumeration value="pulgada" />
        <xs:enumeration value="pie" />
        </xs:restriction>
</xs:simpleType>

<!-- Unimos los dos tipos -->

<xs:simpleType name="Longitud">
    <xs:union memberTypes="LongitudInternacional  LongitudSajona">
</xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{Lista}: permite asignar a un elemento un número de valores válidos separados por espacios en blanco. Puede ser creada de forma similar a la unión con la diferencia de que solo puede contener un tipo d elemento.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:simpleType name="LongitudSajona">
    <xs:restriction base="xs:string">
        <xs:enumeration value="pulgada" />
        <xs:enumeration value="pie" />
    </xs:restriction>
</xs:simpleType>

<xs:simpleType name="Longitud">
    <xs:list itemType="LongitudSajona">
</xs:simpleType>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{itemize}

\subsection{Definción de Datos Complejos}
Aunuqe en el punto 2.3.1 hemos visto los tipos de datos complejos, en esta sección vamos a verlos con mas detalle. Si recordamos la definición que hemos dado, los \textbf{datos de tipo complejo} son aquellos que están compuestos por otros elementos y/o atributos. Su contenido esta definido entre las etiquetas de apertura y cierre del elemento.

Dentro de los tipos de datos complejos nos podemos encontrar, entre otros, los siguientes:

\begin{itemize}
    \item \textbf{xs:eschema}: contiene la definición del esquema, es el elemento de tipo complejo básico. Contiene el atributo \textbf{xmlns} (XML Namspace), que indica el espacio de nombres usado para el esquema.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<xs:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
</xs:schema>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{xs:complexType}: entre sus etiquetas de apertura y cierre se definen los elementos de un dato complejo. Pueden estar formados por elementos predefinidos en XML Schema, como los siguientes:

    \begin{itemize}
        \item \textbf{xs:sequence}: permite construir elementos complejos mediante la enumeración de los elementos que los forman en un orden concreto. Si se altera dicho orden en el documento XML, éste no será correcto.

        \begin{figure}[h]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}

        <xs:element name="Direccion">
            <xs:complexType>
                <xs:sequence>
                    <xs:element name="calle" type="xs:string" />
                    <xs:element name="poblacion" type="xs:string" />
                    <xs:element name="provinvia" type="xs:string" />
                    <xs:element name="codigo_postal" type="xs:int" />
                </xs:sequence>
            </xs:complexType>
        </xs:element>

        <!-- XML Válido -->

        <Direccion>
            <calle>Lago de Enol, nº 32</calle>
            <poblacion>Aguadulce</poblacion>
            <provincia>Almería</provincia>
            <codigo_postal>04720</codigo_postal>
        </Direccion>
               \end{verbatim}
           \end{tcolorbox}
       \end{figure}

       \item \textbf{xs:choice}: representa una alternativa, teniendo en cuenta que es exclusiva, es decir, especifica un lista de elementos de los cuales solo puede aparecer uno:

       \begin{figure}[H]
           \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
               \scriptsize
               \begin{verbatim}
      <xs:element name="FormaPago">
        <xs:complexType>
            <xs:choice>
                <xs:element name="paypal" type="xs:string" />
                <xs:element name="transferencia" type="xs:string" />
            </xs:choice>
        </xs:complexType>
      </xs:element>
               \end{verbatim}
           \end{tcolorbox}
       \end{figure}

   \item \textbf{x:all}: representa a todos los elementos que componen el elemento de tipo compuesto  en cualquier orden. A diferencia de \textbf{xs:sequence}, los elementos dentro de este tipo pueden aparecer en cualquier orden y el documento XML seguirá siendo válido.

   \item \textbf{Contenido Mixto}: se hace dando valor \textbf{true} al atributo \textbf{mixed} del elemento \textbf{xs:complexType} y se usa para poder mezclar texto y otros elementos como hijos. Los elementos hijos se definen con las opciones anteriores, xs:sequence, xs:choice y xs:all.

       \begin{figure}[h]
           \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
               \scriptsize
               \begin{verbatim}


            <xs:complexType mixed="true">
               \end{verbatim}
           \end{tcolorbox}
       \end{figure}

    \item \textbf{Elemento Vacío}: define un elemento que no puede contener ni texto ni hijos, únicamente atributos.

       \begin{figure}[h]
           \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
               \scriptsize
               \begin{verbatim}

            <xs:element>
                <xs:complexType>
                    <xs:attribute name='codigo' type='xs:integer'/>
                </xs:complexType>
            </xs:element>
               \end{verbatim}
           \end{tcolorbox}
       \end{figure}

   \item \textbf{Elemento simple con atributo}: es un elemento simple porque no tiene otros elementos, solo datos, pero es de tipo complejo (complexType) porque tiene un atributo:

       \begin{figure}[h]
           \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
               \scriptsize
               \begin{verbatim}
           <xs:element name="cuota">
               <xs:complexType>
                   <xs:simpleContent>
                       <xs:extension base="xs:float">
                           <xs:attribute type="xs:string" name="moneda"/>
                       </xs:extension>
                   </xs:simpleContent>
                5</xs:complexType>
           </xs:element>
               \end{verbatim}
           \end{tcolorbox}
       \end{figure}
   \end{itemize}
\end{itemize}

Con esta sección terminamos de ver como se definen en XML Schema los tipos de datos simples y complejos, así como los atributos. Además hemos visto formas de expandir los datos simples y agrupar los datos complejos y los atributos. En la siguiente sección veremos como enlazar un esquema con el documento XML que queremos validar.

\subsection{Asociación con Documentos XML}
Una vez que tenemos creado el \textbf{fichero XSD} debemos asociarlo con un \textbf{fichero XML}. El modo de asociar un esquema a un documento XMl es mediante un espacio de nombres al ejemplar del documento, donde se indica la ruta de la localización de los ficheros de esquemas mediante su URI, precedida del prefijo \textbf{xs:}.

Para que el documento XML siga las reglas no utilizaremos \textbf{<!DOCTYPE>}, sino que utilizaremos atributos especiales en el elemento raíz del documento XML.

Primero, al igual que en el documento XML Schema , necesitamos definir los dos espacios de nombres, el correspondiente al documento XML (que se suele usar sin abreviatura) y el espacio de nombres de XML Schema, que suele usar el prefijo xs.

Además es necesario indicar donde está el archivo XML Schema que contiene las reglas de aplicación para el documento. Esto se realiza mediante el atributo \textbf{schemaLocation}.

A continuación se muestra un ejemplo:

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<documento xmlns="http://www.iesaguadulce.es/doc" xmlns:xs="http://w3.org/2001/XMLSchema-instance"
xs:schemaLocation="esquema.xsd">
....
</documento>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Enlace de documento XML con el esquema XSD}
\end{figure}

Como vemos, se indica el \textbf{espacio por defecto de nombres}, que coincide con el declarado en el documento del esquema, se indica el \textbf{espacio de nombres del esquema}, que siempre será la misma url, y se asocia este espacio de nombres con el prefijo \textbf{xs}.

En el caso de que el esquema no definamos el espacio de nombres por defecto del documento, este quedaría de la siguiente forma:

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<documento xmlns:xs="http://w3.org/2001/XMLSchema-instance"
           xs:noNamespaceSchemaLocation="esquema.xsd">
....
</documento>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}


\subsection{Documentación del Esquema}
Una vez que hemos visto como crear el esquema, vamos a ver como incorporar cierta documentación.

Podemos pensar que una forma de hacerlo es añadir comentarios, el problema con esto es que los analizadores no garantizan que los comentarios no se modifiquen al procesar el documento, y por tanto, que los datos añadidos no se pierdan.

En lugar de usar comentarios, XML Schema tiene definido un elemento \textbf{xs:annotation} que permite \textbf{almacenar información adicional}. Este elemento a su vez puede contener una combinación de otros dos, los cuales son:

\begin{itemize}
    \item \textbf{xs:documentation}: ademas de contener elementos de esquema pueden contener elementos XML bien estructurados. También permite determinar el idioma del documento mediante el atributo \textbf{xs:lang}.

    \item \textbf{xs:appinfo}: se diferencia muy poco del elemento anterior, aunque lo que se pretendió es que xs:documentation fuera legible para los usuarios y que xs:appinfo guardase información para los programas de software. También se usa para generar una ayuda contextual para cada elemento declarado del esquema.
\end{itemize}

En la figura 2.3.6 se muestra un ejemplo de documentación de un esquema XML Schema. Como podemos ver, las anotaciones se pueden anidar dentro de los elementos, incluyendo a xs:appinfo para proporcionar información contextual de ese elemento concreto.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<xs:schema xmlns:xsi=http://www.w3.org/2001/XMLSchema>

    <xs:annotation>
        <xs:documentation xml:lang ="es-es">
            Materiales para formación e-Learning
            <modulo>Lenguajes de marcas y sistemas de gestión de información.<modulo>
            <fecha_creación> 2011<fecha_creacion>
            <autor> Nuky La Bruji</autor>
        </xs:documentation>
    </xs:annotation>

    <xs:element name="lmsgi"  type=xs:string>
        <xs:annotation>
            <xs:appinfo>
                <texto_de_ayuda>Nombre completo del tema</texto_de_ayuda>
            <xs:appinfo>
        </xs:annotation>
    </xs:element>
</xs:schema>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Ejemplo de documentación del esquema XML}
\end{figure}

\section{Herramientas de Creación y Validación}
Al igual que hasta ahora, para crear y validad un documento XML basta con un editor de texto plano, aunque no es lo ideal. Hay herramientas que nos facilitan el trabajo permitiendo al usuario visualizar, validar y editar documentos en el lenguaje XML de forma mucho más rápida y cómoda. Algunas de estas aplicaciones son:

\begin{itemize}
    \item \textbf{Notepad++}
    \item \textbf{Editix XML Edito}
    \item \textbf{XML Copy Editor}
    \item \textbf{NetBeans}
    \item \textbf{VSCode}
\end{itemize}

También tenemos herramientas de validación online, entre las que cabe destacar:

\begin{itemize}
    \item \url{https://www.xmlvalidation.com/}
    \item \url{xsdvalidation}
\end{itemize}

\section{Ejercicio Resuelto}
En esta sección vamos a incluir un ejercicio resuelto en el que crearemos documentos tanto, DTD como XSD, así como un documento XML que valide a estos dos documentos.

\subsection{Caso Práctico}
La empresa Reggio tiene establecimientos por toda Italia, pero su sede central está en Cesena, al igual que el almacén donde se distribuye a todos los demás establecimientos. Esta empresa distribuye alpiste para pájaros, así como otros artículos ornitológicos.

Cada establecimiento tiene una tienda, así como un almacén, que pueden o no estar en la misma ubicación. Cuando se hace un pedido a la fábrica por parte de los establecimientos, éstas reciben los artículos en su almacén, y la documentación (albarán y pago) se remite a la tienda.

Cada \textbf{pedido} debe tener los datos siguientes:

\begin{itemize}
    \item \textbf{Datos del establecimiento} que realiza el pedido (Nombre, dirección para envío y dirección almacén (si es la misma, sólo aparecerá una).
    \item \textbf{Código de pedido} (Cadena de caracteres formada por: Código establecimiento (1 letra y 2 números), número pedido (4 números), un guión y Año (dos números), por ejemplo: E180021-17.
    \item \textbf{Nombre del empleado} que realiza el pedido.
    \item \textbf{Fecha} de pedido.
    \item\textbf{Tipo de envío}, cuyos valores son: Normal o Urgente.
\end{itemize}

 Respecto a los \textbf{artículos} del pedido, se guardarán los siguientes datos:

\begin{itemize}
    \item \textbf{Código} del artículo (formado por tres letras y 3 números, por ejemplo: ZZZ134.
    \item \textbf{Número} de unidades.
    \item \textbf{Precio} por unidad.
    \item \textbf{Observaciones}.
\end{itemize}



\subsection{Creación del DTD}
En primer lugar vamos a crear un documento DTD con las especificaciones pedidas y un documento XML que valide estas especificaciones.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<!ELEMENT pedido (establecimiento,empleado,fecha_pedido,articulos)>
<!ATTLIST pedido cod_pedido CDATA #REQUIRED>
<!ATTLIST pedido tipo (normal|urgente) #REQUIRED>

<!ELEMENT establecimiento (nomb_estab,direccion_envio,direccion_almacen?)>
<!ELEMENT nomb_estab (#PCDATA)>
<!ELEMENT direccion_envio (via,numero,localidad,provincia,cp)>
<!ELEMENT direccion_almacen (via,numero,localidad,provincia,cp)>
<!ELEMENT via (#PCDATA)>
<!ELEMENT numero (#PCDATA)>
<!ELEMENT localidad (#PCDATA)>
<!ELEMENT provincia (#PCDATA)>
<!ELEMENT cp (#PCDATA)>

<!ELEMENT empleado (#PCDATA)>
<!ELEMENT fecha_pedido (#PCDATA)>

<!ELEMENT articulos (articulo+)>
<!ELEMENT articulo (unidades,precio,observaciones?)>
<!ATTLIST articulo cod_articulo CDATA #REQUIRED>
<!ELEMENT unidades (#PCDATA)>
<!ELEMENT precio (#PCDATA)>
<!ATTLIST precio moneda CDATA #REQUIRED>
<!ELEMENT observaciones (#PCDATA)>
        \end{verbatim}
    \end{tcolorbox}
    \caption{DTD del ejercicio propuesto}
\end{figure}

Una vez que hemos creado el DTD, deberemos crear un XML que verifique estas restricciones. En nuestro caso, podría ser el siguiente:

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pedido SYSTEM "tarea04_01.dtd">

<pedido cod_pedido="E180021-17" tipo="urgente">

    <establecimiento>
        <nomb_estab>Manitoba</nomb_estab>
        <direccion_envio>
            <via>Vittorio</via>
            <numero>1</numero>
            <localidad>Cesena</localidad>
            <provincia>Cesena</provincia>
            <cp>00400</cp>
        </direccion_envio>
        <direccion_almacen>
            <via>Vittorio</via>
            <numero>5</numero>
            <localidad>Cesena</localidad>
            <provincia>Cesena</provincia>
            <cp>00400</cp>
        </direccion_almacen>
    </establecimiento>

    <empleado>Roberto Rossini</empleado>
    <fecha_pedido>2017-05-01</fecha_pedido>

    <articulos>
        <articulo cod_articulo="ZZZ134">
            <unidades>1</unidades>
            <precio moneda="EUR">1.05</precio>
            <observaciones>Tenere lontano dalla portata dei bambini</observaciones>
        </articulo>
        <articulo cod_articulo="ZZZ137">
            <unidades>2</unidades>
            <precio moneda="EUR">3.50</precio>
        </articulo>
        <articulo cod_articulo="ZZZ139">
            <unidades>5</unidades>
            <precio moneda="EUR">5.50</precio>
        </articulo>
    </articulos>

</pedido>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML válido para el DTD}
\end{figure}

El documento XML podría haber sido diferente, siempre que respetemos el DTD.

\subsection{Creación del XML Schema}
Una vez que hemos creado el documento DTD y el XML correspondiente vamos a crear el XML Schema. En éste, podremos establecer más restricciones que en el DTD, como hemos visto a lo largo de este tema. También el documento será más complejo de crear.

En primer lugar vamos a crear el documento XSD. Como el documento es bastante largo, se ha divido en dos partes para que quepa bien en un página.


\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">

<!-- Definicion del vocabulario -->
    <xs:element name="pedido">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="establecimiento"/>
                <xs:element ref="empleado"/>
                <xs:element ref="fecha_pedido"/>
                <xs:element ref="articulos"/>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.pedido"/>
        </xs:complexType>
    </xs:element>

    <xs:attributeGroup name="attlist.pedido">
        <xs:attribute name="cod_pedido" type="cod_ped" use="required"/>
        <xs:attribute name="tipo">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="normal"/>
                    <xs:enumeration value="urgente"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>

    <xs:simpleType name="cod_ped">
        <xs:restriction base="xs:string">
            <xs:length value="10"/>
            <xs:pattern value="[A-Za-z][0-9]{2}[0-9]{4}-[0-9]{2}"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="establecimiento">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="nomb_estab"/>
                <xs:element ref="direccion_envio"/>
                <xs:element ref="direccion_almacen"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="nomb_estab" type="xs:string" />
    <xs:element name="direccion_envio">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="via"/>
                <xs:element ref="numero"/>
                <xs:element ref="localidad"/>
                <xs:element ref="provincia"/>
                <xs:element ref="cp"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="via" type="xs:string" />
    <xs:element name="numero" type="xs:string" />
    <xs:element name="localidad" type="xs:string" />
    <xs:element name="provincia" type="xs:string" />
    <xs:element name="cp">
        <xs:simpleType>
            <xs:restriction base="xs:string">
                <xs:length value="5" />
                <xs:pattern value="[0-9]{5}"></xs:pattern>
            </xs:restriction>
        </xs:simpleType>
    </xs:element>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML Schema (Parte 1)}
\end{figure}

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
    <xs:element name="direccion_almacen">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="via"/>
                <xs:element ref="numero"/>
                <xs:element ref="localidad"/>
                <xs:element ref="provincia"/>
                <xs:element ref="cp"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="empleado" type="xs:string" />
    <xs:element name="fecha_pedido" type="xs:date" />

    <xs:element name="articulos">
        <xs:complexType>
            <xs:sequence>
                <xs:element maxOccurs="unbounded" ref="articulo"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="articulo">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="unidades"/>
                <xs:element ref="precio"/>
                <xs:element ref="observaciones" minOccurs="0" />
            </xs:sequence>
            <xs:attributeGroup ref="attlist.articulo"/>
        </xs:complexType>
    </xs:element>

    <xs:attributeGroup name="attlist.articulo">
        <xs:attribute name="cod_articulo" type="cod_articulo" use="required"/>
    </xs:attributeGroup>

    <xs:simpleType name="cod_articulo">
        <xs:restriction base="xs:string">
            <xs:length value="6"/>
            <xs:pattern value="[A-Za-z]{3}[0-9]{3}"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="unidades" type="xs:positiveInteger"/>
    <xs:element name="precio">
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:decimal">
                    <xs:attributeGroup ref="attlist.precio" />
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:attributeGroup name="attlist.precio">
        <xs:attribute name="moneda" type="xs:NMTOKEN" fixed="EUR" use="required"/>
    </xs:attributeGroup>
    <xs:element name="observaciones" type="xs:string"/>
</xs:schema>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML Schema (Parte 2)}
\end{figure}

Una vez creado el documento XML Schema, creamos el XML que lo valide, que es similar al visto en el punto anterior, cambiando solo el modo de enlazar el documento con el esquema.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>

    <pedido xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
            xsi:noNamespaceSchemaLocation="reggio.xsd"
            cod_pedido="E180021-17"
            tipo="urgente">

        <establecimiento>
            <nomb_estab>Manitoba</nomb_estab>
            <direccion_envio>
                <via>Vittorio</via>
                <numero>1</numero>
                <localidad>Cesena</localidad>
                <provincia>Cesena</provincia>
                <cp>00400</cp>
            </direccion_envio>
            <direccion_almacen>
                <via>Vittorio</via>
                <numero>5</numero>
                <localidad>Cesena</localidad>
                <provincia>Cesena</provincia>
                <cp>00400</cp>
            </direccion_almacen>
        </establecimiento>
        <empleado>Roberto Rossini</empleado>
        <fecha_pedido>2017-05-01</fecha_pedido>

        <articulos>
            <articulo cod_articulo="ZZZ134">
                <unidades>1</unidades>
                <precio moneda="EUR">1.05</precio>
                <observaciones>Tenere lontano dalla portata dei bambini</observaciones>
            </articulo>
            <articulo cod_articulo="ZZZ137">
                <unidades>2</unidades>
                <precio moneda="EUR">3.50</precio>
            </articulo>
            <articulo cod_articulo="ZZZ139">
                <unidades>5</unidades>
                <precio moneda="EUR">5.50</precio>
            </articulo>
        </articulos>
</pedido>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento XML que valida el XML Schema}
\end{figure}

\section{Documentación de Apoyo}
En esta última sección vamos a incluir una serie de enlaces con documentación extra, incluyendo vídeos, para completar el contenido de este tema y para ver como se realizan los documentos de validación paso a paso. Los enlaces son los siguientes:

\begin{itemize}
    \item  \href{https://www.youtube.com/watch?v=1qFhBPkQqEM&ab_channel=PepeLluyot}{Ejercicio resuelto de DTD y XML Schema} - Parte 1 (Vídeo)
    \item  \href{https://www.youtube.com/watch?v=m1dmbNjbeZA&ab_channel=PepeLluyot}{Ejercicio resuelto de DTD y XML Schema} - Parte 2 (Vídeo)
    \item  \href{https://educacionadistancia.juntadeandalucia.es/formacionprofesional/pluginfile.php/36335/mod_scorm/content/33/ResumenDTD.pdf}{Resumen DTD} (PDF)
    \item \href{https://www.mclibre.org/consultar/xml/ejercicios/dtd.html}{Ejercicios DTD} (Web)
    \item \href{https://educacionadistancia.juntadeandalucia.es/formacionprofesional/pluginfile.php/36335/mod_scorm/content/33/DTD_SCHEMA.pdf}{DTD y XML Schema} (PDF)
    \item \href{https://www.youtube.com/watch?v=JKhfLpkVh3o&ab_channel=Introducci%C3%B3naXML%28iXML%29}{Estructura XML Schema} (Vídeo)
    \item \href{https://www.youtube.com/watch?v=EfnWCeQNTQI&ab_channel=Introducci%C3%B3naXML%28iXML%29}{Mi primer DTD} (Vídeo)
    \item \href{https://www.youtube.com/watch?v=ryoW-B_6cGs&ab_channel=LoboTecnoKu}{DTD: Elementos} (Vídeo)
    \item \href{https://www.youtube.com/watch?v=fPU1ex7bSgg&ab_channel=LoboTecnoKu}{Creación de DTD sencillo} - Parte 1 (Vídeo)
    \item   \href{https://www.youtube.com/watch?v=4NB89iXyxMU&ab_channel=LoboTecnoKu}{Creación DTD sencillo} - Parte 2 (Vídeo)
    \item \href{https://educacionadistancia.juntadeandalucia.es/formacionprofesional/pluginfile.php/36335/mod_scorm/content/33/SchemaDataTypesQR-2.pdf}{XML Schema: Data Types} (PDF)
\end{itemize}

\chapter{Utilización de Lenguajes de Marcas en Entornos Web}

\chapter{Utilización de Lenguajes de Marcas en la Sindicación de Contenidos}
En este tema vamos a estudiar como podemos utilizar los lenguajes de marcas para la \textbf{sindicación de contenidos}, un método que nos permite distribuir contenidos en la Web de forma que los usuarios puedan acceder a esta información basándose solo en los contenidos de su interés.

\section{Sindicación de Contenidos}
La sindicación de contenidos, desde el punto de vista Web, permite a \textbf{un sitio Web} utilizar los \textbf{servicios o contenidos} ofertados por otra web diferente. Estos servicios, juntos con los \textbf{metadatos} que tienen asociados a ellos en el sitio original, constituyen lo que conocemos como \textbf{feeds} o \textbf{canales de contenido}.

Esta redifusión suele realizarse bajo una \textbf{licencia de normas de uso}, en lugar de mediar un contrato para regular los derechos de los contenidos.

En la actualidad, la \textbf{redifusión Web} consiste en ofrecer en una página contenidos desde otra fuente web, permitiendo que los usuarios obtengan actualizaciones sobre dichos contenidos. Las \textbf{fuentes} suelen codificarse en lenguaje \textbf{XML}, aunque es válido hacerlo en cualquier lenguaje que pueda transportar el protocolo http.

\subsection{Características}
Para realizar esta sindicación de contenidos deberemos conseguir que la información, almacenada por ejemplo en un fichero local de un servidor, sea mostrada a los usuarios/as que quieran leerla. En el caso de que la información se haya codificado en un documento HTML, esto se llevará a cabo actualizando dicho documento en el directorio adecuado del servidor.

Actualmente es habitual el uso de un \textbf{CMS} (Content Management System), en cuyo caso los datos se encontrarán en un \textbf{repositorio} y antes de ser servidos al cliente sufren alguna transformación para pasarlos al formato adecuado.

Esta \textbf{transformación} puede corresponder a alguno de los siguientes casos:

\begin{itemize}
    \item Documento XML -> Transformación XSLT -> Documento XHTML
    \item Bases de Datos -> Script en Perl -> Documento HTML
    \item Texto plano -> ASP -> Documento HTML
    \item Mente del autor -> Editor de textos -> Documento HTML
\end{itemize}

Al utilizar cualquier tipo de CMS la transformación puede replicarse. Además, podemos tener mas de una entrada para la información así como \textbf{varias salidas}, pudiendo, por ejemplo, generar tanto \textbf{ficheros HTML} como \textbf{canales RSS}, tal y como se muestra en la siguiente imagen.

    \begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{html-rss.png}
    \caption{Generación de salidas HTML o RSS}
\end{figure}

Publicar en la Web puede ser visto como un \textbf{flujo de información}. Para que una web sea \textbf{suministradora} de un canal en su cabecera \textbf{<head>} hay que incluir un \textbf{enlace} al canal de contenidos, incluyendo un elemento \textbf{<link>} con sus correspondientes atributos \textbf{rel}, \textbf{href}, \textbf{type} y \textbf{title}.

Además tendremos que especificar el enlace para acceder al contenido, por lo que en algún lugar el elemento \textbf{<body>} de nuestro archivo HTML deberemos añadir un enlace usando el elemento \textbf{<a>} y completar sus atributos \textbf{href}, \textbf{type} y \textbf{rel}.

A continuación mostramos un ejemplo de un archivo HTML suministrador de un canal de noticias en formato Atom y RSS:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>RSS y ATOM</title>
    <link rel="stylesheet" href="style.css">
    <!--************************* NOTICIAS *******************************-->
    <link rel="alternate" href="feed/canal.rss" type="application/rss+xml" title="RSS">
    <link rel="alternate" href="feed/canal.atom" type="application/atom+xml" title="Atom">
    <!--************************* NOTICIAS *******************************-->

</head>

<body>
    <header>
        <h1>Unidad 3: Sindicación de contenidos web.</h1>
        <h2>Ejemplo práctico: Enlazar archivos RSS y Atom a una web</h2>
    </header>

    <main>
        <h3>Texto de relleno</h3>
        <p>
            Lorem, ipsum dolor sit amet consectetur adipisicing elit.
            Voluptatibus est sit distinctio ad et culpa maiores ipsam sunt
            dolores nihil, beatae consequuntur, illum mollitia! Veritatis, suscipit
            sapiente! Laboriosam, mollitia dolor.Ipsa expedita exercitationem
            voluptatum id eveniet ipsam nemo eos alias culpa hic. Non, distinctio.
            Alias, necessitatibus deleniti ipsum ullam aliquam ex. Nam cum tempora nisi
            adipisci vel voluptatum officiis asperiores.Dicta, nostrum optio. Facilis
            porro odit distinctio quas, debitis doloremque maiores eveniet, temporibus
            accusantium cum omnis quibusdam! Aperiam, debitis ipsam! Vitae dolorum beatae
            recusandae a laudantium velit eligendi, odio natus.Facere optio voluptate ut,
            ducimus deserunt iusto culpa. Blanditiis, rem. Reiciendis, sapiente.
            Alias necessitatibus recusandae voluptatibus minus beatae dolorum velit vero
            sequi voluptatum optio qui dignissimos, nemo voluptatem iste aliquid.
        </p>
        </main>

    <footer>
        <p>
            <hr>
            <!--************************* NOTICIAS *******************************-->
            <a rel="alternate" href="feed/canal.rss" type="application/rss+xml">
                <img src="img/valid-rss.png" alt="enlace RSS">
            </a>
            <a rel="alternate" href="feed/canal.atom" ype="application/atom+xml">
                <img src="img/valid-atom.png" alt="enlace Atom">
            </a>
            <!--************************* NOTICIAS *******************************-->
            <hr>
        </p>
    </footer>

</body>

</html>
        \end{verbatim}
    \end{tcolorbox}
    \caption{Documento HTML con canal RSS y Atom}
\end{figure}

\subsection{Ventajas de la Redifusión de Contenidos}
El uso de la redifusión de contenidos de otros propietarios nos puede aportar un número de ventajas, siendo las principales las siguientes:

\begin{itemize}
    \item \textbf{Aumentar el tráfico} de nuestro sitio Web.
    \item Ayuda a que los \textbf{usuario/as visiten frecuentemente} nuestro sitio web.
    \item Favorece el \textbf{posicionamiento} del sitio en \textbf{buscadores}.
    \item Ayuda a \textbf{establecer relaciones} entre \textbf{diferentes sitios web} dentro de la comunidad.
    \item Permite a \textbf{otras personas} añadir características a los \textbf{servicios del sitio web}, como por ejemplo, notificaciones de actualizaciones de contenido, mensajes instantáneos, etc.., aunque esto requiere tecnologías adicionales.
    \item Enriquece internet impulsando la \textbf{tecnología semántica} y \textbf{fomenta la reutilización}.
\end{itemize}

\section{Ámbitos de Aplicación}
La redifusión web no es sólo un fenómeno vinculado a los \textbf{weblogs}, aunque ha contribuido mucho a su popularización. Siempre se han sindicado contenidos y se ha compartido todo tipo de información usando documentos XML.

De esta forma, podemos ofrecer contenidos propios que sean mostrados en otras web de forma integrada, lo que aumenta el valor de la página web que muestra el contenido y también nos genera a nosotros más valor, ya que normalmente la redifusión web enlaza con los contenidos originales. Además, ésta puede aplicarse a cualquier tipo de contenido, ya sea \textbf{texto}, \textbf{audio}, \textbf{vídeo} e \textbf{imágenes}.

Desde el punto de vista de los \textbf{suscriptores}, la redifusión web permite, entre otras cosas, la actualización profesional. Mediante la suscripción a sitios relevantes, el usuario/a puede estar al día de temas relevantes relativos a su profesión, recibiendo noticias e información en su blog o su programa agregador de noticias.

\section{Tecnologías de Creación de Canales de Contenido}
Hay un conjunto de tecnologías que se usan para la creación de canales de contenido, o canales RSS. Los principales \textbf{estándares} utilizados son los siguientes:

\begin{itemize}
    \item \textbf{RSS} (Really Simple Syndication): este estándar forma parte de la familia de formatos XML, desarrollado para compartir información entre sitios web que se actualiza con frecuencia. Además, se usa en la conexión de sistema de mensajería instantánea, y permite la conversión de mensajes RSS en correos electrónicos o la transformación de los enlaces favoritos del navegador a RSS. Ha sido desarrollado por tres organizaciones diferentes lo que ha dado lugar a \textbf{siete formatos} diferentes:

    \begin{itemize}
        \item \textbf{RSS 0.90}: es el estándar que creo la empresa \textbf{Netscape} en 1990. Se basa en la especificación \textbf{RFD de metadatos}, con la intención de que su proyectos, My Netscape, estuviera formado por titulares de otras web.

        \item \textbf{RSS 0.91}: es la versión simplificada de RSS 0.90 que Netscape lanzó con posterioridad. Esta versión tuvo poco éxito y su desarrollo se detuvo, aunque la empresa UserLand Software decidió usar esta versión para desarrollar blogs.

        \item \textbf{RSS 1.0}: creado a partir del estándar \textbf{RSS 0.90}, es más estable y permite definir una cantidad mayor de datos que el resto de versiones RSS.

        \item \textbf{RSS 2.0}: la empresa UserLand Software rechazó el estándar RSS 1.0 por considerarlo complejo, y continuó con el desarrollo de RSS 0.91, publicando diferentes versiones, las cuales tenían una sintaxis incompleta y no cumplían con las normas XML. La versión 2.0 se publico para subsanar estos problemas.
    \end{itemize}

    \item \textbf{Atom}: fue publicado como un estándar por el grupod de trabajo \textbf{Atom Publishing Format and Protocol} de la \textbf{IETF} en el \textbf{RFC4287}. Se desarrollo como una alternativa a RSS, con el fin de evita la confusión creada por la existencia de estándares similares para la sindicación de contenidos, entre los que existían diferentes incompatibilidades. En lugar de sustituir estos, se creó un nuevo estándar que convive con ellos. Se caracteriza por su flexibilidad, ya que permite tener un mayor control sobre la cantidad de información que se muestra en los agregadores.
\end{itemize}

En los siguientes enlaces, puedes consultar las especificaciones de estos estándares:

\begin{itemize}
    \item \href{http://web.resource.org/rss/1.0}{RSS 1.0}
    \item \href{https://cyber.harvard.edu/rss/rss.html}{RSS 2.0}
    \item \href{http://tools.ietf.org/html/rfc4287}{Atom}
\end{itemize}

\section{Estructura de un Canal de Contenido}
Para crear una canal de contenidos es necesario crear un fichero siguiendo la especificaciones de \textbf{RSS} o \textbf{Atom} que están basadas en XML. Este \textbf{fichero}, se publicará en uno de los directorios del sitio web.

Los \textbf{elementos básicos} de estos ficheros son los siguientes:

\begin{itemize}
    \item \textbf{Declaración del documento XML} y definición de la \textbf{codificación empleada} en el documento. Esta última será, preferentemente, \textbf{UTF-8}, que es la más ampliamente utilizada y una de las que permite mayor rango de caracteres.

    \item \textbf{Un canal} en el que se determina el sitio web asociado a la fuente web a la que hace referencia el fichero. Este estará formado por:

    \begin{itemize}
        \item La propia \textbf{definición del canal}.
        \item \textbf{Secciones}: cada una de estas hará referencia a la web que contiene uno de los servicios que se van a ofrecer. En un canal pueden incluirse tantas secciones como se quiera, lo que hace que una canal pueda tener un tamaño enorme si contiene un gran número de enlaces independientes.
    \end{itemize}
\end{itemize}

En un principio, \textbf{no existe} ninguna \textbf{restricción} a la cantidad de canales que se pueden ofrecer desde un servicio web.

\subsection{RSS}
En esta sección vamos a crear un \textbf{canal de contenido} empleando el estándar \textbf{RSS}. Esto no servirá para explicar todos los elementos que debe contener un documento XML para la creación de dicho canal y las diferentes opciones y etiquetas que podemos emplear.

Para crear este canal, vamos a seguir los siguientes pasos:

\begin{enumerate}
    \item En primer lugar, vamos a crear un fichero con \textbf{extensión .rss}, con un editor de texto o un IDE de nuestra preferencia.

    \item Una vez creado el documento, vamos a comenzar a añadir los diferentes elementos necesarios para la creación del canal y que el documento sea válido, comenzando por la \textbf{declaración XML}, donde especificaremos la versión de XML a usar así como la \textbf{codificación del documento}, que en nuestro caso va a ser \textbf{UTF-8}.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


                     <?xml version="1.0" encoding="UTF-8"?>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Declaración XML en el documento RSS}
    \end{figure}

    \item A continuación, debemos de indicar el ejemplar. En este caso, el elemento raíz sera \textbf{<rss>}, donde además deberemos indicar, mediante el atributo \textbf{version}, la versión de RSS que vamos a emplear, en este caso, la 2.0.

       \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


                          <rss version="2.0">
                          ...
                          </rss>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Elemento raíz del documento RSS}
    \end{figure}

    \item Una vez creado el elemento raíz, debemos definir el canal empleando el elemento \textbf{<channel>}. Para su definición hay una serie de elementos obligatorios y otros opcionales. Los elementos obligatorios para definir el canal son los siguientes:

    \begin{itemize}
        \item \textbf{<title>}: es el título del canal de noticias, suele ser el mismo que el de la página Web.
        \item \textbf{<link>}: elemento con la dirección web de la página asociada al canal de noticias.
        \item \textbf{<description}: este elemento contiene una breve descripción del canal de noticias.
    \end{itemize}

    Estos elementos son obligatorios y siempre deben aparecer en en la definición de un canal, pero tenemos \textbf{muchos más elementos}, lo cuales no son obligatorios, pero que nos proporcionan diferentes funcionalidades, siendo los principales los siguientes:

    \begin{itemize}
        \item \textbf{<language>}: Determina el idioma utilizado en el canal de noticias, en el caso del español su valor será es. Para indicar español de España: es-es.
        \item \textbf{<item>}: Definirá cada una de las noticias del canal.
        \item \textbf{<copyright>}: Licencia de los contenidos del canal de noticias.
        \item \textbf{<managingEditor>}: Correo electrónico del editor de contenidos del canal de noticias.
        \item \textbf{<webMaster>}: Correo electrónico del responsable técnico del canal de noticias.
        \item \textbf{<pubDate>}: Fecha de publicación del canal de noticias. La fecha se debe escribir en formato: Sat, 07 Sep 2002 0:00:01 GMT
        \item \textbf{<lastBuildDate>}: Fecha del último cambio en los contenidos del canal. También en formato: Sat, 07 Sep 2002 0:00:01 GMT
        \item \textbf{<category>}: Categoría del canal de noticia. Puede estar asociada a una o más categorías.
        \item \textbf{<generator>}: En caso de que el canal de noticias sea generado, nombre del programa que se utiliza para hacerlo.
        \item \textbf{<docs>}: URL de la documentación sobre el formato usado en el archivo RSS.
        \item \textbf{<cloud>}: Permite que los procesos se registren en una nube para recibir notificaciones de las actualizaciones del canal de noticias.
        \item \textbf{<ttl>}: ``Time to live'', minutos que el canal de noticias esta en cache antes de actualizarse.
        \item \textbf{<image>}: Especifica una imagen GIF, JPEG o PNG que puede ser mostrada en el canal de noticias. Tiene tres atributos obligatorios: \textbf{url}, \textbf{title} y \textbf{link}. También se puede indicar el alto (height), ancho (width) y una descripción (description) con los atributos opcionales.
        \item \textbf{<textInput>}: Especifica una caja de texto de entrada que puede ser mostrada en el canal de noticias.
        \item \textbf{<skipHours>}: En este elemento pueden definirse subelementos <hour> que representan una hora GMT en las cuales los agregadores de noticias no se actualizarán.
        \item \textbf{<skipDays>}: En este elemento pueden definirse subelementos <day> que representan los días de la semana en los cuales los agregadores de noticias no se actualizarán.
    \end{itemize}

    Como vemos por la lista anterior, tenemos una gran variedad de elementos que nos permiten añadir información y configurar nuestro canal de contenidos. En nuestro caso, hemos añadidos los que se pueden ver en la siguiente figura:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <channel>
    <title>Canal de noticias</title>
    <link>http://www.noticias.com</link>
    <description>En este canal tendrás noticias actualizadas a diario</description>

    <language>es</language>
    <pubDate>Mon, 7 May 2018 17:32:06 GMT</pubDate>
    <managingEditor>paco@noticas.com (Paco López)</managingEditor>
    <image>
        <url>http://www.noticias.com/img/logo.png</url>
        <title>Canal de noticias</title>
        <link>http://www.noticias.com</link>
    </image>
    <copyright>Creative Common</copyright>
 </channel>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Creación del elemento channel y subelementos}
    \end{figure}

    En primer lugar hemos puesto los elementos obligatorios y a continuación hemos agregado algunos otros como language, pubDate, image o copyright.

    \item Por último, vamos a agregar una cuantas secciones dentro de la definición del canal con el elemento \textbf{<item>}. Un elemento \textbf{<channel>} puede contener cualquier número de elementos \textbf{<item>}, definiendo una sección del canal cada uno. Estas secciones pueden estar completas o contener una sinopsis y un enlace a la sección completa.

    Todos los subelementos del elemento <item>\ son opcionales, aunque al menos debe aparecer un \textbf{título} y una \textbf{descripción} de la sección.  <description>

    Los principales \textbf{subelementos} de <item>\ que existen son los siguientes:

    \begin{itemize}
        \item \textbf{<title>}: Título de la noticia.
        \item \textbf{<link>}: URL de la noticia enlazada, que ha de pertenecer al dominio establecido en el canal.
        \item \textbf{<description>}: Un resumen de la noticia.
        \item \textbf{<author>}: Correo electrónico del autor de la noticia.
        \item \textbf{<category>}: Categoría de la noticia. Puede estar asociada a una o más categorías.
        \item \textbf{<comments>}: URL del hilo de los comentarios relacionados con la noticia.
        \item \textbf{<enclosure>}: Descripción de objetos multimedia asociados a la noticia. Tiene tres atributos obligatorios: \textbf{url}, \textbf{length} y \textbf{type}.
        \item \textbf{<guid>}: Cadena única que identifica la noticia.
        \item \textbf{<pubDate>}: Fecha de publicación de la noticia. La fecha se debe escribir en formato: Sat, 07 Sep 2002 0:00:01 GMT.
        \item \textbf{<source>}: Canal RSS del que proviene la noticia. Tiene un atributo obligatorio \textbf{url}.
    \end{itemize}

    En nuestro ejemplo, nosotros hemos añadido 3 secciones dentro del elemento <channel>\ con los elementos que podemos ver a continuación:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <item>
    <title>Primera noticia de actualidad</title>
    <description>Esta noticia es un ejemplo de noticia de actualidad</description>
    <link>https://www.americannews.com/</link>
    <guid>http://www.americannews.com/today</guid>
    <author>John@americannews.com (John Johnson)</author>
    <category>Actualidad</category>
    <pubDate>Sun, 6 May 2018 12:24:26 GMT</pubDate>
 </item>

 <item>
    <title>Segunda noticia de actualidad</title>
    <link>https://www.titular.es/hoy/segunda.html</link>
    <guid>http://www.titular.es/segunda.html#titular</guid>
 </item>

 <item>
    <description>Otra noticia de ejemplo</description>
    <guid>http://www.quepais.com/actualidad/primera.html#titular</guid>
    <author>maria@actualidad.quepais.com (María Martín)</author>
    <pubDate>Sun, 6 May 2018 12:24:26 GMT</pubDate>
 </item>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Secciones del canal RSS}
    \end{figure}

    Como podemos ver, el número de elementos presentes en cada elemento <item> puede variar según nuestra preferencia o la cantidad de información que queramos añadir.

    No todos los elementos que hemos visto se han empleado en el ejemplo, habiendo algunos como el elemento \textbf{<enclosure>} que sería conveniente revisar la documentación oficial para ver más detalladamente como se usa cuales son sus atributos. Al final de esta sección, se incorporarán algunos enlaces hacia la documentación oficial.

    \item Por último, ponemos todos los elementos juntos y ya tendremos creado nuestro canal RSS, siendo el documento final resultante el que podemos ver en la siguiente figura.

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0">

    <!--CANAL DE NOTICIAS-->

    <channel>
        <title>Canal de noticias</title>
        <link>http://www.noticias.com</link>
        <description>En este canal tendrás noticias actualizadas a diario</description>

        <language>es</language>
        <pubDate>Mon, 7 May 2018 17:32:06 GMT</pubDate>
        <managingEditor>paco@noticas.com (Paco López)</managingEditor>
        <image>
        <url>http://www.noticias.com/img/logo.png</url>
        <title>Canal de noticias</title>
        <link>http://www.noticias.com</link>
        </image>
        <copyright>Creative Common</copyright>

        <!--LISTADO DE NOTICIAS-->
        <!--1º Noticia-->
        <item>
            <title>Primera noticia de actualidad</title>
            <description>Esta noticia es un ejemplo</description>
            <link>https://www.americannews.com/</link>
            <guid>http://www.americannews.com/today</guid>
            <author>John@americannews.com (John Johnson)</author>
            <category>Actualidad</category>
            <pubDate>Sun, 6 May 2018 12:24:26 GMT</pubDate>
        </item>

        <!--2º Noticia-->
        <item>
            <title>Segunda noticia de actualidad</title>
            <link>https://www.titular.es/hoy/segunda.html</link>
            <guid>http://www.titular.es/segunda.html#titular</guid>
        </item>

        <!--3º Noticia-->
        <item>
            <description>Otra noticia de ejemplo</description>
            <guid>http://www.quepais.com/actualidad/primera.html#titular</guid>
            <author>maria@actualidad.quepais.com (María Martín)</author>
            <pubDate>Sun, 6 May 2018 12:24:26 GMT</pubDate>
        </item>

    </channel>
</rss>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Documento RSS completo}
    \end{figure}
\end{enumerate}

Como hemos visto, la creación de un canal RSS puede ser bastante simple, aunque como hemos comentado, no hemos empleado todos los elementos en este ejemplo y puede que haya algunos que requieran ver ejemplos concretos para comprender bien como funcionan, por eso, se incluyen los siguiente enlaces para obtener información más detallada sobre los elementos y sus atributos.

\begin{itemize}
    \item \href{https://validator.w3.org/feed/docs/rss2.html}{RSS 2.0 en W3C}
    \item \href{https://validator.w3.org/feed/#validate_by_input}{Validador RSS 2.0 del W3C}
    \item \href{https://cyber.harvard.edu/rss/rss.html}{Especificación del estándar RSS 2.0}
\end{itemize}

\subsection{Atom}
En la sección anterior ya creamos una canal de contenido usando el estándar RSS 2.0, en esta sección, vamos a crear un canal pero empleando el \textbf{estándar Atom}, para ellos, vamos a enumerar los pasos para su creación al igual que hicimos en la sección anterior.

Como veremos, algunos pasos son prácticamente iguales, mientras que otros difieren tanto en los elementos como en sus atributos.

\begin{enumerate}
    \item En primer lugar creamos un documento con extensión \textbf{.atom} con nuestro editor o IDE favorito.

    \item A continuación, al igual que con RSS, vamos a agregar la \textbf{declaración XML} y la \textbf{codificación} que vamos emplear en el documento, que como vemos en la siguiente figura, no difiere del documento anterior.

        \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


                     <?xml version="1.0" encoding="UTF-8"?>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Declaración XML en el documento Atom}
    \end{figure}

    \item Lo siguiente definir el canal. A diferencia de RSS, con Atom definimos directamente el canal como elemento raíz empleando la etiqueta \textbf{<feed>}, a la que tendremos que añadir el estándar Atom usado, mediante el atributo \textbf{xmlns} y el lenguaje utilizado en el fichero con el atributo \textbf{xml:lang}, como podemos ver en la siguiente figura:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


            <feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es-es">
            ...
            </feed>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Elemento feed del canal Atom}
    \end{figure}

    \item Al igual que con los canales de RSS, en Atom tenemos ciertos \textbf{elementos obligatorios} que todo canal debe incluir, entre los que nos podemos encontrar los siguientes:

    \begin{itemize}
        \item \textbf{<title>}: Es el título del canal de noticias.
        \item \textbf{<id>}: Identificador del canal de noticias. Habitualmente su URI.
        \item \textbf{<updated>}: Fecha de publicación del canal de noticias. La fecha se debe escribir en el formato: CCYY-MM-DDTHH:MM:SSZ, donde T es el separador entre la fecha y la hora y Z indica que la hora hace referencia al sistema de tiempo universal, esto es la hora zulú, o la hora del meridiano de Greenwich. Ejemplo: 6 de febrero de 2010 a la 17:15 hora española tenemos que poner: 2010-02-06T16:15:00Z
    \end{itemize}

    Además de estos elementos obligatorios, tenemos dos \textbf{elementos recomendados} que si bien no es indispensable que aparezcan, es una buena práctica influirlos en cada canal. Estos son:

    \begin{itemize}
        \item \textbf{<link>}: Identificación del sitio web. Tiene un atributo obligatorio \textbf{href} y varios opcionales: \textbf{rel}, \textbf{type}, \textbf{hreflang}, \textbf{title} y \textbf{length}.

        Para el atributo \textbf{rel} deben indicarse dos valores, cada uno en un elemento link diferente:
        \begin{itemize}
            \item \textbf{self}: Referenciando la ubicación del fichero .atom.
            \item \textbf{alternate}: Referenciando la web.
        \end{itemize}

        \item \textbf{<author>}: Cada elemento feed debe tener al menos un \textbf{author} a menos que todas las noticias \textbf{entry} tengan \textbf{author}. Los datos de autor se podrán recoger en los subelementos: \textbf{name}, \textbf{email} y \textbf{uri}.
    \end{itemize}

    Al igual que con los canales RSS, tenemos un conjunto de \textbf{elementos opcionales} que nos ayudarán a aportar información al canal o a incluir imágenes, logos, etc... Estos elementos son:

    \begin{itemize}
        \item \textbf{<category>}: Categoría del canal de noticia. Puede estar asociada a una o más categorías. Tiene un atributo obligatorio \textbf{term}.
        \item \textbf{<contributor>}: Datos de los contribuidores al canal de noticias. Sigue la misma estructura que \textbf{author}.
        \item \textbf{<generator>}: Identifica el software usado para generar el canal de noticias. Tiene dos atributos opcionales \textbf{uri} y \textbf{version}.
        \item \textbf{<icon>}: Identifica una pequeña imagen para ser usada de icono. La imagen debe ser cuadrada.
        \item \textbf{<logo>}: Identifica una imagen como referencia del canal de noticias. La imagen debe ser el doble de ancha que de alta.
        \item \textbf{<rights>}: Información sobre los derechos de autor. Permite el atributo \textbf{type} para indicar la codificación del texto (text, html, xhtml)
        \item \textbf{<subtitle>}: Descripción o subtitulo para el canal de noticias.
    \end{itemize}

    Nosotros hemos agregado, además de las etiquetas obligatorias, las recomendadas y algunas opcionales, como podemos ver en la siguiente figura.

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


 <feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es-es">

    <title type="text">Canal de noticias</title>
    <id>http://www.noticias.com/</id>
    <updated>2018-05-07T17:32:06Z</updated>


    <link rel="self" type="application/atom+xml" href="feed/canal.atom" />
    <link rel="alternate" type="text/html" href="http://www.noticias.com" />
    <author>
        <name>Paco López</name>
        <email>paco@noticias.com</email>
    </author>

    <category term="novedades" />
    <generator version="1.0">vim</generator>
    <icon>img/icon.jpg</icon>
    <logo>img/logo.png</logo>
    <rights>Creative Common</rights>
    <subtitle type="text">Noticias de actualidad.</subtitle>
 </feed>
            \end{verbatim}
        \end{tcolorbox}
        \caption{Elementos del canal feed en Atom}
    \end{figure}

    \item A continuación vamos a definir las secciones. En Atom, esto se lleva a cabo con el elemento \textbf{<entry>}. A diferencia del elemento \textbf{<item>} de RSS que no tenía \textbf{elementos obligatorios}, el elemento <entry> si los tiene, siendo estos similares a los del elemento <feed>, como podemos ver a continuación:

    \begin{itemize}
        \item \textbf{<title>}: Es el título del canal de noticias.
        \item \textbf{<id>}: Identificador del canal de noticias. Habitualmente su URI.
        \item \textbf{<updated>}: Fecha de publicación del canal de noticias. La fecha se debe escribir en el formato: CCYY-MM-DDTHH:MM:SSZ, donde T es el separador entre la fecha y la hora y Z indica que la hora hace referencia al sistema de tiempo universal, esto es la hora zulú, o la hora del meridiano de Greenwich. Ejemplo: 6 de febrero de 2010 a la 17:15 hora española tenemos que poner: 2010-02-06T16:15:00Z
    \end{itemize}

    También tenemos unos \textbf{elementos recomendados} a la hora de definir una noticia con \textbf{<entry>}, que son los siguientes:

    \begin{itemize}
        \item \textbf{<link>}: Relacionado con el sitio web. Tiene un atributo obligatorio \textbf{href} y varios opcionales: \textbf{rel}, \textbf{type}, \textbf{hreflang}, \textbf{title} y \textbf{length}. Si no existe elemento \textbf{content} en la noticia debe haber un elemento \textbf{link} con el atributo \textbf{rel a alternate} que indique la página web de la noticia en el atributo href.
        \item \textbf{<content>}: Contenido o enlace al texto completo de la noticia. Debe existir un elemento \textbf{content} si no hay elemento \textbf{link} con el valor \textbf{rel=``alternative'}' o no hay un elemento \textbf{summary} en la noticia.
        \item \textbf{<author>}: Cada elemento entry debe tener al menos un \textbf{author} a menos que haya un elemento author en el \textbf{elemento feed} o como contenido del elemento \textbf{source}. Los datos de autor se podrán recoger en los subelementos: \textbf{name}, \textbf{email} y \textbf{uri}.
        \item \textbf{<summary>}: Breve resumen del contenido de la noticia. Este elemento debe añadirse si no hay elemento content en la noticia.
    \end{itemize}

    Por último, vamos a listar los \textbf{elementos opcionales}, que en este caso no son tan numerosos con en los anteriores:

    \begin{itemize}
        \item \textbf{<category>}: Categoría de la noticia. Puede estar asociada a una o más categorías. Tiene un atributo obligatorio \textbf{term}.
        \item \textbf{<contributor>}: Datos de los contribuidores de la noticia. Sigue la misma estructura que \textbf{author}.
        \item \textbf{<published>}: Fecha y hora de la creación o primera publicación de la noticia. La fecha se debe escribir en el formato: CCYY-MM-DDTHH:MM:SSZ
        \item \textbf{<rights>}: Información sobre los derechos de autor. Permite el atributo \textbf{type} para indicar la codificación del texto (text, html, xhtml)
        \item \textbf{<source>}: Contiene metainformación sobre el origen del canal de noticias si esta noticia está copiada de otro lugar.
    \end{itemize}

     Nosotros, al igual que en el ejemplo de RSS hemos \textbf{añadido 3 secciones} con diferentes elementos opcionales.

     \item Así, tras añadir todos los elementos que hemos descrito durante estos pasos, el documento resultante lo podemos ver en la siguiente figura:

     \begin{figure}[H]
         \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
             \scriptsize
             \begin{verbatim}
<?xml version="1.0" encoding="utf-8" ?>
<!-- **************************** CANAL ********************************-->

<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es-es">
    <title type="text">Canal de noticias</title>
    <id>http://www.noticias.com/</id>
    <updated>2018-05-07T17:32:06Z</updated>

    <link rel="self" type="application/atom+xml" href="feed/canal.atom" />
    <link rel="alternate" type="text/html" href="http://www.noticias.com" />
    <author>
        <name>Paco López</name>
        <email>paco@noticias.com</email>
    </author>

    <category term="novedades" />
    <generator version="1.0">vim</generator>
    <icon>img/icon.jpg</icon>
    <logo>img/logo.png</logo>
    <rights>Creative Common</rights>
    <subtitle type="text">Noticias de actualidad.</subtitle>

    <!--************************* NOTICIAS *******************************-->

    <entry>
        <title>Primera noticia de actualidad</title>
        <id>https://www.americannews.com/</id>
        <updated>2018-05-06T12:24:26Z</updated>

        <author>
            <name>John Johnson</name>
            <email>john@americannews.com</email>
        </author>
        <link rel="alternate" type="text/html" href="http://www.americann.com/today" />
        <summary>Estado del tiempo de la ciudad de Frankfurt</summary>

        <category term="actualidad"/>
        <contributor>
        <name>Ana Gómez</name>
        </contributor>
        <published>2018-05-10T09:12:30Z</published>
        <rights type="text">Copyright</rights>
    </entry>

    <entry>
        <title>Segunda noticia de actualidad</title>
        <link rel="alternate" type="text/html" href="https://www.ideal.es/hoy/1.html" />
        <updated>2019-12-18T19:25:00Z</updated>

        <id>https://www.titular.es/hoy/primera.html#titular</id>
        <summary>Esta es una noticia local de actualidad</summary>

        <category term="noticias locales"/>
    </entry>

    <entry>
        <title>Otra noticia de ejemplo</title>
        <link rel="alternate" type="text/html" href="http://www.pais.com/hoy/2.html" />
        <updated>2019-12-18T19:27:00Z</updated>

        <id>http://www.quepais.com/actualidad/segunda.html#titular</id>
        <summary>Aqui podras encontrar todo tipo de noticias de actualidad</summary>
        <author>
            <name>María Martín</name>
            <email>maria@actualidad.quepais.com</email>
        </author>

        <published>2018-05-06T12:24:26Z</published>
        <rights type="text">Copyright</rights>
    </entry>
</feed>
             \end{verbatim}
         \end{tcolorbox}
         \caption{Documento del Canal con Atom completo}
     \end{figure}
\end{enumerate}

Al igual que con el canal creado usando RSS, hay elementos y atributos que no se han usado en este ejemplo y que sería conveniente consultar más a fondo, para ver ejemplos de su uso y los valores que pueden tomar sus atributos. En los \textbf{siguiente enlaces} podemos ampliar la información y ver cada elemento de forma más detallada:

\begin{itemize}
    \item \href{https://validator.w3.org/feed/docs/atom.html}{Atom 1.0 en W3C}
    \item \href{http://atomenabled.org/developers/syndication/}{Syndication | Atom Enabled}
    \item \href{https://tools.ietf.org/html/rfc4287}{Especificación de Atom 1.0}
    \item \href{https://validator.w3.org/feed/#validate\_by_input}{Validador de Atom 1.0 de la W3C}
\end{itemize}

\section{Validación}
Una vez creado nuestro fichero, ya sea RSS o Atom, el siguiente paso será validarlo. En internet podemos encontrar múltiples lugares que ofrecen este servicio.

Para \textbf{validar un documento}, ya sea de Atom o RSS, solemos tener dos opciones, una es \textbf{introducir la URI} en la que esta alojado el fichero, en cuyo caso el validador comprobará que el documento alojado en esa dirección es válido, o bien \textbf{introduciendo el código} en el validador, el cual nos lo validará directamente.

Una vez introducido el documento, ya sea con un método u otro, el validador nos dirá si éste es válido. En caso de que no sea, nos mostrará cuales son los errores. También nos puede mostrar \textbf{sugerencias}, para por ejemplo, hacer el documento compatible con otro estándar incluyendo un enlace.

Una véz validado, nos ofrecerán la posibilidad de incluir un \textbf{banner con el resultado} de la validación en nuestra página web, mediante la inclusión de un enlace que nos proporcionan.

Uno de los validadores más empleados es el \href{https://validator.w3.org/feed/}{validador de la W3C}, que nos permite validar documentos tanto de RSS como de Atom mediante una URI o introduciendo directamente el código.

\section{Utilización de Herramientas}
Aunque podemos crear un documento RSS o Atom prácticamente con cualquier editor, hay editores e IDE`s que nos simplifican el trabajo añadiendo diferentes funcionalidades que no tiene un editor simple.

Un ejemplo de este tipo de herramientas es \textbf{PSPad Editor}, un editor de textos con licencia freeware orientado a la programación. Algunas de las funcionalidades que nos ofrece este editor son las siguientes:

\begin{itemize}
    \item Trabajar con distintos estándares.
    \item Importar documentos de texto con CSV y HTML..
    \item Editar HTML.
    \item Editar documentos XML e imágenes.
    \item Actualizar las fuentes por vía FTP.
    \item Exportar documentos RSS a HTML, CSV y Javascript.
\end{itemize}

Aunque hemos mencionado PSPad, hay una gran variedad de editores e IDE`s que nos pueden ofrecer estas funcionalidades y otras muchas más, como pueden set \textbf{Netbeans} o \textbf{VSCode} entre otros.

\section{Directorios de Canales de Contenido}
Los \textbf{directorios de canales de contenido} permiten que un fichero RSS esté disponible para cualquiera, además de facilitar a los usuarios/as finales la búsqueda de información, ya que estos directorios también clasifican los ficheros RSS.

Para usarlos, es necesario \textbf{registrar} un \textbf{fichero RSS} en un \textbf{directorio RSS}. El proceso es similar a registrar un sitio en un motor de búsqueda. Si tienes una web con un feed, es recomendable incluirlo en un directorio, ya que esto ayudará a incrementar las visitas de la web. Además, es totalmente gratuito.

Cabe mencionar, que es posible que a la hora de sindicar un canal puedan surgir problemas debido al uso de tildes o ñ en los contenidos del canal, por lo que siempre es recomendable usar la codificación \textbf{UTF-8} y las entidades XML que les sustituyen, es decir:

\begin{itemize}
    \item \textbf{\&aacute}, en lugar de à, \textbf{\&eacute}, en lugar de é, ...etc.
    \item \textbf{\&lt} en lugar de < y \textbf{\&gt} en lugar de >.
\end{itemize}

\section{Agregación}
Los clientes que quieran usar un servicio RSS o Atom tendrán que utilizar un \textbf{agregador de contenidos} para poder leer estos canales de información.

Un \textbf{agredador} o \textbf{lector de fuentes} es una aplicación software que permite suscribirse a fuentes RSS y Atom. El agregador avisa al usuario de que webs han incorporado contenido nuevo  desde la última lectura y cual es este contenido nuevo. Para ello hay que indicar la dirección web de cada archivo fuente en el agregador, ya sea en formato RSS o Atom, para que pueda acceder al contenido.

Existen \textbf{varios tipos de agregadores}, siendo los más comunes los siguientes:

\begin{itemize}
    \item \textbf{Agregadores RSS Web o En Línea}:

    Son aplicaciones que residen en determinados \textbf{sitios web} y que se ejecutan a través de la propia web. Los lectores RSS online cumplen la misma función que los programas que se instalan en el ordenador, aunque en estos todos se hace a través de la página web. Para ello, hay que \textbf{darse de alta} en la web que ofrece el servicio. A partir de ese momento, se puede acceder en cualquier momento al lector web introduciendo el nombre de usuario y contraseña. Son recomendables cuando el usuario/a no accede a internet siempre desde el mismo ordenador.

    Algunos ejemplos de estas aplicaciones son:

    \begin{itemize}
        \item \textbf{Netvibes}: \url{https://validator.w3.org/feed/}
        \item \textbf{Feedly}: \url{https://feedly.com/}
        \item \textbf{Inoreader}: \url{https://www.inoreader.com/}
    \end{itemize}

    \item \textbf{Agregadores RSS en Navegador Web o Gestor de Correo}:

    Son lectores de RSS que se instalan en un \textbf{navegador web} o en un \textbf{gestor de correo}. Antes los navegadores llevaban esta opción por defecto, aunque en la actualizad se le puede añadir esta funcionalidad mediante plugins. Algunos de los navegadores y gestores de correo más usados que tienen esta funcionalidad son \textbf{Mozilla Firefox}, \textbf{Outlook Express}, \textbf{Google Chrome} o \textbf{Mozilla Thunderbird}.

    Aquí tienes \href{https://www.muylinux.com/2018/10/16/firefox-64-eliminara-soporte-rss/}{un articulo} relacionado con el tema, en concreto con la eliminación de la opción por defecto en Firefox y donde se nos recomiendan diferentes extensiones.

    \item \textbf{Agregadores RSS de Escritorio}:

    Son aplicaciones que se instalan en el ordenador del usuario/a. Su uso es aconsejable para quienes acceden a internet siempre desde el mismo ordenador. Su interfaz suele ser parecida a la de los gestores de correo con un panel donde se agrupan suscripciones y otro donde se accede a la entradas individuales para su lectura.

    Algunos de estos programas son:

    \begin{itemize}
        \item \textbf{Feedreader}: \url{http://feedreader.com/download}
        \item \textbf{RSSReader}: \url{http://www.rssreader.com/download.htm}
    \end{itemize}

    \item \textbf{Agregadores de Podcast o Podcasting}:

    Un \textbf{Podcast} consiste en la \textbf{distribución de archivos multimedia}, por normal general \textbf{vídeo} y \textbf{audio}, de larga duración, mediante un sistema de \textbf{redifusión RSS} y que presenta la posibilidad de suscribirse y usar programas de descarga para que los usuarios los escuchen y vean. Suele haber dos tipos principales:

    \begin{itemize}
        \item \textbf{Podcast de Audio}: distribución de archivos de audio, en general en formato MP3 o AAC, con un tamaño pequeño y fáciles de manejar.

        \item \textbf{Podcast de Video o  Vodcast}: distribución de archivos de video que requieren conexiones de un gran ancho de banda, debido a su tamaño. En general suelen distribuirse en formato MP4 o M4V.
    \end{itemize}

    Algunos de los agregadores de podcast más usados son \textbf{Spotify}, \textbf{Podimo} o \textbf{Google Podcast}, los cuales permiten no solo escucharlos o verlos en directo, sino también descargarlos.
\end{itemize}

\chapter{Conversión y Adaptación de Documentos XML}
En esta unidad vamos a estudiar diferentes técnicas de adaptación y conversión de documentos XML. Para llevar a cabo esto, vamos a usar principalmente dos tecnologías ligadas a XML, por una lado \textbf{XPath}, un que permite realizar la consulta de elementos en en un documento XML y \textbf{XSL}, un lenguaje que nos permitirá realizar diferentes tipos de transformaciones a un documento XML.

\section{Técnicas de Transformación de Documentos XML}
Una de las principales herramientas para realizar transformaciones en un documento XML es \textbf{Extensible Stylesheet Language} (XSL), un lenguaje que interpreta hojas de estilo. Una \textbf{hoja de estilo XSL} describe como debe mostrarse un documento XML, algo parecido a lo que hace un archivo  \textbf{CSS} (Cascade Style Sheets) con los documentos HTML.

La especificación XSL define unas características y una sintaxis que se puede agrupar en tres partes:

\begin{itemize}
    \item \textbf{XSL Transfornation Language} (XSLT): es un lenguaje para la transformación de documentos XML que nos permite realizar diferentes tipos de transformaciones.
    \item \textbf{XML Path Language} (XPath): un lenguaje de consulta de elementos XML.
    \item \textbf{XSL Formatting Object} (XSL-FO): un vocabulario XML para especificar la semántica del formato, es decir, indica donde debe aparecer cada elemento, con que espaciado, que color, etc...
\end{itemize}

Para realizar las transformaciones se utilizan unos programas denominados \textbf{procesadores XSL} o \textbf{XSL parsers}. A estos programas se les debe indicar los archivos de entrada XSL y XML. Si los archivos no tienen errores, se generará el archivo deseado en el formato indicado en las instrucciones XSL.

\textbf{XSLT }fue diseñado para usar realizar transformaciones usando el vocabulario XML especificado por XSL-FO, pero también puede usarse  con independencia de XSL y dicho vocabulario. A nivel académico podemos realizar transformaciones de documentos XML a documentos HTML u otros XML de estructura diferente sin usar XSL-FO.

En esta unidad, usaremos \textbf{XSLT} y \textbf{XPath}, para evitar de esta forma la complejidad añadida por XSL-FO.

\section{XML Path Language (XPath)}
\textbf{XML Path Language} (XPath) es un lenguaje para la consulta de elementos en un documento XML. Diseñado originalmente para ser usado con \textbf{XSLT} (eXtensible Stylesheet Language for Transformations) y \textbf{XPointer} (XML Pointer Language), en versiones posteriores también es usado con \textbf{XQuery} como veremos en próximas unidades.

El consorcio W3C (The World Wide Web Consortium) aprobó su primera versión \textbf{XPath 1.0} en \textbf{noviembre de 1999}. XPath usa una sintaxis compacta y sin etiquetas, por lo que no se asemeja a XML. Su nombre surge por el uso de las rutas en la navegación a través de las estructuras jerárquicas dentro de un documento XML.

Posteriormente siguieron las \textbf{versiones}:

\begin{itemize}
    \item \textbf{XPath 2.0} (Enero de 2007)
    \item \textbf{XPath 2.O Second Edition} (Diciembre 2010)
    \item \textbf{XPath 3.0} (Abril de 2014)
    \item \textbf{XPath 3.1} (Marzo de 2017)
\end{itemize}

Para obtener más información puedes ver la \href{https://www.w3.org/TR/1999/REC-xpath-19991116/}{recomendación completa} en la web de W3C.

\subsection{Árbol de Nodos}
XPath modela los documentos empleando un \textbf{árbol de nodos}.

Un \textbf{árbol} es una estructura abstracta muy empleada en informática que representa una serie de elementos, \textbf{nodos}, unidos por líneas o \textbf{vértice}. Además, entre dos nodos cualesquiera solo existe un camino único y ninguno de los caminos forma un bucle.

El nombre de esta estructura le viene porque tiene forma de copa de árbol invertida. Partiendo de un nodo raíz, van añadiéndose ramas que contienen los nodos hijo. A los nodos que \textbf{tienen} al menos \textbf{un hijo} se les llama \textbf{nodos padre}. 	A los nodos que \textbf{no tienen} ningún hijo se les llama \textbf{nodos hoja}. Los nodos que \textbf{comparten padre} se les llama \textbf{nodos hermanos}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{arbol-nodos.png}
    \caption{Árbol de nodos}
\end{figure}

En \textbf{XPath} existen distintos \textbf{tipos de nodos} que recogen diferentes tipos de información en los documentos XML. Los \textbf{siete tipos distintos} de nodos que podemos encontrar en XPath son los siguientes:

\begin{itemize}
    \item \textbf{Nodo raíz}: es el primer nodo del árbol y el único que no tiene padre. No hay que confundir el nodo raíz con el elemento raíz del documento XML. El nodo raíz tiene como hijos al elemento raíz y en su caso, los comentarios y las instrucciones de procesamiento que formen el prólogo del documento XML.

    \item \textbf{Nodo Elemento}: hay un nodo elemento por cada elemento XML en el documento. Todos los nodos elemento tienen un sólo padre que puede ser otro elemento o el nodo raíz. Los nodo elementos pueden tener un identificador único (ID), aunque para ello deben estar declarados como tipo ID en el documento DTD o en el XMl Schema.

    \item \textbf{Nodo atributo}: estos nodos almacenan los atributos de un documento XML. Un nodo atributo estará asociado a un único elemento que será el padre de este, pero desde el punto de vista del elemento no se considera a los nodo atributo como sus hijos. Los nodo atributo son siempre nodos hoja, es decir, no pueden tener nodos hijo.

    \item \textbf{Nodo texto o contenido}: estos nodos almacenan los valores alfanuméricos de los elementos en un documento XML. Estos nodos son nodos hoja, al igual que nodos atributo. Nótese que los valores de los nodos atributo no se almacenan en nodos texto, sino en los propios identificadores de dichos nodos.

    \item \textbf{Nodo comentario}: son los nodos que almacenan los comentarios de un documento XML. El nodo almacenará el contenido del comentario sin incluir las cadenas de inicio (<!--) ni fin (-->) del comentario.

    \item \textbf{Nodo espacio de nombres}: cada nodo elemento puede tener un conjunto asociado de nodos espacio de nombres, uno para cada uno de los distintos prefijos de espacios de nombres, incluyendo si si es el caso el espacio de nombres por defecto. Tienen un funcionamiento parecido a los nodos atributo. Un nodo espacio de nombres tiene un único elemento como nodo padre, pero desde el punto de vista del elemento estos nodos no son considerados nodos hijo. Estos nodos siempre serán nodos hoja.

    \item \textbf{Nodo instrucción de procesamiento}: hay un nodo por cada instrucción de procesamiento. No se incluye la cadena de terminación de la orden (?>).
\end{itemize}

Además se establece un \textbf{orden entre los nodos} que se corresponde con el orden en el que está escrito el documento, de modo que la raíz será el primer nodo y los nodos elemento aparecerán antes que sus hijos. Por tanto, el orden del documento establece un orden para los nodos según el orden de aparición de las etiquetas de apertura de dichos elementos en el documento XML. Los nodos atributos y los nodos espacio de nombres aparecen antes que los hijos del elemento, apareciendo los nodos espacio de nombres antes que los nodos atributo.

El nodo raíz y los nodos elemento tiene un lista ordenada de nodos hijo. Además, los nodos nunca comparten hijo, es decir, cada nodo tiene un único padre, excepto del nodo raíz que no tiene padre.

En el \textbf{siguiente ejemplo} de un documento XML que almacena una agenda podemos ver el árbol de nodos que crea la aplicaicón \textbf{BaseX}. Podemos observar a la izquierda el documento XML y a la derecha el árbol creado. Esta aplicación no resalta los diferentes nodos de ninguna forma especial, mostrando todos con su identificador.

En la siguiente figura podemos ver una captura del documento y su correspondiente árbol.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{xml-arbol.png}
    \caption{Arbol de un documento XML}
\end{figure}

\begin{itemize}
    \item El \textbf{nodo raíz} esta indicado con el nombre del documento \textbf{XML:arbol\_nodos\_ejemplo.xml}. Nótese que no se corresponde con el elemento raíz que en esta caso sería 'agenda'. Es importante \textbf{no confundir} el nodo raíz con el elemento raíz. El primero ser refiere al árbol de nodos y el segundo al documento XML.

    \item Los \textbf{nodos elementos} son los más abundantes: \textbf{agenda}, \textbf{contacto}, \textbf{nombre} y \textbf{teléfono}.

    \item Los \textbf{nodos texto} son los contenidos de los elementos \textbf{nombre} y \textbf{teléfono}, es decir: \textbf{Jóse}, \textbf{600102030}, \textbf{Pizzería Roma} y \textbf{600302010}. Estos nodos siempre serán nodos hoja.

    \item Los \textbf{nodos atributo} recogen el identificado y el valor. En nuestro caso, \textbf{tipo=``personal''} y \textbf{tipo=``empresa''}.

    \item También podemos ver en el ejemplo los \textbf{nodos comentario}, uno al inicio y otro dentro del segundo elemento \textbf{contacto}, con el contenido \textbf{Ejemplo de agenda y añadir dirección web}.
\end{itemize}

\subsection{Relaciones entre Nodos}
Cuando nos \textbf{posicionamos en un nodo} dentro de un árbol de nodos se establecen \textbf{distintas relaciones} con otros nodos del arbol. El nodo en el que nos posicionamos para establecer la relación se denomina \textbf{nodo contexto} o \textbf{nodo contextual}. Las distintas relaciones que podemos tener serán utilizadas después como ejes en los pasos de localización.

Las \textbf{relaciones} que se pueden establecer son la siguientes:

\begin{itemize}
    \item \textbf{self}: contiene solo el nodo contexto.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-1.png}
    \end{figure}

    \item \textbf{child}: contiene los hijos del nodo contexto.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-2.png}
    \end{figure}

    \item \textbf{descendant}: contiene los descendientes del nodo contexto, es decir, los hijos y los hijos de éstos, etc.. Nunca contiene nodos atributo o espacio de nombres.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-3.png}
    \end{figure}

    \item \textbf{descendant-or-self}: contiene todos los nodos que contiene la relación descendant además del nodo contexto mismo.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-4.png}
    \end{figure}

    \item \textbf{parent}: contiene el padre del nodo contexto, si lo hay.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-5.png}
    \end{figure}

    \item \textbf{ancestor}: contiene los ancestros del nodo contexto, es decir, el padre del nodo contexto y el padre de este, etc.. Esta relación siempre incluirá al nodo raíz, salvo que el nodo contexto sea el mismo nodo raíz.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-6.png}
    \end{figure}

    \item \textbf{ancestor-or-self}: contiene los mismo nodos que la relación ancestor, pero además incluye al nodo contexto mismo.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-7.png}
    \end{figure}

    \item \textbf{preceding}: contiene todos los nodos del mismo documento que el nodo contexto que están antes que él, según el orden de documento, excluyendo a los ancestros y los nodos atributos y espacio de nombres.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-8.png}
    \end{figure}

    \item \textbf{preceding-siblin}: contiene todos los hermanos precedentes del nodo contexto. Si el nodo contexto es un nodo atributo o espacio de nombres el eje preceding-sibling estará vacío.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-9.png}
    \end{figure}

    \item \textbf{following}: contiene todos los nodos del mismo documento que el nodo contexto que preceden a este según el orden del documento, excluyendo a los descendientes de este y los nodos atributo y espacio de nombres.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-10.png}
    \end{figure}

    \item \textbf{followinf-sibling}: contiene todos los elementos siguiente al nodo contexto. Si el nodo contexto es un nodo atributo o espacio de nombres, el eje following-sibling estará vacío.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{relacion-nodo-11.png}
    \end{figure}
\end{itemize}

No se han incluido \textbf{nodos atributo} ni \textbf{nodos espacios de nombres} en estos gráficos para simplificarlos un poco, pero las \textbf{relaciones} que podemos encontrar con estos nodos son las siguientes:

\begin{itemize}
    \item \textbf{attribute}: contiene todos los nodos atributos del nodo contexto. Esta relación estará vacía si el elemento contexto no es un nodo elemento, ya que es el único que puede tener atributos.
    \item \textbf{namespace}: contiene todos los nodos de espacio de nombres del nodo contexto. Al igual que la relación attibute, ésta estará vacía si el nodo contexto no es un nodo elemento.
\end{itemize}

\subsection{Sintaxis}
La sintaxis de XPath no usa etiquetas, por lo que no se asemeja a XML. Como su utilidad es hacer búsquedas en el árbol de nodos, se utiliza una sintaxis similar a la que se usa en los árboles de directorios y archivos del sistema operativo.

Un ejemplo de sintaxis de XPath puede ser el siguiente '\textbf{camino de localización}' (location paths):

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


descendant-or-self::curso[position()=1]/child::grupo[position()=2]/child::alumno[last()]/
    child::nombre/child::node()
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Aunque siempre que se pueda, se suele emplear su \textbf{versión simplificada}. El ejemplo anterior, quedaría de la siguiente forma en esta versión:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


                   //curso[1]/grupo[2]/alumno[last()]/nombre/text()
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Como podemos ver, nos hemos ahorrado muchos caracteres, y la consulta se ve mucho más limpia y fácil de entender. Por lo que es altamente recomendable usar la versión simplificada siempre que se pueda.

Además de las expresiones XPath, se pueden emplear \textbf{llamadas a funciones}, \textbf{operaciones matemáticas simples} y \textbf{operaciones lógicas}.

Cuando un programa \textbf{evalúa} un \textbf{camino de localización} devolverá el resultado en uno de los siguientes \textbf{tipos básicos}:

\begin{itemize}
    \item Un \textbf{conjunto de nodos} (Node-Set): una colección desordenada de nodos sin duplicados. Nótese que este conjunto de nodos no puede ser vacío ni contener un único nodo.
    \item Un \textbf{valor lógico} (booleano): el valor verdadero o falso.
    \item Un \textbf{valor numérico}: un número en punto flotante.
    \item Una \textbf{cadena de caracteres}.
\end{itemize}

Las \textbf{palabras reservadas} de XPath son las siguientes:

\begin{itemize}
    \item \textbf{Ejes}: ancestor, ancestor-or-self, child, descendant, descendant-or-self, following, following-sibling, namespace, parent, preceding, preceding-sibling y self.

    \item \textbf{Selectores de nodos}: node(), text(), comment() y procesing-instruction().
    \item \textbf{Operaciones lógicas}: and, or, not().
    \item \textbf{Operaciones matemáticas}: div, mod.
\end{itemize}

Además, hay un \textbf{conjunto de símbolos} con funcionales definidas en el lenguaje, a saber:

\begin{itemize}
    \item \textbf{Agrupación} de \textbf{operaciones} con paréntesis: \textbf{()}
    \item \textbf{Predicados} con corchetes: \textbf{[]}
    \item Abreviación \textbf{nodo actual} con el punto: \textbf{.}
    \item Abreviación del \textbf{nodo padre} con dos puntos: \textbf{..}
    \item Abreviación del \textbf{atributo} con la arroba: \textbf{@}
    \item \textbf{Todos} los \textbf{tipos de nodos} con el asterisco: \textbf{*}
    \item \textbf{Separado eje-selector} con los dos puntos: \textbf{:}
    \item \textbf{Separador} de los \textbf{pasos} de localización con la barra: \textbf{/}
    \item Abreviación del \textbf{paso} de localización \textit{descendant-or-self::node()} con dos barras: \textbf{//}
    \item Referencia a \textbf{una variable} con el símbolo del dolar: \textbf{\$}
    \item \textbf{Unión} de conjuntos con las barra vertical: \textbf{|}
    \item \textbf{Operaciones lógicas}: \textbf{=}, \textbf{!=}, \textbf{<}, \textbf{>}, \textbf{<=} y \textbf{>=}
    \item \textbf{Operaciones matemáticas}: \textbf{+}, \textbf{-} y \textbf{*}
\end{itemize}

El lenguaje también usa:

\begin{itemize}
    \item \textbf{Nombres cualificados} de los identificadores de XML.
    \item Los \textbf{nombres de las funciones} que se desean utilizar.
    \item \textbf{Nombres de las referencias a variables} anteponiendo el símbolo \$.
    \item \textbf{Numeros y literales}, estos últimos entrecomillados con comillas simples o dobles. Pueden anidarse alternando el tipo de comillas.
\end{itemize}

A continuación, mostramos \textbf{un ejemplo} de como se realizarían varias consultas dado un documento XML. En la siguiente imagen, podemos ver el documento XML que se usará de ejemplo.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.50]{ejemplo-xpath-xml.png}
    \caption{XML de ejemplo para XPath}
\end{figure}

Partiendo de este documento XML, vamos a realizar la siguientes consultas:

\begin{enumerate}
    \item Localizar al alumnado de la clase 2 de ESO A:

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


/child::colegio/child::curso[@nivel="2"]/child::grupo[@orden="A"]/child::alumno

<!-- Versión simplificada -->

/colegio/curso[@nivel="2"]/grupo[@orden="A"]/alumno


            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Localizar a todas las alumnas llamadas Ana:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


descendant-or-self::alumno[nombre="Ana"]

<!-- Versión simplificada -->

//alumno[nombre="Ana"]

            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Nombre del alumno con la nota más alta:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


descendant-or-self::alumno[child::nota_media=max(/descendant-or-self::nota_media)]/
    child::nombre

<!-- Versión simplificada -->

//alumno[nota_media=max(//nota_media)]/nombre
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}
\end{enumerate}

\subsubsection{Caminos de Localización}
Aunque los \textbf{caminos de localización} no son la construcción gramatical más general del lenguaje XPath, si es la \textbf{más importante}.

Todo camino de localización se \textbf{puede expresar} utilizando la sintaxis compleja, aunque algo más extensa. Existen también ciertas abreviaturas sintácticas que permiten expresar los casos más frecuentes de forma más concisa.

Siguiendo con el ejemplo anterior:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


        /descendant-or-self::curso[position()=1]/child::grupo[position()=2]
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

A estas expresiones se le llama \textbf{camino de localización} (location paths). Estos caminos están compuestos por trozos separados por barras (\textbf{/}). Cada uno de estos trozos se denominan \textbf{pasos de localización} (location steps).

A su vez, cada \textbf{pasado de localización} esta separado en dos partes por dos puntos dobles (\textbf{::}). A la \textbf{primera parte} se le denomina \textbf{eje} (axe) y a la \textbf{segunda parte} se le llama \textbf{selector de nodos} (node test).

En la siguiente imagen podemos ver de forma más gráfica las diferentes partes de una expresión de camino de localización.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{camino-localizacion.png}
    \caption{Partes de un camino de localización}
\end{figure}

En algunos \textbf{pasos de localización} hay instrucciones entre corchetes (\textbf{[]}), después del selector de nodos. Son los conocidos como \textbf{predicados}.

Además, en los caminos de localización se pueden usar \textbf{llamadas a funciones}, \textbf{operaciones matemáticas} y \textbf{operaciones lógicas}, como por ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


sum(//nota_media) div count(//nota_media)

substring(//child::colegio/child::comment(), 12, 4)
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Los caminos de localización pueden expresarse de forma \textbf{absoluta o relativa}:

\begin{itemize}
    \item Un \textbf{camino de localización} es \textbf{absoluto} si comienza por el nodo raíz. Esto se puede reconocer fácilmente ya que el camino de localización comenzará con una barra (\textbf{/}). Por ejemplo:

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}


            /child::colegio/child::curso/child::grupo/attribute::*
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Si no comienza por el nodo raíz, estamos hablando de una \textbf{camino de localización relativo}, es decir, relativo al nodo de contexto que éste posicionado en un determinado lugar. En el siguiente ejemplo el nodo contexto estaría posicionado en el elemento grupo:

    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


                               child::grupo/attribute::*
        \end{verbatim}
    \end{tcolorbox}
\end{figure}
\end{itemize}

Además, podemos usar el \textbf{operador unión} (\textbf{|}) para unir el resultado de dos caminos de localización que devuelvan conjuntos de nodos, como por ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}


                descendant-or-self::apellidos | descendant-or-self::nota_media
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsubsection{Pasos de Localización}
Como hemos visto en el punto anterior los caminos de localización pueden estar compuestos de \textbf{pasos de localización}. Cada paso irá refinando la búsqueda de la información que deseemos localizar. Los pasos de localización se separan unos de otros con una barra (\textbf{/}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{paso-localizacion.png}
    \caption{Elementos de un paso de localización}
\end{figure}

Como vemos en la imagen, una paso de localización tiene \textbf{3 partes diferentes}:

\begin{itemize}
    \item Un \textbf{eje}, que especifica la relación jerárquica entre los nodos seleccionados por el paso de localización y el nodo contextual.
    \item Un \textbf{selector de nodos}, que especifica el tipo de nodo de los nodos seleccionados por el paso de localización.
    \item Cero o más \textbf{predicados}, que usan expresiones lógicas para refinar aún más el conjunto de nodos seleccionados por el paso de localización.
\end{itemize}

La \textbf{sintaxis} de un paso de localización es, por tanto, el \textbf{nombre del eje} y el \textbf{selector de nodos}, separados por dos puntos dobles (\textbf{::}), seguidos de cero o más \textbf{predicados}, cada uno de los cuales va entre corchetes (\textbf{[]}). Por ejemplo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}

                            child::grupo[position()=2]
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

Donde \textbf{child} es el nombre del eje, \textbf{grupo} es el selector de nodo y \textbf{[position()=2]} es un predicado.

El \textbf{conjunto de nodos seleccionados} por un paso de localización es el resultante de generar un conjunto de nodos inicial a partir  del eje y el selector de nodos, para a continuación filtrar dicho conjunto por cada uno de los predicados definidos. El conjunto final de nodos es el conjunto seleccionado por el paso de localización.

\subsubsection{Ejes}
Los \textbf{ejes} se corresponden con las relaciones entre los nodos del árbol de nodos que hemos visto en puntos anteriores. Estos \textbf{trece} ejes son:

\begin{itemize}
    \item \textbf{self}: nodo contexto.
    \item \textbf{child}: hijos del nodo contexto.
    \item \textbf{descendant}: descendientes del nodo contexto.
    \item \textbf{descendant-or-self}: nodo contexto y sus descendientes.
    \item \textbf{parent}: padre del nodo contexto.
    \item \textbf{ancestor}: ancestros del nodo contexto.
    \item \textbf{ancestor-of-self}: nodo contexto y ancestros.
    \item \textbf{preceding}: nodos anteriores.
    \item \textbf{preceding-sibling}: hermanos anteriores.
    \item \textbf{following}: nodos posteriores.
    \item \textbf{followinf-sibling}: nodos hermanos posteriores.
    \item \textbf{attribute}: nodos atributos.
    \item \textbf{namespace}: nodos de espacio de nombres. En XPath 2.0 se dejó de usar.
\end{itemize}

Hay que recordad que para seleccionar los atributos o espacios de nombres hay que utilizar  la \textbf{forma explícita}  de sus ejes correspondientes. Por ejemplo, en el eje \textbf{child} de un nodo elemento no contendrá sus atributos ni sus espacios de nombres.

\subsubsection{Selectores de Nodos}
Los \textbf{selectores de nodos} usan los diferentes tipos de nodos que vimos al estudiar el árbol de nodos. Cada uno tiene un tipo principal de nodos. Si un eje puede contener elementos, entonces el tipo principal del no es elemento, en otro caso, será el tipo de nodo que contenga el eje. Pudiendo ser:

\begin{itemize}
    \item Para el eje \textbf{attribute}, el tipo de nodo principal son los \textbf{atributos}.
    \item Para el eje \textbf{namepspace}, el tipo de nodo principal son los \textbf{espacios de nombres}.
    \item Para los \textbf{demás ejes}, el tipo de nodo principal será el \textbf{elemento}.
\end{itemize}

El siguiente elemento en el paso de localización es el \textbf{selector de nodos}. XPath nos proporcionar los siguientes:

\begin{itemize}
    \item \textbf{Nombre cualificado}: nombre del objeto que estamos buscando.
    \item \textbf{Todos} (\textbf{*})
    \item \textbf{text()}
    \item \textbf{comment()}
    \item \textbf{processing-intruction()}
    \item \textbf{node()}
\end{itemize}

Estos son los selectores de nodos orinales, pero en versiones posteriores de XPath se agregaron algunos selectores más, que son los siguientes:

\begin{itemize}
    \item \textbf{element()}
    \item \textbf{attribute()}
    \item \textbf{document-node()}
\end{itemize}

Un selector de nombres que sea un \textbf{nombre cualificado} (QName) es cierto si los tipos de nodo se corresponden y tiene un nombre igual al especificado por el nombre cualificado. Por ejemplo, \textbf{child::alumno} selecciona los elementos \textbf{alumno} hijos del nodo contexto. Si el nodo contexto no tiene ningún hijo alumno, seleccionará un conjunto de nodos vacíos. Otro ejemplo es, \textbf{attribute::nivel}, que seleccionaría el atributo \textbf{nivel} del nodo contexto. Si este no tuviera ningún atributo \textbf{nivel}, se seleccionará un conjunto de nodos vacíos igualmente.

Un selector de nodos \textbf{*} es cierto para cualquier nodo del tipo principal de nodo. Por ejemplo, \textbf{child::*} seleccionará todo elemento hijo del nodo contexto, y \textbf{attribute::*} seleccionaría todos los nodos atributos de éste.

El selector de nodos \textbf{text()} es cierto para cualquier nodo de texto. Por ejemplo, \textbf{child::text()} seleccionaría todos los nodos hijos del nodo contexto que son de tipo texto.

Análogamente, el selector de nodos \textbf{comment()} es cierto para cualquier nodo comentario, y el selector de nodos \textbf{processgin-instruction()} es cierto para cualquier instrucción de procesamiento. El selector \textbf{processing-instruction()} puede tener un argumento que sea literal; en este caso, será verdadera para cualquier instrucción de procesamiento que tenga un nombres igual al literal.

El selector \textbf{node()} es cierto para cualquier nodo de cualquier tipo.

A continuación, vamos a ver varios \textbf{ejemplos de uso} de los selectores de nodos.

\begin{itemize}
    \item Selector nombre cualificado:

    \textbf{/descendant-or-self::alumno/child::nombre}
    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carlos</nombre>
<nombre>Ana</nombre>
<nombre>Benito</nombre>
<nombre>Carmen</nombre>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Selector todos:

    \textbf{ /descendant-or-self::grupo/attribute::*}
        \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
orden="A"
orden="B"
orden="A"
orden="B"
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Selector text():

    \textbf{/descendant-or-self::apellidos/text()}
    \begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
Abad Álvarez
Benitez Bermúdez
Carmona Casado
Amate Antunez
Bellido Bravo
Cuesta Camacho
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item Selector comment():

    \textbf{ /descendant-or-self::colegio/child::comment()}
    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<!-- Datos del colegio -->
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item Selector node():

    \textbf{/descendant-or-self::grupo/child::node()}
    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<alumno codigo="342">
    <nombre>Ana</nombre>
    <apellidos>Abad Álvarez</apellidos>
    <anno_nac>2018</anno_nac>
    <nota_media>6.5</nota_media>
</alumno>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}
\end{itemize}

\subsubsection{Sintaxis Abreviada}
La abreviatura más importante es que el selector \textbf{child::} puede ser omitido en los pasos de localización. A efectos prácticos, \textbf{child} es el \textbf{eje por defecto}. Por ejemplo, un camino de localización \textbf{/colegio/curso}es la abreviatura de \textbf{child::colegio/child::curso}.

Hay también una abreviatura para atributos. \textbf{attribute::} puede abreviarse usando el carácter \textbf{@}. Por ejemplo, un camino \textbf{grupo::[@orden=``A'']} es la abreviatura de \textbf{child::grupo[attribute::orden=``A']} y por tanto selecciona hijos \textbf{grupo} con un atributo \textbf{orden} con el valor igual a \textbf{A}.

La doble barra (\textbf{//}) es una abreviatura de \textbf{descendant-or-self::node()}. Por ejemplo, \textbf{//alumno}, sería la correspondiente abreviatura de \textbf{/descendant-or-self::node()/child::alumno} y por tanto seleccionará cualquier elemento \textbf{alumno} en el documento. Otro ejemplo sería \textbf{curso//alumno} que es la abreviatura de \textbf{child::curso/descendant-or-self::node()/child::alumno} y por tanto seleccionará todos los descendientes \textbf{alumno} de hijos \textbf{curso}.

Otra abreviatura es el uso del punto (\textbf{.}) en lugar de \textbf{self::node()}. Esto es particularmente útil en conjunción con \textbf{//}. Por ejemplo, el camino de localización \textbf{.//grupo} es abreviatura de \textbf{self::node()/descendant-or-self::node()/child::grupo} y por tanto seleccionará todos los descendientes elementos \textbf{grupo} del nodo contexto.

Análogamente, un paso de localización con dos puntos (\textbf{..}) es la abreviatura de \textbf{parent::node()}. Por ejemplo, \textbf{../apellidos} es las abreviatura de \textbf{parend::node/child::apellidos} y por tanto seleccionará los hijos \textbf{apellidos} del nodo padre del nodo contexto.

En resumen, las principales abreviaturas son:

\begin{itemize}
    \item Si se omite el eje, estamos usando el eje \textbf{child} por defecto.
    \item Si usamos \textbf{@} estamos usando el eje \textbf{attribute}.
    \item (\textbf{//}): paso de localización \textbf{descendant-or-self::node()}
    \item (\textbf{..}): paso de localización \textbf{parent::node()}
    \item (\textbf{.}): paso de localización \textbf{self::node()}.
\end{itemize}

Algunos ejemplos del uso de abreviaturas son las siguientes:

\begin{itemize}
    \item \textbf{descendant-or-self::node()/child::nota\_media} se abrevia \textbf{//nota\_media}

    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<nota_media>6.5</nota_media>
<nota_media>8.25</nota_media>
<nota_media>4.75</nota_media>
<nota_media>7.5</nota_media>
<nota_media>2.25</nota_media>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item \textbf{child::colegio/child::curso/attribute::etapa} se abrevia \textbf{colegio/curso/@etapa)}
    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
etapa="ESO"
etapa="ESO"
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item \textbf{self::node()/descendant::telefono} se abrevia \textbf{./descendant::telefono}
     \begin{figure}[H]
     \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
         \scriptsize
         \begin{verbatim}
<telefono>900102030</telefono>
         \end{verbatim}
     \end{tcolorbox}
 \end{figure}
\end{itemize}

\subsubsection{Predicados}
Un \textbf{predicado} filtra un conjunto de nodos respecto a un eje y un selector de nodos para introducir un nuevo conjunto de nodos. El resultado de la expresión contenida en el predicado sera de tipo booleano. Los predicados dentro de corchetes (\textbf{[]}). Un paso de localización puede tener \textbf{cero o más} predicados en cascada. Si existe más de un predicado, estos se evaluarán de \textbf{izquierda a derecha}.

Si estamos evaluando un valor numérico, este será cierto si el número es igual a la posición contextual y se convertirá en falso de otro modo. Así, un camino de localización \textbf{grupo[2]} es equivalente a \textbf{grupo[position()=2]}.

Las \textbf{operaciones} que podemos usar en los predicados son las siguientes:

\begin{itemize}
    \item \textbf{Operadores de comparación}: =, !=, <, >, >=, <=
    \item \textbf{Operadores lógicos}: and, or
    \item \textbf{Operadores matemáticos}: +, -, *, div, mod
\end{itemize}

A continuación vemos \textbf{algunos ejemplos} del uso de predicados:

\begin{itemize}
    \item Primer Alumno de 2 ESO A:

     \textbf{//curso[@nivel="2"]/grupo[@orden="A"]/alumno[1]}
    \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<alumno codigo="534">
    <nombre>Alejando</nombre>
    <apellidos>Álvarez Amate</apellidos>
    <anno_nac>2018</anno_nac>
    <nota_media>5.25</nota_media>
</alumno>
            \end{verbatim}
        \end{tcolorbox}
        \end{figure}

        \item Apellidos de alumnos con nota superior a 8:

        \textbf{//alumno[nota\_media>8]/apellidos}

         \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
<apellidos>Benitez Bermúdez</apellidos>
<apellidos>Cuesta Camacho</apellidos>
<apellidos>Camacho Camacho</apellidos>
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}

        \item Nombres de alumnos que no nacieron en el 2017 y tienen media superior a 7:

        \begin{itemize}
            \item  \textbf{//alumno[anno\_nac!=2017][nota\_media>7]/nombre}
            \item  \textbf{//alumno[anno\_nac!=2017 and nota\_media>7]/nombre}
        \end{itemize}

         \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
<nombre>Beatriz</nombre>
<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carmen</nombre>
                \end{verbatim}
            \end{tcolorbox}
        \end{figure}
\end{itemize}

\subsubsection{Funciones}

XPath nos ofrece un conjunto de funciones para poder realizar diferentes operaciones y evaluar expresiones. Todas las implementaciones de XPath deben incluir las \textbf{funciones} que vamos a ver en esta sección y que podremos usar para \textbf{evaluar expresiones}.

Vamos a especificar cada función con un prototipo de función, que indica el tipo devuelto, el nombre de la función y el tipo de argumentos, que pueden ser número, string, booleano o node-set. Si un tipo de argumento es seguido de un símbolo de interrogación indica que el argumento es opcional, en otro caso, el argumento es obligatorio.

Esta \textbf{funciones} se pueden clasificar en cuatro grupos y son las siguientes:

\begin{itemize}
    \item \textbf{Funciones de Conjuntos de Nodos}: son funciones que nos permiten trabaja con nodos y realizar diferentes operaciones con nodos. Estas funciones son las siguientes:

    \begin{itemize}
        \item \textbf{\textit{number} last()}: devuelve el número total de nodos del contexto seleccionado.
        \item \textbf{\textit{number} position()}: devuelve la posición del nodo actual dentro de los nodos del contexto seleccionado. Esta posición de enumera desde el 1, y no desde el 0 como en otros lenguajes de programación.
        \item \textbf{\textit{número} count(\textit{nodo-set})}: devuelve el número de nodos del conjunto de nodos pasado como argumento.
        \item \textbf{\textit{string} name(\textit{nodo-set?})}: devuelve una cadena de caracteres con el nombre cualificado de un nodo del conjunto de nodos que se le pasa como argumento, formado por una URI del espacio de nombres y el nombres local. Si no se le pasa ningún argumento, tomará el nodo contexto como argumento. Si no se declaran espacios de nombres devolverá el mismo resultado que la función local-name().
        \item \textbf{\textit{string} loca-name(\textit{node-set?})}: devuelve el nombres local, sin URI, de un nodo del conjunto de nodos pasado como argumento. Si no se le pasa ningún argumento tomará los nodos contexto como argumento. Si no se declaran espacios de nombres dará el mismo resultado que la función name().
        \item \textbf{\textit{string} namespace-uri(\textit{nodo-set?})}: devuelve el URI del espacio de nombres, sin el nombres local, de un nodo del conjunto de nodos que se le pasa como argumento. Si no se le pasa ningún parámetro, tomará los nodos contexto como argumentos.
        \item \textbf{\textit{node-ser} id(\textit{object})}: selecciona elementos mediante su identificador único. Los nodos deben ser declarados de tipo ID en DTD o el XML Schema correspondiente.
    \end{itemize}

    \item \textbf{Funciones de Cadenas de Caracteres}: son funciones que nos permiten trabajar con cadenas de caracteres, permitiéndonos buscar subcadenas, hacer concatenaciones, etc... Esta funciones son:
    \begin{itemize}
        \item \textbf{\textit{string} string(\textit{object?})}: convierte un objeto en cadena de caracteres. Si no se especifica el objeto toma un conjunto de nodos con el nodo contexto como único miembro.
        \item \textbf{\textit{string} concat(\textit{string}, \textit{string}, \textit{string*})}: devuelve la concatenación de las cadenas pasadas como argumento.
        \item \textbf{\textit{boolean} starts-with(\textit{string}, string)}: devuelve verdadero si la primera cadena del argumento comienza con la segunda cadena del argumento. Devuelve falso en caso contrario.
        \item \textbf{\textit{boolean} contains(\textit{string, string})}: devuelve verdadero si la primera cadena de los argumentos contiene a la segunda y falso en caso contrario.
        \item \textbf{\textit{string} substring-before(\textit{string}, \textit{string})}: devuelve las subcadena, de la primera cadena del argumento, que precede a la aparición de la cadena pasada como segundo argumento, o la cadena vacía si la cadena no aparece en ésta. Si el argumento es la cadena vacía, entonces devuelve una cadena vacía.
        \item \textbf{\textit{string} substring-after(\textit{string}, \textit{string})}: devuelve la subcadena, de la primera cadena del argumento, que sigue a la aparición de la segunda cadena pasada como argumento o la cadena vacía en caso de que esta no aparezca en la primera cadena. Si el argumento es la cadena vacía, devolverá una cadena vacía.
        \item \textbf{\textit{string} substring(\textit{string}, \textit{number}, \textit{number?})}: devuelve la subcadena que comienza en la posición indicada por el segundo argumento y con la longitud indicada en el tercer argumento. Si no es especifica la longitud, devuelve la cadena que comienza en la posición especificada y continúa hasta el final de la cadena. Se considera que cada carácter tiene una posición numérica dentro de la cadena, comenzado a contar desde 1.
        \item \textbf{\textit{number} string-length(\textit{string?})}: devuelve el número de caracteres de la cadena indicada como argumento. Si se omite el argumento, toma por defecto el nodo contexto convertido en cadena de caracteres.
        \item \textbf{\textit{string} normalize-space(\textit{string?})}: devuelve la cadena argumento con el espacio en blanco normalizado, es decir, elimina los espacios que se encuentra al principio y final de la cadena, además de sustituir las secuencias de espacios en blanco por uno solo. Si se omite el argumento, toma por defecto el nodo contexto convertido en cadena de caracteres.
        \item \textbf{\textit{string} translate(\textit{string}, \textit{string}, \textit{string})}: devuelve la cadena del primer argumento con las apariciones indicadas en el segundo argumento sustituidas por las indicadas en el tercer argumento.
    \end{itemize}

    \item \textbf{Funciones Lógicas}: nos permiten realizar diferentes operaciones booleanas sobre diferentes datos.
    \begin{itemize}
        \item \textbf{\textit{boolean} boolean(\textit{object})}: convierte el objecto argumento al tipo booleano.
        \item \textbf{\textit{boolean} not(\textit{boolean})}: devuelve verdadero si su argumento es falso y falso en caso contrario.
        \item \textbf{\textit{boolean} true()}: devuelve el valor true.
        \item \textbf{\textit{boolean} false()}: devuelve el valor false.
        \item \textbf{\textit{boolean} lang(\textit{string})}: devuelve verdadero o falso dependiendo si el lenguaje del nodo contextual, tal como se especifica por el atributo \textit{xml:lang}, es el mismo o un sublenguaje del especificado como argumento.
    \end{itemize}

    \item \textbf{Funciones Matemáticas}: son funciones que nos permiten realizar diferentes operaciones matemáticas. Estas son:
    \begin{itemize}
        \item \textbf{\textit{number} number(\textit{object?})}: convierte el argumento al tipo numérico. Si se omite el argumento, toma por defecto un conjunto de nodos con el nodo contexto como único elemento.
        \item \textbf{\textit{number} sum(\textit{node-set})}: devuelve la suma, a lo largo de todos los nodos del conjunto de nodos del argumento, resultando de convertir los valores de cadenas de caracteres de los distintos nodos en números.
        \item \textbf{\textit{number} floor(\textit{number})}: devuelve el mayor número entero que sea igual o menor que el número pasado como argumento.
        \item \textbf{\textit{number} ceiling(\textit{number})}: devuelve el menor número entero que sea igual o mayor que el número pasado como argumento.
        \item \textbf{\textit{number} round(\textit{number})}: devuelve el número entero más cercano al pasado como argumento.
    \end{itemize}
\end{itemize}

A continuación vamos a ver \textbf{algunos ejemplos} de las funciones que hemos visto:

\begin{itemize}
    \item Número total de alumnos nacidos en 2018:

    \textbf{count(//alumno[anno\_nac=2018])}

    \begin{figure}[h]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
8
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Nombre de los primeros alumnos de cada grupo: \textbf{//alumno[1]/nombre}
    \begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<nombre>Ana</nombre>
<nombre>Ana</nombre>
<nombre>Alejando</nombre>
<nombre>Ana</nombre>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item Alumnos que su nombre comience por 'Al':

    \textbf{//alumno[starts-with(nombre,"Al")]}
    \begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
<alumno codigo="534">
    <nombre>Alejando</nombre>
    <apellidos>Álvarez Amate</apellidos>
    <anno_nac>2018</anno_nac>
    <nota_media>5.25</nota_media>
</alumno>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item Normalización de una cadena:

    \textbf{normalize-space(" Esto    es      una   prueba  ")}
    \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
Esto es una prueba
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

    \item Alumnos que no se llaman 'Carmen':

    \textbf{//alumno[not(nombre="Carmen")]/nombre}
     \begin{figure}[H]
        \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
            \scriptsize
            \begin{verbatim}
<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carlos</nombre>
<nombre>Ana</nombre>
<nombre>Benito</nombre>
<nombre>Alejando</nombre>
            \end{verbatim}
        \end{tcolorbox}
    \end{figure}

    \item Suma de las notas de los alumnos de 1 ESO A:

    \textbf{sum(//curso[@nivel="1"]/grupo[@orden="A"]/alumno/nota\_media)}
     \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
19.5
        \end{verbatim}
    \end{tcolorbox}
    \end{figure}
\end{itemize}

\subsection{Estrategias de Uso}
A la hora de crear sentencias de XPath hay ciertas estrategias que podemos seguir para obtener los resultados deseados de una forma más precisa. Ademas hay situaciones concretas que se resuelven de mejor manera usando un determinado patrón.

A continuación veremos las principales estrategias que nos ayudarán a crear consultas eficientes.

\subsubsection{Posicionamiento de Predicados}

     Hay ciertas \textbf{estrategias} que podemos tener en cuenta a la hora de \textbf{posicionar los predicados} dentro de un paso de localización. Vamos a ver un ejemplo para que quede más claro como posicionar éstos.

     Imaginemos que queremos saber el \textbf{grupo del alumno que se apellida 'Bellido Bravo'}.


     Primero, buscamos en la estructura de nuestro documento XML la posición del atributo y del elemento que se indica en el enunciado. Para ello, podremos usar las siguientes sentencias:

         \begin{figure}[h]
             \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                 \scriptsize
                 \begin{verbatim}
colegio/curso/grupo/alumno/apellidos

colegio/curso/grupo/@orden
\end{verbatim}
             \end{tcolorbox}
         \end{figure}

        A continuación, sabemos que el resultado debe ser el número de orden, es decir, nuestro camino de localización debe acabar en ese atributo. Este será nuestro punto de partida. Probamos por lo tanto la consulta \textbf{colegio/curso/grupo/@orden)} antes de filtrar el apellido.
        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
orden="A"
orden="B"
orden="A"
\end{verbatim}
            \end{tcolorbox}
        \end{figure}

        Para posicionar el predicado podemos utilizar varias estrategias. Una de ellas puede ser \textbf{poner el predicado} en el \textbf{primer elemento padre común}, que en nuestro ejemplo sería grupo. Es decir:
         \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize

\begin{verbatim}
colegio/curso/grupo[alumno/apellidos="Bellido Bravo"]
\end{verbatim}
            \end{tcolorbox}
        \end{figure}

        Si probamos esta consulta, obtendremos el grupo que buscamos, pero nos devuelve todo el grupo, no solamente su orden.

        Podemos \textbf{mezclar ambos caminos de localización} en el elemento común que habíamos determinado antes, obtendremos el resultado que queremos. Es decir, usaremos el camino de localización del atributo que queremos mostrar con el predicado que situaremos en el elemento común.
        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
                \begin{verbatim}
colegio/curso/grupo[alumno/apellidos="Bellido Bravo"]/@orden
\end{verbatim}
            \end{tcolorbox}
        \end{figure}
        Simplificando con doble barra en la parte inicial quedaría:

        \begin{figure}[H]
            \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
                \scriptsize
\begin{verbatim}
 //grupo[alumno/apellidos="Bellido Bravo"]/@orden
\end{verbatim}
            \end{tcolorbox}
        \end{figure}

        Cuando trabajamos con información en distintos niveles de nuestra estructura \textbf{es importante no utilizar} la \textbf{doble barra} (//) en mitad de los caminos de localización, ya que la \textbf{búsqueda se reiniciará} desde el \textbf{elemento raíz} y no con el predicado establecido. Por ejemplo, si sustituimos la expresión anterior por \textbf{//grupo[//apellidos="Bellido Bravo"]/@orden}, el resultado obtenido no será el deseado, como vemos a continuación.

     \begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
 orden="A"
 orden="B"
 orden="A"
 orden="B
\end{verbatim}
    \end{tcolorbox}
\end{figure}

    Vemos también la utilidad de utilizar el operador nodo actual (\textbf{.}) cuando necesitamos \textbf{bajar niveles} y del operador nodo padre (\textbf{..}) cuando necesitamos \textbf{subir niveles}.

\subsubsection{Consultas Anidadas}
En ocasiones necesitamos realizar \textbf{varias consultas anidadas}, es decir, que necesitemos el resultado de una consulta para realizar la segunda consulta.

Por ejemplo, si queremos saber la nota media de los alumnos/as que tienen una nota media menor que la del alumno que se apellida 'Abad Álvarez', tendremos que hacer \textbf{dos consultas}.

La \textbf{primera consulta} para saber la nota media de 'Abad Álvarez' y \textbf{otra} para saber los alumnos/as que tienen una nota media inferior a un número cualquiera, por ejemplo 5. Estas consultas podrían ser las siguientes:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
//alumno[apellidos="Abad Álvarez"]/nota_media

Resultado:

<nota_media>6.5</nota_media>


//alumno[nota_media < 5]/nota_media

Resultado:

<nota_media>4.75</nota_media>
<nota_media>2.25</nota_media>
<nota_media>4</nota_media>
<nota_media>2.5</nota_media
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Ahora tendremos que mezclar las dos consultas y en lugar del número 5 de antes poner la subconsulta que nos muestra la nota de 'Abad Ávarez', dando como resultado la siguiente consulta:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
        \begin{verbatim}
//alumno[number(nota_media) < //alumno[apellidos="Abad Álvarez"]/nota_media ]/nota_media

Resultado:

<nota_media>4.75</nota_media>
<nota_media>2.25</nota_media>
<nota_media>5.25</nota_media>
<nota_media>4</nota_media>
<nota_media>2.5</nota_media>
        \end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsubsection{Evitar Elementos Repetidos}
A veces puede que queramos mostrar todos los resultados de un determinado tipo pero sin que salgan resultados repetidos. Gracias al eje \textbf{preceding} podemos hacerlo de forma sencilla. Recordad que este eje no tiene abreviación por lo que su notación es la completa.

En primer lugar, mostramos \textbf{todos los nombres de los alumnos}:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
//alumno/nombre

Resultado:

<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carlos</nombre>
<nombre>Ana</nombre>
<nombre>Benito</nombre>
<nombre>Carmen</nombre>
<nombre>Alejando</nombre>
<nombre>Benito</nombre>
<nombre>Carmen</nombre>
<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carmen</nombre>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Si ahora quisiéramos que se nos mostrara el resultado sin los nombres duplicados, podemos añadir el eje \textbf{preceding} junto con la función \textbf{not()} obteniendo la consulta y resultados siguientes:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
//alumno[not(nombre=preceding::nombre)]/nombre

Resultado:

<nombre>Ana</nombre>
<nombre>Beatriz</nombre>
<nombre>Carlos</nombre>
<nombre>Benito</nombre>
<nombre>Carmen</nombre>
<nombre>Alejando</nombre>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\section{XSL Transformations (XSLT)}
El \textbf{lenguaje de transformaciones XSL} (Extensible Stylesheet Language Transformations ó XSLT) es una recomendación aprobada por el consorcio W3C, cuya versión 1.0 fue aprobada el 16 de Noviembre de 1999. El mismo día que la recomendación XPath 1.0.

Gracias a este lenguaje, los procesadores XSLT pueden transformar un documento XML en otros documentos XML, HTML o de texto plano con estructuras y contenido diferentes al original. Esta transformación se realiza gracias al uso de \textbf{hojas de estilo} (\textbf{xsl:stylesheet}). El lenguaje XSLT define la sintaxis y semántica de estas hojas de estilo.

Una \textbf{transformación} expresada en XSLT describe reglas para transformar un árbol de nodos origen en un árbol de nodos resultado. La transformación se logra asociando patrones definidos en la plantilla (\textbf{xsl:template}). Un \textbf{patrón}, expresado mediante XPath, se compara con los elementos de origen.  Si cumple con alguna de las reglas de la plantilla, éstos pasan a formar parte del árbol de nodo resultado.

Es importante resaltar que el \textbf{árbol de nodos resultado} es distinto del árbol de nodos origen. Además la estructura del árbol de nodos resultado puede ser completamente diferentes al de origen. Al construir el árbol resultado los elementos del árbol origen se pueden reordenar, filtrar y agrupar en una estructura arbitraria.

\subsection{Hojas de Estilo XSLT}
Para crear el árbol de nodos resultado debemos crear una \textbf{hoja de estilo}, en la que podremos usar \textbf{diferentes tipos de elementos}, siendo estos:

\begin{itemize}
    \item \textbf{Elementos del espacio de nombres} asociados a la URI \textbf{http://www.w3.org/1999/XSL/Transform}. Se suele emplear el prefijo \textbf{xsl} y son las instrucciones que usa el el lenguaje XSLT. Algunos ejemplos son: \textbf{xsl:stylesheet}, \textbf{xsl:template}, \textbf{xsl:value-of}, \textbf{xsl:for-each}, etc...

    \item \textbf{Elementos de extensión} que se utilizan como mecanismos implementados por diferentes desarrolladores para aportar funcionalidades extra. Cada desarrollador determinará su uso. No los estudiaremos en esta unidad.

    \item \textbf{Elementos de resultado literal} (LRE), que son elementos que se añaden al árbol de nodos resultado y que no pertenecen al espacio de nombres xsl. Por ejemplo, cuando incluimos elementos HTML o texto entre la información obtenida del documento XML.
\end{itemize}

El \textbf{lenguaje XSLT no especifica} como se \textbf{asocia} una hoja de estilo con un documento XML. Para esto, se usa un mecanismo propio de XML, las \textbf{instrucciones de procesamiento}. Debe tenerse en cuenta que algunos navegadores, por seguridad, bloquean estas instrucciones de procesamiento. Un ejemplo de documento XML asociado con una hoja de estilo lo podemos ver en la siguiente figura.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{xml-hoja-estilo.png}
    \caption{Documento XML asociado con una hoja de estilo}
\end{figure}

En este ejemplo, se utiliza la instrucción de procesamiento \textbf{xml-stylesheet}, indicando en el atributo \textbf{type} el tipo de archivo con la nomenclatura MIME (\textbf{text/xml} o \textbf{text/xsl}) y en el atributo \textbf{ref}, la ubicación de la hoja de estilo.

\begin{figure}[h]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
                 <?xml-stylesheet type="text/xsl" href="colegio.xsl"?>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Esta instrucción de procesamiento no es obligatoria, ya que al ejecutar el procesador XSLT se le puede indicar	como parámetros los documentos XML y XSL sobre los que queremos realizar la transformación.

Para \textbf{crear una hoja de estilos} usaremos la instrucción \textbf{xsl:stylesheet}, necesitando declarar el espacio de nombres de XSLT que se corresponde con la URI \textbf{http://www.w3.org/1999/XSL/Transform}. Se suele asociar este espacio de nombres con el \textbf{prefijo xsl:}. Además, esta instrucción tiene una atributo obligatorio, \textbf{version}, en el que indicaremos la versión del lenguaje XSLT en la que vamos a codificar nuestra hoja de estilos.

Normalmente, cada hoja de estilos se creará en un \textbf{archivo de texto plano} con las extensión \textbf{.xsl}. Como dijimos anteriormente, el lenguaje XSLT es derivado de XML, por lo que será necesario incluir en la primera línea el prólogo XML. Posteriormente declararemos nuestra hoja de estilos como vemos en el siguiente código:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
...
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsubsection{Simplificación de Hojas de Estilo}
XSLT permite una \textbf{sintaxis simplificada} para las hojas de estilo que consten con una plantilla para el nodo raíz. La sintaxis simplificada permite omitir el elemento \textbf{xsl:stylesheet} cuando se trate de un\textbf{elemento de contenido literal}. Además, en vez de declarar una plantilla \textbf{xsl:template}, esta se sustituirá directamente por dicho elemento de contenido literal. Desde este contenido literal se podrá acceder a las instrucciones del espacio de nombres \textbf{xsl:} como si se hubiera seleccionado como patrón el nodo raíz del árbol de nodos origen.

En este caso de simplificación, el elemento literal debe tener el atributo \textbf{xsl:version}. Para poder usar este atributo, así como las demás instrucciones del espacio de nombres \textbf{xsl:} se deberá añadir dicho espacio de nombres al citado elemento literal. Este elemento que actúa como plantilla no podrá contener instrucciones de nivel superior.

En el siguiente ejemplo, tenemos el documento \textbf{colegio.xml}, al que vamos a realizar una transformación.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="html"/>
    <xsl:template match="/">
        <html>
            <head>
               <title>Colegio Cervantes</title>
            </head>
            <body>
               <h1>Nombre del colegio: <xsl:value-of select="colegio/nombre"/></h1>
               <p>Teléfono: <xsl:value-of select="colegio/telefono"/></p>
               <p>Suma de notas: <xsl:value-of select="sum(//nota_media)"/></p>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Si simplificamos este documento, el resultado sería el siguiente:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <head>
        <title>Colegio Cervantes</title>
    </head>
    <body>
        <h1>Nombre del colegio: <xsl:value-of select="colegio/nombre"/></h1>
        <p>Teléfono: <xsl:value-of select="colegio/telefono"/></p>
        <p>Suma de notas: <xsl:value-of select="sum(//nota_media)"/></p>
    </body>
</html>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

En esta simplificación el \textbf{elemento de contenido literal} sería el elemento \textbf{html}, que contiene la declaración  del espacio de nombres \textbf{xslnm} del lenguaje XSLT y el atributo obligatorio \textbf{version}. Posteriormente, haciendo uso del prefijo \textbf{xsl:}, podemos utilizar instrucciones que no sean de nivel superior como \textbf{xls:value-of}.

\subsection{Elementos XSLT de Nivel Superior}
Si consideramos un documento XSLT como un documento XML, el elemento raíz será \textbf{xsl:stylesheet} ó \textbf{xsl:transform}. Los \textbf{elementos de nivel superior} son aquellos del espacio de nombres \textbf{xsl:} que son hijos directos de alguno de estos dos elementos. Tiene una tratamiento especial ya que su ámbito de aplicación es toda la hoja de estilos que estamos declarando.

Los elementos de nivel superior \textbf{más utilizados} son:

\begin{itemize}
    \item \textbf{xsl:template}
    \item \textbf{xsl:variable} y \textbf{xsl:param}
    \item \textbf{xsl:output}
\end{itemize}

También tenemos otros elementos de nivel superior que aunque, son menos utilizados, es conveniente que los conozcamos ya que cada uno tiene una utilizada muy específica. Estos son:

\begin{itemize}
    \item \textbf{xsl:import} y \textbf{xsl:include}: sirven para añadir contenido a las hojas de estilo que estamos desarrollando. Los contenidos añadidos mediante \textbf{xsl:import} tiene una menor preferencia que los desarrollados en nuestra hoja de estilo. La preferencia de los contenidos añadidos con \textbf{xsl:include} es la misma que los desarrollados en nuestra hoja de estilos. Ambos elementos tiene una atributo \textbf{href} que indica donde se encuentran los contenidos a añadir.

    \item \textbf{xsl:strip-space} y \textbf{xsl:preserve-space}: sirve para indicar al procesador XSL como deber actuar al normalizar los espacios en blanco.

    \item \textbf{xsl:key}: sirve para declarar un elemento como clave de forma que pueda emplearse como los tipos de dato ID, IDREF y IDREFS. Declara una clave con nombres que se puede usar en cualquier lado de la hoja de estilo con la función \textbf{key()}.

    \item \textbf{xls:decimal-format}: define el formato que se empleará para convertir los números en cadenas de caracteres.

    \item \textbf{xsl:namespace-alias}: sirve para definir un prefijo alternativo para un espacio de nombres.

    \item \textbf{xsl:attribute-set}: se utiliza para crear grupos de atributos que se pueden reutilizar en los elementos \textbf{xsl:element} y \textbf{xsl:param}.
\end{itemize}

Estos elementos de nivel superior pueden aparecer varias veces o no aparecer en el documento. El orden de aparición no es relevante salvo para \textbf{xsl:import} que debe aparecer en primer lugar. Además, los elementos de nivel superior no pueden usarse dentro de otros elementos excepto \textbf{xsl:variable} y \textbf{xsl:param}.

\subsubsection{xsl:template}
Las plantillas (\textbf{xsl:template}) constan de dos partes: \textbf{un patrón}, expresado mediante XPath en el atributo \textbf{match}, que se compara con los nodos del árbol origen, y \textbf{unas instrucciones} que se aplicarán a los nodos seleccionados.

Con la aplicación de estas instrucciones y la incorporación de los elementos de contenido literal, podremos ir construyendo los nodos que necesitemos para el árbol de nodos resultado. Esto permite que la hoja de estilo sea aplicable a distintos documentos XML siempre que éstos tengan una misma estructura.

El \textbf{atributo mathc} es obligatorio a no ser que existe el atributo \textbf{name}. El atributo \textbf{name} sirve para hacer referencia a una plantilla mediante la instrucción \textbf{xsl:call-template}. El valor del atributo \textbf{match} no puede incluir el uso de variables.

En una \textbf{hoja de estilo} podemos tener \textbf{más de una plantilla}. La ejecución de las plantillas tiene una serie de abreviaciones que si no tenemos en cuenta puede llegar a confundir. Cada plantilla se puede hacer coincidir con un determinado nodo de nuestra estructura. Algunos ejemplos de \textbf{constricciones plantilla} son los siguientes:

\begin{itemize}
    \item \textbf{Plantilla vacía}: si tenemos una plantilla que se corresponde con un nodo de nuestra estructura y es plantilla no tiene contenido entonces al recorrer los nodos no mostrará nada.
    \item \textbf{Nodos sin plantillas asociadas}: si en un determinado nodo de nuestra construcción no creamos plantilla, por defecto, ese nodo mostrará el contenido textual de ese nodo determinado, pero no mostrará el valor de sus atributos.
\end{itemize}

En el siguiente ejemplo tenemos una plantilla asociado a los nodos de tipo 'alumno', pero es plantilla esta vacía, por lo que al recorres estos nodos mostrará lo que contiene la plantilla, es decir, nada. Además, en nuestra estructura, tenemos otros nodos que no tienen correspondencia con el atributo \textbf{match} de ninguna plantilla, por lo que mostrará el contenido textual de esos nodos sin plantilla.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml"/>
    <xsl:template match="//alumno">
        <!-- No hacer nada -->
    </xsl:template>
    </xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

El resultado de esta transformación será:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>

Cervantes
900102030
\end{verbatim}
    \end{tcolorbox}
\end{figure}

En ocasiones cuando tenemos \textbf{más de una plantilla} vemos que \textbf{no funciona como esperábamos}. Por ejemplo, si tenemos una plantilla para 'alumno' que nos muestra el 'nombre' y otra plantilla para 'apellidos' que nos muestra el propio elemento '.', vemos que no funciona correctamente.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml"/>

    <xsl:template match="//alumno">
        <xsl:value-of select="nombre"/>
    </xsl:template>

    <xsl:template match="//apellidos">
        <xsl:value-of select="."/>
    </xsl:template>
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

El resultado, no es el que esperamos, como vemos a continuación:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>

Cervantes
900102030

Ana
Beatriz
Carlos

Ana
Benito
Carmen
\end{verbatim}
    \end{tcolorbox}
\end{figure}

EL \textbf{motivo} de este comportamiento es el \textbf{recorrido del árbol origen}. Cuando recorremos en la primera plantilla los elementos 'alumno' podemos mostrar perfectamente su nombre. Pasamos al siguiente 'alumno' y volvemos a mostrar el 'nombre', y así hasta el último elemento 'alumno'. Cuando vamos a aplicar la segunda plantilla ya hemos \textbf{terminado de recorrer} todo el árbol de nodos origen y no podemos volver atrás. Para que esto funcione, debemos usar la instrucción \textbf{xsl:apply-templates}.

Sabiendo esto, entenderemos porque el siguiente ejemplo, si mostraría correctamente ambos valores, nombre y apellidos, ya que los recorre cuando nos encontramos en el nodo alumno.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml"/>

    <xsl:template match="//alumno">
        <xsl:value-of select="nombre"/>
        <xsl:value-of select="apellido"/>
    </xsl:template>

</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Una \textbf{forma habitual de simplificar} el \textbf{uso de plantillas} es usar una única plantilla que accede al elemento raíz. Dentro de esta única plantilla podemos utilizar XPath para seleccionar las partes del documento XML que queramos e instrucciones de recorrido, como \textbf{xsl:for-each} y selección \textbf{xsl:if} para construir la estructura que deseemos. Por ejemplo, la siguiente estructura con llamadas anidadas mediante el uso de plantillas:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />
    <xsl:strip-space elements="*"/>
    <xsl:template match="/">
        <xsl:apply-templates select="//alumno"/>
    </xsl:template>
    <xsl:template match="//alumno">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="//anno_nac">
        <xsl:text>privado</xsl:text>
    </xsl:template>
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

Se puede simplificar a una sola plantilla con expresiones XPath e instrucciones \textbf{xsl:for-each} y \textbf{xsl:if}, como vemos a continuación.

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />
        <xsl:template match="/">
            <xsl:for-each select="//alumno">
                <xsl:value-of select="nombre"/>
                <xsl:value-of select="apellidos"/>
                <xsl:text>privado</xsl:text>
                <xsl:value-of select="nota_media"/>
            </xsl:for-each>
        </xsl:template>
</xsl:stylesheet>
\end{verbatim}
\end{tcolorbox}
\end{figure}

El resultado de ambas hojas de estilo es el mismo:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
AnaAbad Álvarezprivado6.5BeatrizBenitez Bermúdezprivado8.25 ...
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsubsection{xsl:variable y xsl:param}
Una \textbf{variable} es un nombre que se vincula con un valor. El valor de la variable puede ser de distintos tipos que devuelven las expresiones y funciones XPath. Hay dos elementos que utilizan esta vinculación de valores, \textbf{xsl:variable} y \textbf{xsl:param}.

Ambos elementos tienen un atributo obligatorio \textbf{name} en el cual hay que especificar el nombre de la variable, en el momento de utilizar su contenido, con un símbolo \textbf{\$} delante.  El otro atributo de estos elementos es \textbf{select}, que si se especifica en una expresión XPath almacenará su valor en una variables.

La \textbf{diferencia entre ambos} elementos es que el valor de \textbf{xsl:param} es un valor predeterminado que se usa normalmente pero que puede ser sobreescrito cuandoa se invoca una plantilla o una hoja de estilo mediante el elemento \textbf{xsl:with-param}, que tenga el mismo nombre (\textbf{name}) pero un valor distinto al predeterminado.

A continuación vemos unos ejemplos del uso de estos elementos:

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text"/>
    <xsl:template match="/">

        <xsl:variable name="mensaje" >Hola mundo</xsl:variable>
        <xsl:value-of select="$mensaje" />
        <xsl:text>&#10;</xsl:text>
        <xsl:variable name="nombre_cole" select="colegio/nombre" />
        <xsl:value-of select="$nombre_cole"/>

    </xsl:template>
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text"/>
    <xsl:template match="/">

        <xsl:param name="mensaje" >Hola mundo</xsl:param>
        <xsl:value-of select="$mensaje" />
        <xsl:text>&#10;</xsl:text>
        <xsl:param name="nombre_cole" select="colegio/nombre" />
        <xsl:value-of select="$nombre_cole"/>

    </xsl:template>
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsubsection{xsl:output}
Con esta instrucción especificamos el \textbf{formato de salida deseado}. Esta instrucción se puede omitir ya que el procesador XSLT devolverá el resultado como secuencias de caracteres. El uso de este elemento nos facilita poder especificar características de salida. Los \textbf{atributos más usados} son:

\begin{itemize}
    \item \textbf{method}: especifica el formato de salida. Los valores que puede tomar este atributo son: \textbf{xml}, \textbf{html} y \textbf{text},
    \item \textbf{version}: especifica la versión del método de salida.
    \item \textbf{indent}: especifica si la salida tiene que ser indentada o no. Los valores que puede tomar son: \textbf{yes} y \textbf{no}.
    \item \textbf{encoding}: para especificar la codificación.
    \item \textbf{standalone}: especifica si el documento tendrá relación con otros documentos. Los posibles valores que puede tomar son: \textbf{yes} y \textbf{no}.
    \item Otros atributos menos usados son: \textbf{media-type}, \textbf{doctype-system}, \textbf{doctype-public}, \textbf{omit-xml-declaration} y \textbf{cdata-section-elements}
\end{itemize}

\begin{figure}[H]
    \begin{tcolorbox}[sharp corners, colback=yellow!30, colframe=white!20]
        \scriptsize
\begin{verbatim}
xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="html" version="5.0" encoding="UTF-8" indent="yes" />
....
</xsl:stylesheet>
\end{verbatim}
    \end{tcolorbox}
\end{figure}

\subsection{Otros Elementos de XSLT}
Además de los elementos que hemos visto en la sección anterior, que son los más usados, XSLT tiene otros elementos que nos permiten realizar diferentes acciones sobre el documento y que podemos clasificar en tres grupos principales:

\begin{itemize}
    \item Intrucciones de manipulación de plantillas:
    \begin{itemize}
        \item \textbf{xsl:apply-templates}
        \item \textbf{xsl:call-template}
        \item \textbf{xsl:with-param}
    \end{itemize}

    \item Intrucciones de control de flujo:
    \begin{itemize}
        \item \textbf{xsl:for-each}
        \item \textbf{xsl:if}
        \item \textbf{xsl:choose}
        \item \textbf{xsl:when}
        \item \textbf{xsl:otherwise}
        \item \textbf{xsl:sort}
    \end{itemize}

    \item Intrucciones de de salida:
    \begin{itemize}
        \item \textbf{xsl:value-of}
        \item \textbf{xsl:number}
        \item \textbf{xsl:element}
        \item \textbf{xsl:attribute}
        \item \textbf{xsl:text}
        \item \textbf{xsl:comment}
        \item \textbf{xsl:processing-instruction}
    \end{itemize}
\end{itemize}

Todas estas instrucciones las veremos con más detalle en los siguientes puntos, pero hay otras, que aunque no las veremos en profundidad, si conviene que sepamos de su existencia, que son las siguientes:

\begin{itemize}
    \item \textbf{xsl:copy}: con esta instrucción podemos añadir el nodo actual al árbol de nodos destino. Al copiar un nodo se copian sus nodos espacios de nombres pero no sus atributos ni sus elementos hijos. Este elemento puede usar el atributo \textbf{use-attribute-sets} para añadir conjuntos de atributos declarados anteriormente. Solo se puede usar esta instrucción con nodos que puedan tener atributos o elementos hijos, es decir, el nodo raíz y nodos elementos.

    \item \textbf{xsl:copy-of}: con esta instrucción podemos añadir un fragmento completo del árbol de nodos al árbol de destino. No es necesario convertir ese fragmento a cadenas de caracteres. Tiene una \textbf{atributo obligatorio} llamado \textbf{select} donde debe indicarse, mediante una expresión XPath, el fragmento de árbol a copiar. Cuando se copia un elemento se copia el propio elemento y también sus nodos atributo, sus nodos espacio de nombres y sus elementos hijo.

    \item \textbf{xsl:apply-imports}: sirve para indicar cuando realizar una importación para sobreescribir una regla de plantillas.

    \item \textbf{xsl:message}: se utiliza para enviar mensajes al procesador XSLT. Tiene un atributo, \textbf{terminate}, que puede tomar los valores \textbf{yes} y \textbf{no}, y que se utiliza para indicar al procesador XSLT que interrumpa el procesamiento de la hoja de estilos.

    \item \textbf{xsl:fallback}: su función es establecer una secuencia ordenada de ejecución.
\end{itemize}

\subsubsection{Instrucción de Manipulación de Plantillas}

% Apéndice -------------------------------------------------------------------------------------
\appendix

% Change appendix display options
\titleformat{\chapter}{\bfseries\Huge}{\thechapter.}{1ex}{}

\chapter{Anexos Tema 3}

\section{Servidores}
Un \textbf{servidor}, como la misma palabra indica, es un ordenador o máquina informática que esta al ``servicio'' de otras máquinas u ordenadores, llamadas \textbf{clientes}, y que suministran a estos todo tipo de información.

Este tipo de relación entre diferentes dispositivos genera uno de los esquemas mas empleados y en el que se basa gran parte de internet, como es el esquema \textbf{cliente-servidor}, del cual podemos ver un ejemplo en la siguiente figura.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.60]{cliente-servidor.png}
    \caption{Arquitectura Cliente-Servidor}
\end{figure}

Como vemos en este esquema, tenemos una máquina servidora que se comunica con diferentes clientes, todos demandando algún tipo de información. Esta información puede ser desde archivos de texto, audio, vídeo, imágenes, programas, consultas a bases de datos, etc...

Los \textbf{servidores} suelen ser \textbf{más potentes} que un ordenador normal, sobre todo en lo relativo  \textbf{capacidad de almacenamiento} como de \textbf{memoria principal}, ya que suelen dar servicios a muchos clientes, aunque esto también depende de las necesidades, ya que si vamos a tener pocos clientes, podemos tener un servidor con menores prestaciones.

Existen muchos \textbf{tipos de servidores}, como servidores de corre, proxy, web, de bases de datos, de aplicaciones, etc...

\subsection{Servidores Web}
Un \textbf{servidor Web} se encarga de almacenar documentos HTML, imágenes, vídeos, documentos y todo tipo de información relacionado con una web. Además, se encarga de servir esta información y hacerla llegar a los clientes.

A la hora de crear una página web será necesario contar con un \textbf{dominio} y un \textbf{servidor} donde alojar los archivos de nuestra web. Si se trata de una web muy extensa, se recomienda usar un \textbf{servidor local} mientras se desarrolla, ya que si contratamos un hosting de pago antes de que este finalizada tendremos un periodo de tiempo en el que no lo estaremos usando, ademas tenemos el riesgo de \textbf{no tener} aún el \textbf{SEO adecuado}, ya que durante el proceso de desarrollo se irá añadiendo mucha información.

Un \textbf{servidor local} es simplemente un ordenador común con una serie de aplicaciones instaladas para que podamos usarlo de servidor de pruebas y así corregir las imperfecciones y realizar los cambios necesarios en nuestra página web hasta que estemos seguro de que la podemos poner online. Suelen ser servidores que se instalan en el \textbf{mismo ordenador} u \textbf{otro diferente} en donde se realiza el desarrollo de la web pero que \textbf{solo ofrecen servicios} a nuestra \textbf{red local}.

También tenemos la posibilidad de hacer que \textbf{nuestro ordenador} funcione como un servidor online. En este caso necesitaremos un conjunto de aplicaciones entre las que podemos encontrar:

\begin{itemize}
    \item \textbf{Sistema Operativo}: debemos tener instalado un sistema operativo, ya sea \textbf{Windows}, \textbf{Linux}, \textbf{MacOS} o algún otro de nuestra preferencia.
    \item \textbf{Servidor Web}: debemos tener instalada una aplicación de servidor web, que permita al ordenador ofrecer esta función. Algunos de los más usados son \textbf{Apache}, \textbf{Nginx} o \textbf{LiteSpeed}.
    \item \textbf{Base de Datos}: por norma general las aplicaciones de servidores web nos pedirán que tengamos instalado un sistema de bases de datos. Algunos de los más usados son \textbf{MySQL}, \textbf{PostgreSQL} o \textbf{MongoDB}.
    \item \textbf{Soporte para Lenguaje del Servidor}: también debemos tener instalado el soporte para el lenguaje que vayamos a usar en la parte del servidor o \textbf{backend}, ya sea este \textbf{PHP}, \textbf{Java}, \textbf{Javascript}, \textbf{Ruby}, etc..
\end{itemize}

La mayoría de las aplicaciones que podemos emplear son de \textbf{código abierto} y todas pueden ser instaladas por separado, aunque podemos encontrar \textbf{paquetes} que incluyen todas las aplicaciones necesarias para poder empezar a funcionar como un servidor.

Uno de los paquetes más empleados es \textbf{LAMP} (Linux, Apache, MySQL y PHP), que nos permitirá instalar todo lo necesario de una sola vez así como gestionar los diferentes servicios desde una misma interfaz de forma cómoda y sencilla.


% Glossary

\glsaddall
\printglossaries

% Bibliography

\newpage
\addcontentsline{toc}{chapter}{Bibliografía}
\bibliography{citas}
\bibliographystyle{unsrt}

\end{document}